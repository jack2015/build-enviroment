diff -ruN gcc-4.8.4/libgcc/config/sh/t-generic gcc-4.8.4-stm.150128/libgcc/config/sh/t-generic
--- gcc-4.8.4/libgcc/config/sh/t-generic	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libgcc/config/sh/t-generic	2013-05-28 13:16:16.885075000 +0200
@@ -0,0 +1,2 @@
+# Provide dummy generic threads functions
+LIB2ADD += $(srcdir)/gthr-generic.c
diff -ruN gcc-4.8.4/libgcc/configure gcc-4.8.4-stm.150128/libgcc/configure
--- gcc-4.8.4/libgcc/configure	2013-05-23 10:25:29.376545000 +0200
+++ gcc-4.8.4-stm.150128/libgcc/configure	2014-06-30 10:27:38.105611000 +0200
@@ -4516,6 +4516,7 @@
     single)	thread_header=gthr-single.h ;;
     tpf)	thread_header=config/s390/gthr-tpf.h ;;
     vxworks)	thread_header=config/gthr-vxworks.h ;;
+    generic)	thread_header=gthr-generic.h ;;
     win32)	thread_header=config/i386/gthr-win32.h ;;
 esac
 
diff -ruN gcc-4.8.4/libgcc/gthr-generic.c gcc-4.8.4-stm.150128/libgcc/gthr-generic.c
--- gcc-4.8.4/libgcc/gthr-generic.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libgcc/gthr-generic.c	2014-06-30 11:17:54.536986000 +0200
@@ -0,0 +1,181 @@
+/* Generic threads supplementary implementation. */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997, 1999, 2000, 2002, 2006 Free Software Foundation, Inc.
+   Copyright (c) 2006, 2012 STMicroelectronics.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define __GTHR_WEAK __attribute__ ((weak))
+
+#include "tconfig.h"
+#include "gthr.h"
+
+#ifndef __gthr_generic_h
+#error "Generic thread support package not supported"
+#endif
+
+/* These are stub functions.  When threading is available, a suitable set of definitions should be linked in.  */
+
+/* Return 1 if thread system is active, 0 if not.  */
+int
+__generic_gxx_active_p (void)
+{
+  return 0;
+}
+
+/* The following functions should return zero on success or the error
+   number.  If the operation is not supported, -1 is returned.
+
+   __generic_gxx_once
+   __generic_gxx_key_create
+   __generic_gxx_key_delete
+   __generic_gxx_setspecific
+   __generic_gxx_mutex_lock
+   __generic_gxx_mutex_trylock
+   __generic_gxx_mutex_unlock
+   __generic_gxx_recursive_mutex_lock
+   __generic_gxx_recursive_mutex_trylock
+   __generic_gxx_recursive_mutex_unlock  */
+
+/* FUNC is a function that should be called without parameters.
+   *ONCE has been initialized to __GTHREAD_ONCE_INIT and is otherwise only
+   used in calls to __generic_gxx_once with FUNC as the second parameter.
+   If __generic_gxx_once succeeds, FUNC will have been called exactly once
+   since the initialization of ONCE through any number of calls of
+   __generic_gxx_once with this pair of ONCE and FUNC values.  */
+int
+__generic_gxx_once (__gthread_once_t *once ATTRIBUTE_UNUSED,
+		    void (*func)(void) ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+/* Assign a key to *KEY that can be used in calls to
+   __generic_gxx_setspecific / __generic_gxx_getspecific.
+   If DTOR is nonzero, and at thread exit the value associated with the key
+   is nonzero, DTOR will be called at thread exit with the value associated
+   with the key as its only argument.  */
+int
+__generic_gxx_key_create (__gthread_key_t *key ATTRIBUTE_UNUSED,
+			  void (*dtor)(void *) ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+/* KEY is a key previously allocated by __generic_gxx_key_create.
+   Remove it from the set of keys known for this thread.  */
+int
+__generic_gxx_key_delete (__gthread_key_t key ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+/* Return thread-specific data associated with KEY.  */
+void *
+__generic_gxx_getspecific (__gthread_key_t key ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Set thread-specific data associated with KEY to PTR.  */
+int
+__generic_gxx_setspecific (__gthread_key_t key ATTRIBUTE_UNUSED,
+		      const void *ptr ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+/* Initialize *MUTEX.  */
+void
+__generic_gxx_mutex_init_function (__gthread_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+}
+
+/* Destroy *MUTEX.  */
+int
+__generic_gxx_mutex_destroy (__gthread_mutex_t *__mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Acquire a lock on *MUTEX.  The behaviour is undefined if a lock on *MUTEX
+   has already been acquired by the same thread.  */
+int
+__generic_gxx_mutex_lock (__gthread_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Try to acquire a lock on *MUTEX.  If a lock on *MUTEX already exists,
+   return an error code.  */
+int
+__generic_gxx_mutex_trylock (__gthread_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* A lock on *MUTEX has previously been acquired with __generic_gxx_mutex_lock
+   or __generic_gxx_mutex_trylock.  Release the lock.  */
+int
+__generic_gxx_mutex_unlock (__gthread_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Initialize *MUTEX.  */
+void
+__generic_gxx_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+}
+
+/* Destroy *MUTEX.  */
+int
+__generic_gxx_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Acquire a lock on *MUTEX.  If a lock on *MUTEX has already been acquired by
+   the same thread, succeed.  */
+int
+__generic_gxx_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Try to acquire a lock on *MUTEX.  If a lock on *MUTEX has already been
+   acquired by the same thread, succeed.  If any other lock on *MUTEX
+   already exists, return an error code.  */
+int
+__generic_gxx_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* A lock on *MUTEX has previously been acquired with
+   __generic_gxx_recursive_mutex_lock or
+   __generic_gxx_recursive_mutex_trylock.  Release the lock.  */
+int
+__generic_gxx_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
diff -ruN gcc-4.8.4/libgcc/gthr-generic.h gcc-4.8.4-stm.150128/libgcc/gthr-generic.h
--- gcc-4.8.4/libgcc/gthr-generic.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libgcc/gthr-generic.h	2014-06-30 11:17:54.536986000 +0200
@@ -0,0 +1,385 @@
+/* Generic threads compatibility routines for libgcc2 and libobjc. */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997, 1999, 2000, 2002, 2006 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef __gthr_generic_h
+#define __gthr_generic_h
+
+#define __GTHREADS 1
+
+#define __GTHREAD_ONCE_INIT 0
+#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function
+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Avoid depedency on specific headers.
+   The general idea is that you dynamically allocate the required data
+   structures, and a void * is used to point to this dynamically allocated
+   data.  If your implementation can put all the required information in
+   the void * itself, that's fine, too, of course.
+   libstdc++ inherits from the mutex types, whcih is why they need to be
+   wrapped up as structs.  */
+typedef void *__gthread_key_t;
+typedef void *__gthread_once_t;
+typedef struct __gthread_mutex_s { void *__p; } __gthread_mutex_t;
+typedef struct __gthread_recursive_mutex_s { void *__p; } __gthread_recursive_mutex_t;
+
+/* We should always link with at least one definition, so we want strong
+   references.  The stub definitions are weak so that they can be overriden.  */
+#ifndef __GTHR_WEAK
+#define __GTHR_WEAK
+#endif
+
+extern int __generic_gxx_active_p (void) __GTHR_WEAK;
+
+extern int __generic_gxx_once (__gthread_once_t *, void (*)(void)) __GTHR_WEAK;
+
+extern int __generic_gxx_key_create (__gthread_key_t *,
+				     void (*)(void *)) __GTHR_WEAK;
+
+extern int __generic_gxx_key_delete (__gthread_key_t key) __GTHR_WEAK;
+
+extern void *__generic_gxx_getspecific (__gthread_key_t key) __GTHR_WEAK;
+
+extern int __generic_gxx_setspecific (__gthread_key_t, const void *) __GTHR_WEAK;
+
+extern void __generic_gxx_mutex_init_function (__gthread_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_mutex_destroy (__gthread_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_mutex_lock (__gthread_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_mutex_trylock (__gthread_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_mutex_unlock (__gthread_mutex_t *) __GTHR_WEAK;
+
+extern void __generic_gxx_recursive_mutex_init_function (__gthread_recursive_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_recursive_mutex_destroy (__gthread_recursive_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_recursive_mutex_lock (__gthread_recursive_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_recursive_mutex_trylock (__gthread_recursive_mutex_t *) __GTHR_WEAK;
+
+extern int __generic_gxx_recursive_mutex_unlock (__gthread_recursive_mutex_t *) __GTHR_WEAK;
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef _LIBOBJC
+
+extern int __generic_gxx_objc_init_thread_system (void) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_close_thread_system (void) __GTHR_WEAK;
+
+extern objc_thread_t __generic_gxx_objc_thread_detach (void (*)(void *), void *) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_thread_set_priority (int priority) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_thread_get_priority (void) __GTHR_WEAK;
+
+extern void __generic_gxx_objc_thread_yield (void) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_thread_exit (void) __GTHR_WEAK;
+
+extern objc_thread_t __generic_gxx_objc_thread_id (void) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_thread_set_data (void *value) __GTHR_WEAK;
+
+extern void *__generic_gxx_objc_thread_get_data (void) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_mutex_allocate (objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_mutex_deallocate (objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_mutex_lock (objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_mutex_trylock (objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_mutex_unlock (objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_condition_allocate (objc_condition_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_condition_deallocate (objc_condition_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_condition_wait (objc_condition_t, objc_mutex_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_condition_broadcast (objc_condition_t) __GTHR_WEAK;
+
+extern int __generic_gxx_objc_condition_signal (objc_condition_t) __GTHR_WEAK;
+
+/* Backend initialization functions */
+
+/* Initialize the threads subsystem.  */
+static inline int
+__gthread_objc_init_thread_system (void)
+{
+  return __generic_gxx_objc_init_thread_system ();
+}
+
+/* Close the threads subsystem.  */
+static inline int
+__gthread_objc_close_thread_system (void)
+{
+  return __generic_gxx_objc_close_thread_system ();
+}
+
+/* Backend thread functions */
+
+/* Create a new thread of execution.  */
+static inline objc_thread_t
+__gthread_objc_thread_detach (void (* func)(void *), void * arg)
+{
+  return __generic_gxx_objc_thread_detach (func, arg);
+}
+
+/* Set the current thread's priority.  */
+static inline int
+__gthread_objc_thread_set_priority (int priority)
+{
+  return __generic_gxx_objc_thread_set_priority (priority);
+}
+
+/* Return the current thread's priority.  */
+static inline int
+__gthread_objc_thread_get_priority (void)
+{
+  return __generic_gxx_objc_thread_get_priority ();
+}
+
+/* Yield our process time to another thread.  */
+static inline void
+__gthread_objc_thread_yield (void)
+{
+  __generic_gxx_objc_thread_yield ();
+}
+
+/* Terminate the current thread.  */
+static inline int
+__gthread_objc_thread_exit (void)
+{
+  return __generic_gxx_objc_thread_exit ();
+}
+
+/* Returns an integer value which uniquely describes a thread.  */
+static inline objc_thread_t
+__gthread_objc_thread_id (void)
+{
+  return __generic_gxx_objc_thread_id ();
+}
+
+/* Sets the thread's local storage pointer.  */
+static inline int
+__gthread_objc_thread_set_data (void *value)
+{
+  return __generic_gxx_objc_thread_set_data (value);
+}
+
+/* Returns the thread's local storage pointer.  */
+static inline void *
+__gthread_objc_thread_get_data (void)
+{
+  return __generic_gxx_objc_thread_get_data ();
+}
+
+/* Backend mutex functions */
+
+/* Allocate a mutex.  */
+static inline int
+__gthread_objc_mutex_allocate (objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_mutex_allocate (mutex);
+}
+
+/* Deallocate a mutex.  */
+static inline int
+__gthread_objc_mutex_deallocate (objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_mutex_deallocate (mutex);
+}
+
+/* Grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_lock (objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_mutex_lock (mutex);
+}
+
+/* Try to grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_trylock (objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_mutex_trylock (mutex);
+}
+
+/* Unlock the mutex */
+static inline int
+__gthread_objc_mutex_unlock (objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_mutex_unlock (mutex);
+}
+
+/* Backend condition mutex functions */
+
+/* Allocate a condition.  */
+static inline int
+__gthread_objc_condition_allocate (objc_condition_t condition)
+{
+  return __generic_gxx_objc_condition_allocate (condition);
+}
+
+/* Deallocate a condition.  */
+static inline int
+__gthread_objc_condition_deallocate (objc_condition_t condition)
+{
+  return __generic_gxx_objc_condition_deallocate (condition);
+}
+
+/* Wait on the condition */
+static inline int
+__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)
+{
+  return __generic_gxx_objc_condition_wait (condition, mutex);
+}
+
+/* Wake up all threads waiting on this condition.  */
+static inline int
+__gthread_objc_condition_broadcast (objc_condition_t condition)
+{
+  return __generic_gxx_objc_condition_broadcast ( condition);
+}
+
+/* Wake up one thread waiting on this condition.  */
+static inline int
+__gthread_objc_condition_signal (objc_condition_t condition)
+{
+  return __generic_gxx_objc_condition_signal (condition);
+}
+
+#else /* !_LIBOBJC */
+
+static inline int
+__gthread_active_p (void)
+{
+  return __generic_gxx_active_p ();
+}
+
+static inline int
+__gthread_once (__gthread_once_t *once, void (*func)(void))
+{
+  return __generic_gxx_once (once, func);
+}
+
+static inline int
+__gthread_key_create (__gthread_key_t *key, void (*dtor)(void *))
+{
+  return __generic_gxx_key_create (key, dtor);
+}
+
+static inline int
+__gthread_key_delete (__gthread_key_t key)
+{
+  return __generic_gxx_key_delete (key);
+}
+
+static inline void *
+__gthread_getspecific (__gthread_key_t key)
+{
+  return __generic_gxx_getspecific (key);
+}
+
+static inline int
+__gthread_setspecific (__gthread_key_t key, const void *ptr)
+{
+  return __generic_gxx_setspecific (key, ptr);
+}
+
+static inline void
+__gthread_mutex_init_function (__gthread_mutex_t *mutex)
+{
+  __generic_gxx_mutex_init_function (mutex);
+}
+
+static inline int
+__gthread_mutex_destroy (__gthread_mutex_t * mutex)
+{
+  return __generic_gxx_mutex_destroy (mutex);
+}
+
+static inline int
+__gthread_mutex_lock (__gthread_mutex_t * mutex)
+{
+  return __generic_gxx_mutex_lock (mutex);
+}
+
+static inline int
+__gthread_mutex_trylock (__gthread_mutex_t * mutex)
+{
+  return __generic_gxx_mutex_trylock (mutex);
+}
+
+static inline int
+__gthread_mutex_unlock (__gthread_mutex_t * mutex)
+{
+  return __generic_gxx_mutex_unlock (mutex);
+}
+
+static inline void
+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
+{
+  __generic_gxx_recursive_mutex_init_function (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t * mutex)
+{
+  return __generic_gxx_recursive_mutex_destroy (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t * mutex)
+{
+  return __generic_gxx_recursive_mutex_lock (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t * mutex)
+{
+  return __generic_gxx_recursive_mutex_trylock (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t * mutex)
+{
+  return __generic_gxx_recursive_mutex_unlock (mutex);
+}
+
+#endif /* _LIBOBJC */
+
+#endif /* __gthr_generic_h */
diff -ruN gcc-4.8.4/libstdc++-v3/configure gcc-4.8.4-stm.150128/libstdc++-v3/configure
--- gcc-4.8.4/libstdc++-v3/configure	2014-06-05 11:32:38.738163000 +0200
+++ gcc-4.8.4-stm.150128/libstdc++-v3/configure	2014-06-30 10:27:38.105611000 +0200
@@ -15177,6 +15177,7 @@
     single)	thread_header=gthr-single.h ;;
     tpf)	thread_header=config/s390/gthr-tpf.h ;;
     vxworks)	thread_header=config/gthr-vxworks.h ;;
+    generic)	thread_header=gthr-generic.h ;;
     win32)	thread_header=config/i386/gthr-win32.h ;;
 esac
 
diff -ruN gcc-4.8.4/libstdc++-v3/include/std/mutex gcc-4.8.4-stm.150128/libstdc++-v3/include/std/mutex
--- gcc-4.8.4/libstdc++-v3/include/std/mutex	2013-10-16 16:17:23.864201000 +0200
+++ gcc-4.8.4-stm.150128/libstdc++-v3/include/std/mutex	2013-10-17 12:15:29.460924000 +0200
@@ -102,6 +103,14 @@
 
     ~__recursive_mutex_base()
     { __gthread_recursive_mutex_destroy(&_M_mutex); }
+
+    // default match
+    template<typename _Rm>
+      static 
+      typename enable_if<is_same<_Rm, __gthread_recursive_mutex_t>::__value,
+        void>::__type
+      _S_destroy(_Rm* __mx)
+      { __gthread_recursive_mutex_destroy(__mx); }
 #endif
   };
 
diff -ruN gcc-4.8.4/libstdc++-v3/testsuite/lib/libstdc++.exp gcc-4.8.4-stm.150128/libstdc++-v3/testsuite/lib/libstdc++.exp
--- gcc-4.8.4/libstdc++-v3/testsuite/lib/libstdc++.exp	2013-10-16 16:17:23.864201000 +0200
+++ gcc-4.8.4-stm.150128/libstdc++-v3/testsuite/lib/libstdc++.exp	2013-10-17 12:15:29.460924000 +0200
@@ -93,6 +93,8 @@
     global tool_timeout
     global DEFAULT_CXXFLAGS
     global STATIC_LIBCXXFLAGS
+    global GXX_UNDER_TEST
+    global GCC_UNDER_TEST
 
     # We set LC_ALL and LANG to C so that we get the same error
     # messages as expected.
@@ -209,12 +211,22 @@
     set tool_timeout 600
 
     # Default settings.
-    set cxx [transform "g++"]
+    if [info exists GXX_UNDER_TEST] {
+        set cxx $GXX_UNDER_TEST
+    } else {
+    	set cxx [transform "g++"]
+    }
     set cxxflags "-D_GLIBCXX_ASSERT -fmessage-length=0"
     set cxxpchflags ""
     set cxxvtvflags ""
     set cxxldflags ""
-    set cc [transform "gcc"]
+
+    if [info exists GCC_UNDER_TEST] {
+        set cc $GCC_UNDER_TEST
+    } else {
+    	set cc [transform "gcc"]
+    }
+    
     # Locate testsuite_hooks.h and other testsuite headers.
     set includes "-I${srcdir}/util"
     # Adapt the defaults for special circumstances.
@@ -425,6 +437,8 @@
     global cxxldflags
     global includes
     global STATIC_LIBCXXFLAGS
+    global srcdir
+    global additional_linker_flag
 
     if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
         lappend options "libs=${gluefile}"
@@ -440,6 +454,9 @@
 
     # Flag setting based on type argument.
     if { $type == "executable" } {
+        if { [info exists additional_linker_flag] } {
+           lappend cxx_final $additional_linker_flag
+	}
 	# Link the support objects into executables.
 	lappend options "additional_flags=./libtestc++.a $cxxldflags"
     } else {
@@ -467,6 +484,8 @@
     global cc
     global cxxflags
     global STATIC_LIBCXXFLAGS
+    global srcdir
+    global additional_linker_flag
 
     if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
         lappend options "libs=${gluefile}"
@@ -480,6 +499,10 @@
     set cc_final [concat $cc_final $STATIC_LIBCXXFLAGS]
     set cc_final [concat $cc_final $cxxflags]
     set cc_final [concat $cc_final $includes]
+    if { [info exists additional_linker_flag] } {
+        lappend cc_final $additional_linker_flag
+    }
+    
     regsub -all {\s[-]nostdinc[+][+]} $cc_final "" cc_final
 
     # This is needed for "C" tests, as this type of test may need the
diff -ruN gcc-4.8.4/gcc/testsuite/gcc.target/sh/executejava_standard.c gcc-4.8.4-stm.150128/gcc/testsuite/gcc.target/sh/executejava_standard.c
--- gcc-4.8.4/gcc/testsuite/gcc.target/sh/executejava_standard.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/gcc/testsuite/gcc.target/sh/executejava_standard.c	2013-05-28 13:15:34.280352000 +0200
@@ -0,0 +1,10235 @@
+/* { dg-do compile { target "sh-*-*" } } */
+/* { dg-options "-w" } */
+
+typedef long long CVMInt64;
+typedef int CVMInt32;
+typedef short CVMInt16;
+typedef signed char CVMInt8;
+typedef unsigned long long CVMUint64;
+typedef unsigned int CVMUint32;
+typedef unsigned short CVMUint16;
+typedef unsigned char CVMUint8;
+typedef float CVMfloat32;
+typedef double CVMfloat64;
+typedef unsigned int CVMAddr;
+typedef unsigned int CVMSize;
+typedef int ptrdiff_t;
+typedef unsigned int size_t;
+typedef long int wchar_t;
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+__extension__ typedef __u_quad_t __dev_t;
+__extension__ typedef unsigned int __uid_t;
+__extension__ typedef unsigned int __gid_t;
+__extension__ typedef unsigned long int __ino_t;
+__extension__ typedef __u_quad_t __ino64_t;
+__extension__ typedef unsigned int __mode_t;
+__extension__ typedef unsigned int __nlink_t;
+__extension__ typedef long int __off_t;
+__extension__ typedef __quad_t __off64_t;
+__extension__ typedef int __pid_t;
+__extension__ typedef struct { int __val[2]; } __fsid_t;
+__extension__ typedef long int __clock_t;
+__extension__ typedef unsigned long int __rlim_t;
+__extension__ typedef __u_quad_t __rlim64_t;
+__extension__ typedef unsigned int __id_t;
+__extension__ typedef long int __time_t;
+__extension__ typedef unsigned int __useconds_t;
+__extension__ typedef long int __suseconds_t;
+__extension__ typedef int __daddr_t;
+__extension__ typedef long int __swblk_t;
+__extension__ typedef int __key_t;
+__extension__ typedef int __clockid_t;
+__extension__ typedef void * __timer_t;
+__extension__ typedef long int __blksize_t;
+__extension__ typedef long int __blkcnt_t;
+__extension__ typedef __quad_t __blkcnt64_t;
+__extension__ typedef unsigned long int __fsblkcnt_t;
+__extension__ typedef __u_quad_t __fsblkcnt64_t;
+__extension__ typedef unsigned long int __fsfilcnt_t;
+__extension__ typedef __u_quad_t __fsfilcnt64_t;
+__extension__ typedef int __ssize_t;
+typedef __off64_t __loff_t;
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+__extension__ typedef int __intptr_t;
+__extension__ typedef unsigned int __socklen_t;
+struct _IO_FILE;
+typedef struct _IO_FILE FILE;
+typedef struct _IO_FILE __FILE;
+typedef struct
+{
+  int __count;
+  union
+  {
+    unsigned int __wch;
+    char __wchb[4];
+  } __value;
+} __mbstate_t;
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
+typedef __builtin_va_list __gnuc_va_list;
+struct _IO_jump_t; struct _IO_FILE;
+typedef void _IO_lock_t;
+struct _IO_marker {
+  struct _IO_marker *_next;
+  struct _IO_FILE *_sbuf;
+  int _pos;
+};
+enum __codecvt_result
+{
+  __codecvt_ok,
+  __codecvt_partial,
+  __codecvt_error,
+  __codecvt_noconv
+};
+struct _IO_FILE {
+  int _flags;
+  char* _IO_read_ptr;
+  char* _IO_read_end;
+  char* _IO_read_base;
+  char* _IO_write_base;
+  char* _IO_write_ptr;
+  char* _IO_write_end;
+  char* _IO_buf_base;
+  char* _IO_buf_end;
+  char *_IO_save_base;
+  char *_IO_backup_base;
+  char *_IO_save_end;
+  struct _IO_marker *_markers;
+  struct _IO_FILE *_chain;
+  int _fileno;
+  int _flags2;
+  __off_t _old_offset;
+  unsigned short _cur_column;
+  signed char _vtable_offset;
+  char _shortbuf[1];
+  _IO_lock_t *_lock;
+  __off64_t _offset;
+  void *__pad1;
+  void *__pad2;
+  void *__pad3;
+  void *__pad4;
+  size_t __pad5;
+  int _mode;
+  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
+};
+typedef struct _IO_FILE _IO_FILE;
+struct _IO_FILE_plus;
+extern struct _IO_FILE_plus _IO_2_1_stdin_;
+extern struct _IO_FILE_plus _IO_2_1_stdout_;
+extern struct _IO_FILE_plus _IO_2_1_stderr_;
+typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
+typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
+     size_t __n);
+typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);
+typedef int __io_close_fn (void *__cookie);
+typedef __io_read_fn cookie_read_function_t;
+typedef __io_write_fn cookie_write_function_t;
+typedef __io_seek_fn cookie_seek_function_t;
+typedef __io_close_fn cookie_close_function_t;
+typedef struct
+{
+  __io_read_fn *read;
+  __io_write_fn *write;
+  __io_seek_fn *seek;
+  __io_close_fn *close;
+} _IO_cookie_io_functions_t;
+typedef _IO_cookie_io_functions_t cookie_io_functions_t;
+struct _IO_cookie_file;
+extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
+        void *__cookie, _IO_cookie_io_functions_t __fns);
+extern int __underflow (_IO_FILE *);
+extern int __uflow (_IO_FILE *);
+extern int __overflow (_IO_FILE *, int);
+extern int _IO_getc (_IO_FILE *__fp);
+extern int _IO_putc (int __c, _IO_FILE *__fp);
+extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
+extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));
+extern int _IO_peekc_locked (_IO_FILE *__fp);
+extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
+   __gnuc_va_list, int *__restrict);
+extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
+    __gnuc_va_list);
+extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
+extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);
+extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
+extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);
+extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
+typedef __gnuc_va_list va_list;
+typedef _G_fpos_t fpos_t;
+typedef _G_fpos64_t fpos64_t;
+extern struct _IO_FILE *stdin;
+extern struct _IO_FILE *stdout;
+extern struct _IO_FILE *stderr;
+extern int remove (__const char *__filename) __attribute__ ((__nothrow__));
+extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));
+extern int renameat (int __oldfd, __const char *__old, int __newfd,
+       __const char *__new) __attribute__ ((__nothrow__));
+extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
+extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));
+extern char *tmpnam (char *__s) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *tempnam (__const char *__dir, __const char *__pfx)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern int fclose (FILE *__stream);
+extern int fflush (FILE *__stream);
+extern int fflush_unlocked (FILE *__stream);
+extern int fcloseall (void);
+extern FILE *fopen (__const char *__restrict __filename,
+      __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
+extern FILE *freopen (__const char *__restrict __filename,
+        __const char *__restrict __modes,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern FILE *fopen64 (__const char *__restrict __filename,
+        __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
+extern FILE *freopen64 (__const char *__restrict __filename,
+   __const char *__restrict __modes,
+   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *fopencookie (void *__restrict __magic_cookie,
+     __const char *__restrict __modes,
+     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
+  __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));
+extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
+      int __modes, size_t __n) __attribute__ ((__nothrow__));
+extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
+         size_t __size) __attribute__ ((__nothrow__));
+extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));
+extern int fprintf (FILE *__restrict __stream,
+      __const char *__restrict __format, ...);
+extern int printf (__const char *__restrict __format, ...);
+extern int sprintf (char *__restrict __s,
+      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg);
+extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);
+extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg) __attribute__ ((__nothrow__));
+extern int snprintf (char *__restrict __s, size_t __maxlen,
+       __const char *__restrict __format, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int vsnprintf (char *__restrict __s, size_t __maxlen,
+        __const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
+extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
+        __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
+extern int __asprintf (char **__restrict __ptr,
+         __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern int asprintf (char **__restrict __ptr,
+       __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern int vdprintf (int __fd, __const char *__restrict __fmt,
+       __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int fscanf (FILE *__restrict __stream,
+     __const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));
+extern int scanf (__const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));
+extern int sscanf (__const char *__restrict __s,
+     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
+      __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
+extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
+extern int vsscanf (__const char *__restrict __s,
+      __const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
+extern int fgetc (FILE *__stream);
+extern int getc (FILE *__stream);
+extern int getchar (void);
+extern int getc_unlocked (FILE *__stream);
+extern int getchar_unlocked (void);
+extern int fgetc_unlocked (FILE *__stream);
+extern int fputc (int __c, FILE *__stream);
+extern int putc (int __c, FILE *__stream);
+extern int putchar (int __c);
+extern int fputc_unlocked (int __c, FILE *__stream);
+extern int putc_unlocked (int __c, FILE *__stream);
+extern int putchar_unlocked (int __c);
+extern int getw (FILE *__stream);
+extern int putw (int __w, FILE *__stream);
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+     __attribute__ ((__warn_unused_result__));
+extern char *gets (char *__s) __attribute__ ((__warn_unused_result__));
+extern char *fgets_unlocked (char *__restrict __s, int __n,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t __getdelim (char **__restrict __lineptr,
+          size_t *__restrict __n, int __delimiter,
+          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t getdelim (char **__restrict __lineptr,
+        size_t *__restrict __n, int __delimiter,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t getline (char **__restrict __lineptr,
+       size_t *__restrict __n,
+       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);
+extern int puts (__const char *__s);
+extern int ungetc (int __c, FILE *__stream);
+extern size_t fread (void *__restrict __ptr, size_t __size,
+       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
+        size_t __n, FILE *__restrict __s) __attribute__ ((__warn_unused_result__));
+extern int fputs_unlocked (__const char *__restrict __s,
+      FILE *__restrict __stream);
+extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
+         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
+          size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern int fseek (FILE *__stream, long int __off, int __whence);
+extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern void rewind (FILE *__stream);
+extern int fseeko (FILE *__stream, __off_t __off, int __whence);
+extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
+extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
+extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
+extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
+extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
+extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));
+extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
+extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void perror (__const char *__s);
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *popen (__const char *__command, __const char *__modes) __attribute__ ((__warn_unused_result__));
+extern int pclose (FILE *__stream);
+extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
+extern char *cuserid (char *__s);
+struct obstack;
+extern int obstack_printf (struct obstack *__restrict __obstack,
+      __const char *__restrict __format, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int obstack_vprintf (struct obstack *__restrict __obstack,
+       __const char *__restrict __format,
+       __gnuc_va_list __args)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));
+extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));
+extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
+extern __inline int
+getchar (void)
+{
+  return _IO_getc (stdin);
+}
+extern __inline int
+fgetc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline int
+getc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline int
+getchar_unlocked (void)
+{
+  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
+}
+extern __inline int
+putchar (int __c)
+{
+  return _IO_putc (__c, stdout);
+}
+extern __inline int
+fputc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline int
+putc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline int
+putchar_unlocked (int __c)
+{
+  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
+}
+extern __inline __ssize_t
+getline (char **__lineptr, size_t *__n, FILE *__stream)
+{
+  return __getdelim (__lineptr, __n, '\n', __stream);
+}
+extern __inline int
+__attribute__ ((__nothrow__)) feof_unlocked (FILE *__stream)
+{
+  return (((__stream)->_flags & 0x10) != 0);
+}
+extern __inline int
+__attribute__ ((__nothrow__)) ferror_unlocked (FILE *__stream)
+{
+  return (((__stream)->_flags & 0x20) != 0);
+}
+extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+      __const char *__restrict __format,
+      __gnuc_va_list __ap) __attribute__ ((__nothrow__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) sprintf (char *__restrict __s, __const char *__restrict __fmt, ...)
+{
+  return __builtin___sprintf_chk (__s, 2 - 1,
+      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vsprintf (char *__restrict __s, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __builtin___vsprintf_chk (__s, 2 - 1,
+       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
+}
+extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
+      size_t __slen, __const char *__restrict __format,
+      ...) __attribute__ ((__nothrow__));
+extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
+       size_t __slen, __const char *__restrict __format,
+       __gnuc_va_list __ap) __attribute__ ((__nothrow__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) snprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, ...)
+{
+  return __builtin___snprintf_chk (__s, __n, 2 - 1,
+       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vsnprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
+        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
+}
+extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
+     __const char *__restrict __format, ...);
+extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
+extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
+      __const char *__restrict __format, __gnuc_va_list __ap);
+extern int __vprintf_chk (int __flag, __const char *__restrict __format,
+     __gnuc_va_list __ap);
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
+{
+  return __fprintf_chk (__stream, 2 - 1, __fmt,
+   __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+printf (__const char *__restrict __fmt, ...)
+{
+  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vprintf (__const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vfprintf (FILE *__restrict __stream,
+   __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
+}
+extern int __asprintf_chk (char **__restrict __ptr, int __flag,
+      __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
+extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
+       __const char *__restrict __fmt, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
+extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
+     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __vdprintf_chk (int __fd, int __flag,
+      __const char *__restrict __fmt, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 3, 0)));
+extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
+     int __flag, __const char *__restrict __format,
+     ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
+      int __flag,
+      __const char *__restrict __format,
+      __gnuc_va_list __args)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)
+{
+  return __asprintf_chk (__ptr, 2 - 1, __fmt,
+    __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) __asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)
+{
+  return __asprintf_chk (__ptr, 2 - 1, __fmt,
+    __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+dprintf (int __fd, __const char *__restrict __fmt, ...)
+{
+  return __dprintf_chk (__fd, 2 - 1, __fmt,
+   __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) obstack_printf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, ...)
+{
+  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
+          __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vasprintf (char **__restrict __ptr, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vdprintf (int __fd, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) obstack_vprintf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
+    __ap);
+}
+extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused_result__));
+extern char *__gets_warn (char *__str) __asm__ ("" "gets")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use fgets or getline instead, gets can't " "specify buffer size")))
+                               ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+gets (char *__str)
+{
+  if (__builtin_object_size (__str, 2 > 1) != (size_t) -1)
+    return __gets_chk (__str, __builtin_object_size (__str, 2 > 1));
+  return __gets_warn (__str);
+}
+extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
+     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")
+                                        __attribute__ ((__warn_unused_result__));
+extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+ return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
+ return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+    }
+  return __fgets_alias (__s, __n, __stream);
+}
+extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
+      size_t __size, size_t __n,
+      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")
+            __attribute__ ((__warn_unused_result__));
+extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
+fread (void *__restrict __ptr, size_t __size, size_t __n,
+       FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+   || !__builtin_constant_p (__n)
+   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+ return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
+      if (__size * __n > __builtin_object_size (__ptr, 0))
+ return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
+    }
+  return __fread_alias (__ptr, __size, __n, __stream);
+}
+extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
+       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")
+                                                 __attribute__ ((__warn_unused_result__));
+extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+ return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
+ return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+    }
+  return __fgets_unlocked_alias (__s, __n, __stream);
+}
+extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
+        size_t __size, size_t __n,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")
+                     __attribute__ ((__warn_unused_result__));
+extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
+                                        ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
+fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
+  FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+   || !__builtin_constant_p (__n)
+   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+ return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
+         __stream);
+      if (__size * __n > __builtin_object_size (__ptr, 0))
+ return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
+       __stream);
+    }
+  if (__builtin_constant_p (__size)
+      && __builtin_constant_p (__n)
+      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
+      && __size * __n <= 8)
+    {
+      size_t __cnt = __size * __n;
+      char *__cptr = (char *) __ptr;
+      if (__cnt == 0)
+ return 0;
+      for (; __cnt > 0; --__cnt)
+ {
+   int __c = (__builtin_expect (((__stream)->_IO_read_ptr >= (__stream)->_IO_read_end), 0) ? __uflow (__stream) : *(unsigned char *) (__stream)->_IO_read_ptr++);
+   if (__c == (-1))
+     break;
+   *__cptr++ = __c;
+ }
+      return (__cptr - (char *) __ptr) / __size;
+    }
+  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
+}
+extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *calloc (size_t __nmemb, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) __attribute__ ((__nothrow__));
+extern void cfree (void *__ptr) __attribute__ ((__nothrow__));
+extern void *memalign (size_t __alignment, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *valloc (size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void * pvalloc (size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *(*__morecore) (ptrdiff_t __size);
+extern void *__default_morecore (ptrdiff_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__));
+struct mallinfo {
+  int arena;
+  int ordblks;
+  int smblks;
+  int hblks;
+  int hblkhd;
+  int usmblks;
+  int fsmblks;
+  int uordblks;
+  int fordblks;
+  int keepcost;
+};
+extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__));
+extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__));
+extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__));
+extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__));
+extern void malloc_stats (void) __attribute__ ((__nothrow__));
+extern int malloc_info (int __options, FILE *__fp);
+extern void *malloc_get_state (void) __attribute__ ((__nothrow__));
+extern int malloc_set_state (void *__ptr) __attribute__ ((__nothrow__));
+extern void (*__malloc_initialize_hook) (void);
+extern void (*__free_hook) (void *__ptr, __const void *)
+                             ;
+extern void *(*__malloc_hook) (size_t __size, __const void *)
+                                  ;
+extern void *(*__realloc_hook) (void *__ptr, size_t __size, __const void *)
+                                   ;
+extern void *(*__memalign_hook) (size_t __alignment, size_t __size, __const void *)
+                                    ;
+extern void (*__after_morecore_hook) (void);
+extern void __malloc_check_init (void) __attribute__ ((__nothrow__));
+struct timespec
+  {
+    __time_t tv_sec;
+    long int tv_nsec;
+  };
+struct sched_param
+  {
+    int __sched_priority;
+  };
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+    int __flags, void *__arg, ...) __attribute__ ((__nothrow__));
+extern int unshare (int __flags) __attribute__ ((__nothrow__));
+extern int sched_getcpu (void) __attribute__ ((__nothrow__));
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+typedef unsigned long int __cpu_mask;
+typedef struct
+{
+  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
+} cpu_set_t;
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+  __attribute__ ((__nothrow__));
+extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__));
+extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
+     __attribute__ ((__nothrow__));
+extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__));
+extern int sched_setscheduler (__pid_t __pid, int __policy,
+          __const struct sched_param *__param) __attribute__ ((__nothrow__));
+extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__));
+extern int sched_yield (void) __attribute__ ((__nothrow__));
+extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__));
+extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__));
+extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__));
+extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
+         __const cpu_set_t *__cpuset) __attribute__ ((__nothrow__));
+extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
+         cpu_set_t *__cpuset) __attribute__ ((__nothrow__));
+typedef __clock_t clock_t;
+typedef __time_t time_t;
+typedef __clockid_t clockid_t;
+typedef __timer_t timer_t;
+struct tm
+{
+  int tm_sec;
+  int tm_min;
+  int tm_hour;
+  int tm_mday;
+  int tm_mon;
+  int tm_year;
+  int tm_wday;
+  int tm_yday;
+  int tm_isdst;
+  long int tm_gmtoff;
+  __const char *tm_zone;
+};
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+struct sigevent;
+typedef __pid_t pid_t;
+extern clock_t clock (void) __attribute__ ((__nothrow__));
+extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));
+extern double difftime (time_t __time1, time_t __time0)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+   __const char *__restrict __format,
+   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern char *strptime (__const char *__restrict __s,
+         __const char *__restrict __fmt, struct tm *__tp)
+     __attribute__ ((__nothrow__));
+typedef struct __locale_struct
+{
+  struct locale_data *__locales[13];
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+  const char *__names[13];
+} *__locale_t;
+typedef __locale_t locale_t;
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+     __const char *__restrict __format,
+     __const struct tm *__restrict __tp,
+     __locale_t __loc) __attribute__ ((__nothrow__));
+extern char *strptime_l (__const char *__restrict __s,
+    __const char *__restrict __fmt, struct tm *__tp,
+    __locale_t __loc) __attribute__ ((__nothrow__));
+extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern struct tm *gmtime_r (__const time_t *__restrict __timer,
+       struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern struct tm *localtime_r (__const time_t *__restrict __timer,
+          struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));
+extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern char *asctime_r (__const struct tm *__restrict __tp,
+   char *__restrict __buf) __attribute__ ((__nothrow__));
+extern char *ctime_r (__const time_t *__restrict __timer,
+        char *__restrict __buf) __attribute__ ((__nothrow__));
+extern char *__tzname[2];
+extern int __daylight;
+extern long int __timezone;
+extern char *tzname[2];
+extern void tzset (void) __attribute__ ((__nothrow__));
+extern int daylight;
+extern long int timezone;
+extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
+extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));
+extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));
+extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int nanosleep (__const struct timespec *__requested_time,
+        struct timespec *__remaining);
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));
+extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
+     __attribute__ ((__nothrow__));
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+       __const struct timespec *__req,
+       struct timespec *__rem);
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));
+extern int timer_create (clockid_t __clock_id,
+    struct sigevent *__restrict __evp,
+    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));
+extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));
+extern int timer_settime (timer_t __timerid, int __flags,
+     __const struct itimerspec *__restrict __value,
+     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     __attribute__ ((__nothrow__));
+extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
+extern int getdate_err;
+extern struct tm *getdate (__const char *__string);
+extern int getdate_r (__const char *__restrict __string,
+        struct tm *__restrict __resbufp);
+typedef int __sig_atomic_t;
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+typedef __sigset_t sigset_t;
+typedef unsigned long int pthread_t;
+typedef union
+{
+  char __size[36];
+  long int __align;
+} pthread_attr_t;
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[24];
+  long int __align;
+} pthread_mutex_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_mutexattr_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[48];
+  __extension__ long long int __align;
+} pthread_cond_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_condattr_t;
+typedef unsigned int pthread_key_t;
+typedef int pthread_once_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+    pthread_t __writer;
+  } __data;
+  char __size[32];
+  long int __align;
+} pthread_rwlock_t;
+typedef union
+{
+  char __size[8];
+  long int __align;
+} pthread_rwlockattr_t;
+typedef volatile int pthread_spinlock_t;
+typedef union
+{
+  char __size[20];
+  long int __align;
+} pthread_barrier_t;
+typedef union
+{
+  char __size[4];
+  int __align;
+} pthread_barrierattr_t;
+typedef struct __jmp_buf_internal_tag
+  {
+    int __regs[8];
+    void * __pc;
+    void * __gbr;
+    int __fpscr;
+    int __fpregs[4];
+  } __jmp_buf[1];
+enum
+{
+  PTHREAD_CREATE_JOINABLE,
+  PTHREAD_CREATE_DETACHED
+};
+enum
+{
+  PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_ADAPTIVE_NP
+  ,
+  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
+  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
+};
+enum
+{
+  PTHREAD_MUTEX_STALLED,
+  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
+  PTHREAD_MUTEX_ROBUST,
+  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
+};
+enum
+{
+  PTHREAD_PRIO_NONE,
+  PTHREAD_PRIO_INHERIT,
+  PTHREAD_PRIO_PROTECT
+};
+enum
+{
+  PTHREAD_RWLOCK_PREFER_READER_NP,
+  PTHREAD_RWLOCK_PREFER_WRITER_NP,
+  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
+  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
+};
+enum
+{
+  PTHREAD_INHERIT_SCHED,
+  PTHREAD_EXPLICIT_SCHED
+};
+enum
+{
+  PTHREAD_SCOPE_SYSTEM,
+  PTHREAD_SCOPE_PROCESS
+};
+enum
+{
+  PTHREAD_PROCESS_PRIVATE,
+  PTHREAD_PROCESS_SHARED
+};
+struct _pthread_cleanup_buffer
+{
+  void (*__routine) (void *);
+  void *__arg;
+  int __canceltype;
+  struct _pthread_cleanup_buffer *__prev;
+};
+enum
+{
+  PTHREAD_CANCEL_ENABLE,
+  PTHREAD_CANCEL_DISABLE
+};
+enum
+{
+  PTHREAD_CANCEL_DEFERRED,
+  PTHREAD_CANCEL_ASYNCHRONOUS
+};
+extern int pthread_create (pthread_t *__restrict __newthread,
+      __const pthread_attr_t *__restrict __attr,
+      void *(*__start_routine) (void *),
+      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
+extern int pthread_join (pthread_t __th, void **__thread_return);
+extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__));
+extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
+     __const struct timespec *__abstime);
+extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__));
+extern pthread_t pthread_self (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __attribute__ ((__nothrow__));
+extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_destroy (pthread_attr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
+     int *__detachstate)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
+     int __detachstate)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
+          size_t *__guardsize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
+          size_t __guardsize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
+           __attr,
+           struct sched_param *__restrict __param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
+           __const struct sched_param *__restrict
+           __param) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
+     __attr, int *__restrict __policy)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
+      __attr, int *__restrict __inherit)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
+      int __inherit)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
+      int *__restrict __scope)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
+          __attr, void **__restrict __stackaddr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));
+extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
+          void *__stackaddr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));
+extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
+          __attr, size_t *__restrict __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
+          size_t __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
+      void **__restrict __stackaddr,
+      size_t *__restrict __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
+      size_t __stacksize) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
+     size_t __cpusetsize,
+     __const cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
+     size_t __cpusetsize,
+     cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
+      __const struct sched_param *__param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_getschedparam (pthread_t __target_thread,
+      int *__restrict __policy,
+      struct sched_param *__restrict __param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
+     __attribute__ ((__nothrow__));
+extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__));
+extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__));
+extern int pthread_yield (void) __attribute__ ((__nothrow__));
+extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
+       __const cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
+       cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_once (pthread_once_t *__once_control,
+    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_setcancelstate (int __state, int *__oldstate);
+extern int pthread_setcanceltype (int __type, int *__oldtype);
+extern int pthread_cancel (pthread_t __th);
+extern void pthread_testcancel (void);
+typedef struct
+{
+  struct
+  {
+    __jmp_buf __cancel_jmp_buf;
+    int __mask_was_saved;
+  } __cancel_jmp_buf[1];
+  void *__pad[4];
+} __pthread_unwind_buf_t __attribute__ ((__aligned__));
+struct __pthread_cleanup_frame
+{
+  void (*__cancel_routine) (void *);
+  void *__cancel_arg;
+  int __do_it;
+  int __cancel_type;
+};
+extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
+     ;
+extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
+  ;
+extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
+     ;
+extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
+  ;
+extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
+     __attribute__ ((__noreturn__))
+     __attribute__ ((__weak__))
+     ;
+struct __jmp_buf_tag;
+extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));
+extern int pthread_mutex_init (pthread_mutex_t *__mutex,
+          __const pthread_mutexattr_t *__mutexattr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
+                                    __const struct timespec *__restrict
+                                    __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
+      __restrict __mutex,
+      int *__restrict __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
+      int __prioceiling,
+      int *__restrict __old_ceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
+      __restrict __attr,
+      int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
+      int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
+          __attr, int *__restrict __kind)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
+       __restrict __attr,
+       int *__restrict __protocol)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
+       int __protocol)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
+          __restrict __attr,
+          int *__restrict __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
+          int __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
+     int *__robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
+        int *__robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
+     int __robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
+        int __robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
+    __const pthread_rwlockattr_t *__restrict
+    __attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
+  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
+           __const struct timespec *__restrict
+           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
+           __const struct timespec *__restrict
+           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
+       __restrict __attr,
+       int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
+       int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
+       __restrict __attr,
+       int *__restrict __pref)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
+       int __pref) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
+         __const pthread_condattr_t *__restrict
+         __cond_attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_destroy (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_signal (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_broadcast (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
+         pthread_mutex_t *__restrict __mutex)
+     __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
+       pthread_mutex_t *__restrict __mutex,
+       __const struct timespec *__restrict
+       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int pthread_condattr_init (pthread_condattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_getpshared (__const pthread_condattr_t *
+                                        __restrict __attr,
+                                        int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
+                                        int __pshared) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_getclock (__const pthread_condattr_t *
+          __restrict __attr,
+          __clockid_t *__restrict __clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
+          __clockid_t __clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_lock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
+     __const pthread_barrierattr_t *__restrict
+     __attr, unsigned int __count)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
+        __restrict __attr,
+        int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
+                                           int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_key_create (pthread_key_t *__key,
+          void (*__destr_function) (void *))
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__));
+extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__));
+extern int pthread_setspecific (pthread_key_t __key,
+    __const void *__pointer) __attribute__ ((__nothrow__)) ;
+extern int pthread_getcpuclockid (pthread_t __thread_id,
+      __clockid_t *__clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int pthread_atfork (void (*__prepare) (void),
+      void (*__parent) (void),
+      void (*__child) (void)) __attribute__ ((__nothrow__));
+extern __inline int
+__attribute__ ((__nothrow__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
+{
+  return __thread1 == __thread2;
+}
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+typedef __loff_t loff_t;
+typedef __ino_t ino_t;
+typedef __ino64_t ino64_t;
+typedef __dev_t dev_t;
+typedef __gid_t gid_t;
+typedef __mode_t mode_t;
+typedef __nlink_t nlink_t;
+typedef __uid_t uid_t;
+typedef __off_t off_t;
+typedef __off64_t off64_t;
+typedef __id_t id_t;
+typedef __ssize_t ssize_t;
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+typedef __key_t key_t;
+typedef __useconds_t useconds_t;
+typedef __suseconds_t suseconds_t;
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+typedef int int8_t __attribute__ ((__mode__ (__QI__)));
+typedef int int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int int32_t __attribute__ ((__mode__ (__SI__)));
+typedef int int64_t __attribute__ ((__mode__ (__DI__)));
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+typedef long int __fd_mask;
+typedef struct
+  {
+    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];
+  } fd_set;
+typedef __fd_mask fd_mask;
+extern int select (int __nfds, fd_set *__restrict __readfds,
+     fd_set *__restrict __writefds,
+     fd_set *__restrict __exceptfds,
+     struct timeval *__restrict __timeout);
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+      fd_set *__restrict __writefds,
+      fd_set *__restrict __exceptfds,
+      const struct timespec *__restrict __timeout,
+      const __sigset_t *__restrict __sigmask);
+__extension__
+extern unsigned int gnu_dev_major (unsigned long long int __dev)
+     __attribute__ ((__nothrow__));
+__extension__
+extern unsigned int gnu_dev_minor (unsigned long long int __dev)
+     __attribute__ ((__nothrow__));
+__extension__
+extern unsigned long long int gnu_dev_makedev (unsigned int __major,
+            unsigned int __minor)
+     __attribute__ ((__nothrow__));
+__extension__ extern __inline unsigned int
+__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
+{
+  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
+}
+__extension__ extern __inline unsigned int
+__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
+{
+  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
+}
+__extension__ extern __inline unsigned long long int
+__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
+{
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+   | (((unsigned long long int) (__minor & ~0xff)) << 12)
+   | (((unsigned long long int) (__major & ~0xfff)) << 32));
+}
+typedef __blksize_t blksize_t;
+typedef __blkcnt_t blkcnt_t;
+typedef __fsblkcnt_t fsblkcnt_t;
+typedef __fsfilcnt_t fsfilcnt_t;
+typedef __blkcnt64_t blkcnt64_t;
+typedef __fsblkcnt64_t fsblkcnt64_t;
+typedef __fsfilcnt64_t fsfilcnt64_t;
+typedef union
+{
+  char __size[16];
+  long int __align;
+} sem_t;
+extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
+     __attribute__ ((__nothrow__));
+extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__));
+extern sem_t *sem_open (__const char *__name, int __oflag, ...) __attribute__ ((__nothrow__));
+extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_unlink (__const char *__name) __attribute__ ((__nothrow__));
+extern int sem_wait (sem_t *__sem);
+extern int sem_timedwait (sem_t *__restrict __sem,
+     __const struct timespec *__restrict __abstime);
+extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
+     __attribute__ ((__nothrow__));
+typedef CVMInt8 CVMJavaByte;
+typedef CVMInt16 CVMJavaShort;
+typedef CVMUint16 CVMJavaChar;
+typedef CVMUint8 CVMJavaBoolean;
+typedef CVMInt32 CVMJavaInt;
+typedef CVMfloat32 CVMJavaFloat;
+typedef CVMInt64 CVMJavaLong;
+typedef CVMfloat64 CVMJavaDouble;
+typedef CVMUint32 CVMBool;
+typedef struct CVMMutex CVMMutex;
+typedef struct CVMCondVar CVMCondVar;
+typedef struct CVMMicroLock CVMMicroLock;
+typedef struct CVMThreadID CVMThreadID;
+typedef struct CVMTargetGlobalState CVMTargetGlobalState;
+typedef char CVMUtf8;
+typedef struct CVMObjectHeader CVMObjectHeader;
+typedef union CVMVariousBits CVMVariousBits;
+typedef union CVMJavaVal8 CVMJavaVal8;
+typedef union CVMJavaVal16 CVMJavaVal16;
+typedef union CVMJavaVal32 CVMJavaVal32;
+typedef union CVMJavaVal64 CVMJavaVal64;
+typedef struct CVMjava_lang_Object CVMjava_lang_Object;
+typedef struct CVMSyncVector CVMSyncVector;
+typedef CVMjava_lang_Object CVMObject;
+typedef struct CVMArrayOfByte CVMArrayOfByte;
+typedef struct CVMArrayOfShort CVMArrayOfShort;
+typedef struct CVMArrayOfChar CVMArrayOfChar;
+typedef struct CVMArrayOfBoolean CVMArrayOfBoolean;
+typedef struct CVMArrayOfInt CVMArrayOfInt;
+typedef struct CVMArrayOfRef CVMArrayOfRef;
+typedef struct CVMArrayOfFloat CVMArrayOfFloat;
+typedef struct CVMArrayOfLong CVMArrayOfLong;
+typedef struct CVMArrayOfDouble CVMArrayOfDouble;
+typedef struct CVMArrayOfAnyType CVMArrayOfAnyType;
+typedef struct CVMjava_lang_ObjectICell CVMjava_lang_ObjectICell;
+typedef struct CVMObjectICell CVMObjectICell;
+typedef struct CVMArrayOfByteICell CVMArrayOfByteICell;
+typedef struct CVMArrayOfShortICell CVMArrayOfShortICell;
+typedef struct CVMArrayOfCharICell CVMArrayOfCharICell;
+typedef struct CVMArrayOfBooleanICell CVMArrayOfBooleanICell;
+typedef struct CVMArrayOfIntICell CVMArrayOfIntICell;
+typedef struct CVMArrayOfRefICell CVMArrayOfRefICell;
+typedef struct CVMArrayOfFloatICell CVMArrayOfFloatICell;
+typedef struct CVMArrayOfLongICell CVMArrayOfLongICell;
+typedef struct CVMArrayOfDoubleICell CVMArrayOfDoubleICell;
+typedef struct CVMArrayOfAnyTypeICell CVMArrayOfAnyTypeICell;
+typedef struct CVMClassBlock CVMClassBlock;
+typedef union CVMGCBitMap CVMGCBitMap;
+typedef struct CVMBigGCBitMap CVMBigGCBitMap;
+typedef struct CVMArrayInfo CVMArrayInfo;
+typedef struct CVMInterfaces CVMInterfaces;
+typedef struct CVMInterfaceTable CVMInterfaceTable;
+typedef struct CVMMethodBlock CVMMethodBlock;
+typedef struct CVMMethodBlockImmutable CVMMethodBlockImmutable;
+typedef struct CVMMethodRange CVMMethodRange;
+typedef struct CVMMethodArray CVMMethodArray;
+typedef struct CVMCheckedExceptions CVMCheckedExceptions;
+typedef struct CVMJavaMethodDescriptor CVMJavaMethodDescriptor;
+typedef struct CVMExceptionHandler CVMExceptionHandler;
+typedef struct CVMLineNumberEntry CVMLineNumberEntry;
+typedef struct CVMLocalVariableEntry CVMLocalVariableEntry;
+typedef struct CVMFieldBlock CVMFieldBlock;
+typedef struct CVMFieldRange CVMFieldRange;
+typedef struct CVMFieldArray CVMFieldArray;
+typedef struct CVMInnerClassInfo CVMInnerClassInfo;
+typedef struct CVMInnerClassesInfo CVMInnerClassesInfo;
+typedef union CVMConstantPool CVMConstantPool;
+typedef struct CVMTransitionConstantPool CVMTransitionConstantPool;
+typedef union CVMConstantPoolEntry CVMConstantPoolEntry;
+typedef struct CVMStackMapEntry CVMStackMapEntry;
+typedef struct CVMStackMaps CVMStackMaps;
+typedef CVMObjectICell CVMThreadICell;
+typedef CVMObjectICell CVMThrowableICell;
+typedef CVMObjectICell CVMStringICell;
+typedef CVMObjectICell CVMClassICell;
+typedef CVMObjectICell CVMClassLoaderICell;
+typedef CVMObject* CVMStringObject;
+typedef struct CVMExecEnv CVMExecEnv;
+typedef CVMBool CVMTryLockFunc (CVMExecEnv* ee,
+        CVMObject* obj);
+typedef CVMBool CVMLockFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMNotifyFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMNotifyAllFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMWaitFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj,
+        CVMJavaLong millis);
+typedef struct CVMReentrantMutex CVMReentrantMutex;
+typedef struct CVMSysMutex CVMSysMutex;
+typedef struct CVMSysMonitor CVMSysMonitor;
+typedef struct CVMProfiledMonitor CVMProfiledMonitor;
+typedef struct CVMNamedSysMonitor CVMNamedSysMonitor;
+typedef struct CVMObjMonitor CVMObjMonitor;
+typedef struct CVMOwnedMonitor CVMOwnedMonitor;
+typedef struct CVMCState CVMCState;
+typedef struct CVMTCState CVMTCState;
+typedef struct CVMLoaderCacheEntry CVMLoaderCacheEntry;
+typedef struct CVMLoaderConstraint CVMLoaderConstraint;
+typedef struct CVMSeenClass CVMSeenClass;
+typedef struct CVMClassPathEntry CVMClassPathEntry;
+typedef union CVMStackVal32 CVMStackVal32;
+typedef struct CVMStack CVMStack;
+typedef struct CVMStackChunk CVMStackChunk;
+typedef struct CVMFrame CVMFrame;
+typedef struct CVMFrameIterator CVMFrameIterator;
+typedef struct CVMLocalRootsFrame CVMLocalRootsFrame;
+typedef struct CVMFreelistFrame CVMFreelistFrame;
+typedef struct CVMInterpreterFrame CVMInterpreterFrame;
+typedef struct CVMJavaFrame CVMJavaFrame;
+typedef struct CVMTransitionFrame CVMTransitionFrame;
+typedef struct CVMStackWalkContext CVMStackWalkContext;
+typedef struct CVMGlobalState CVMGlobalState;
+typedef struct CVMGCGlobalState CVMGCGlobalState;
+typedef struct CVMOptions CVMOptions;
+typedef struct CVMGCOptions CVMGCOptions;
+typedef struct CVMJavaAssertionsOptionList CVMJavaAssertionsOptionList;
+typedef void (*CVMRefCallbackFunc)(CVMObject** refAddr, void* data);
+typedef CVMBool (*CVMRefLivenessQueryFunc)(CVMObject** refAddr, void* data);
+typedef CVMBool (*CVMObjectCallbackFunc)(CVMObject* obj, CVMClassBlock* cb,
+                                         CVMUint32 objSize, void* data);
+typedef void CVMFrameGCScannerFunc(CVMExecEnv* ee,
+       CVMFrame* thisFrame,
+       CVMStackChunk* thisChunk,
+       CVMRefCallbackFunc refCallback,
+       void* data,
+       CVMGCOptions* gcOpts);
+struct JNINativeInterface;
+typedef const struct JNINativeInterface *JNIEnv;
+typedef CVMUint32 CVMTypeID;
+typedef CVMUint16 CVMTypeIDPart;
+typedef CVMTypeID CVMMethodTypeID;
+typedef CVMTypeID CVMFieldTypeID;
+typedef CVMTypeID CVMClassTypeID;
+typedef CVMTypeIDPart CVMTypeIDNamePart;
+typedef CVMTypeIDPart CVMTypeIDTypePart;
+extern int CVMtypeidGetArrayDepthX( CVMClassTypeID );
+extern CVMClassTypeID CVMtypeidGetArrayBasetypeX( CVMClassTypeID );
+extern CVMBool
+CVMtypeidInit(CVMExecEnv *ee);
+extern void
+CVMtypeidRegisterPreloadedPackages();
+extern void
+CVMtypeidDestroy();
+extern CVMMethodTypeID
+CVMtypeidLookupMethodIDFromNameAndSig( CVMExecEnv *ee,
+      const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMMethodTypeID
+CVMtypeidNewMethodIDFromNameAndSig( CVMExecEnv *ee,
+      const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMMethodTypeID
+CVMtypeidCloneMethodID( CVMExecEnv *ee, CVMMethodTypeID cookie );
+extern void
+CVMtypeidDisposeMethodID( CVMExecEnv *ee, CVMMethodTypeID cookie );
+extern CVMFieldTypeID
+CVMtypeidLookupFieldIDFromNameAndSig( CVMExecEnv *ee,
+   const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMFieldTypeID
+CVMtypeidNewFieldIDFromNameAndSig( CVMExecEnv *ee,
+   const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMFieldTypeID
+CVMtypeidCloneFieldID( CVMExecEnv *ee, CVMFieldTypeID cookie );
+extern void
+CVMtypeidDisposeFieldID( CVMExecEnv *ee, CVMFieldTypeID cookie );
+extern CVMClassTypeID
+CVMtypeidLookupClassID( CVMExecEnv *ee, const char * name, int nameLength );
+extern CVMClassTypeID
+CVMtypeidNewClassID( CVMExecEnv *ee, const char * name, int nameLength );
+extern CVMClassTypeID
+CVMtypeidCloneClassID( CVMExecEnv *ee, CVMClassTypeID cookie );
+extern void
+CVMtypeidDisposeClassID( CVMExecEnv *ee, CVMClassTypeID cookie );
+extern CVMTypeID
+CVMtypeidLookupMembername( CVMExecEnv *ee, const char * name );
+extern CVMTypeID
+CVMtypeidNewMembername( CVMExecEnv *ee, const char * name );
+extern CVMTypeID
+CVMtypeidCloneMembername( CVMExecEnv *ee, CVMTypeID cookie );
+extern void
+CVMtypeidDisposeMembername( CVMExecEnv *ee, CVMTypeID cookie );
+extern char
+CVMtypeidGetReturnType(CVMMethodTypeID type);
+extern CVMUint16
+CVMtypeidGetArgsSize( CVMMethodTypeID methodTypeID );
+extern CVMBool
+CVMtypeidMethodIsRef(CVMMethodTypeID type);
+extern size_t
+CVMtypeidFieldTypeLength0(CVMFieldTypeID type, CVMBool isField);
+extern size_t
+CVMtypeidMethodTypeLength(CVMMethodTypeID type);
+extern size_t
+CVMtypeidMemberNameLength(CVMMethodTypeID type);
+extern size_t
+CVMtypeidClassNameLength(CVMClassTypeID type);
+extern CVMBool
+CVMtypeidMethodTypeToCString(CVMMethodTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidFieldTypeToCString(CVMFieldTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidMethodNameToCString(CVMMethodTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidFieldNameToCString(CVMFieldTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidClassNameToCString(CVMClassTypeID type, char* buf, int bufLength);
+extern char *
+CVMtypeidMethodTypeToAllocatedCString( CVMMethodTypeID type );
+extern char *
+CVMtypeidFieldTypeToAllocatedCString( CVMFieldTypeID type );
+extern char *
+CVMtypeidMethodNameToAllocatedCString( CVMMethodTypeID type );
+extern char *
+CVMtypeidFieldNameToAllocatedCString( CVMFieldTypeID type );
+extern char *
+CVMtypeidClassNameToAllocatedCString( CVMClassTypeID type );
+int CVMtypeidIncrementFieldRefcount( CVMFieldTypeID );
+int CVMtypeidDecrementFieldRefcount( CVMFieldTypeID );
+extern CVMClassTypeID
+CVMtypeidIncrementArrayDepth( CVMExecEnv *ee, CVMClassTypeID base,
+         int depthIncrement );
+extern CVMBool
+CVMtypeidIsSameClassPackage( CVMClassTypeID classname1,
+        CVMClassTypeID classname2 );
+typedef struct CVMterseSig {
+    CVMUint32 * datap;
+    int nParameters;
+} CVMterseSig;
+typedef struct CVMterseSigIterator {
+    CVMterseSig thisSig;
+    int word;
+    int syllableInWord;
+} CVMterseSigIterator;
+void
+CVMtypeidGetTerseSignature( CVMMethodTypeID tid, CVMterseSig* result );
+void
+CVMtypeidGetTerseSignatureIterator( CVMMethodTypeID tid, CVMterseSigIterator* result );
+typedef struct CVMSigIterator {
+    CVMterseSigIterator terseSig;
+    CVMTypeIDTypePart* parameterDetails;
+    CVMClassTypeID returnType;
+    CVMClassTypeID temp;
+} CVMSigIterator;
+void
+CVMtypeidGetSignatureIterator( CVMMethodTypeID tid, CVMSigIterator* result );
+extern void CVMtypeidPrintStats();
+extern void CVMtypeidPrintDiffs( CVMBool verbose );
+extern void CVMtypeidCheckTables();
+enum CVMBasicType {
+    CVM_T_ERR = 0,
+    CVM_T_CLASS = 2,
+    CVM_T_BOOLEAN = 4,
+    CVM_T_CHAR,
+    CVM_T_FLOAT,
+    CVM_T_DOUBLE,
+    CVM_T_BYTE,
+    CVM_T_SHORT,
+    CVM_T_INT,
+    CVM_T_LONG,
+    CVM_T_VOID = 17
+};
+typedef enum CVMBasicType CVMBasicType;
+extern const CVMUint32 CVMbasicTypeSizes[];
+extern const char CVMbasicTypeSignatures[];
+extern const CVMClassTypeID CVMbasicTypeID[];
+extern const CVMClassBlock* const CVMbasicTypeClassblocks[];
+extern const CVMClassBlock* const CVMbasicTypeArrayClassblocks[];
+extern const CVMClassBlock* const CVMterseTypeClassblocks[];
+extern const CVMBasicType CVMterseTypeBasicTypes[];
+extern const char CVMterseTypePrimitiveSignatures[];
+extern CVMBool CVMmicrolockInit (CVMMicroLock* m);
+extern void CVMmicrolockDestroy(CVMMicroLock* m);
+extern void CVMmicrolockLock (CVMMicroLock* m);
+extern void CVMmicrolockUnlock (CVMMicroLock* m);
+extern CVMBool CVMmutexInit (CVMMutex* m);
+extern void CVMmutexDestroy(CVMMutex* m);
+extern CVMBool CVMmutexTryLock(CVMMutex* m);
+extern void CVMmutexLock (CVMMutex* m);
+extern void CVMmutexUnlock (CVMMutex* m);
+extern void CVMmutexSetOwner(CVMThreadID *self, CVMMutex* m,
+    CVMThreadID *ti);
+extern CVMBool CVMcondvarInit (CVMCondVar *c, CVMMutex* m);
+extern void CVMcondvarDestroy(CVMCondVar *c);
+extern CVMBool CVMcondvarWait (CVMCondVar* c, CVMMutex* m,
+       CVMJavaLong millis);
+extern void CVMcondvarNotify (CVMCondVar* c);
+extern void CVMcondvarNotifyAll(CVMCondVar* c);
+typedef struct {
+    pthread_mutex_t m;
+} POSIXMutex;
+typedef struct {
+    pthread_cond_t c;
+} POSIXCondVar;
+extern CVMBool POSIXmutexInit(POSIXMutex * m);
+extern void POSIXmutexDestroy(POSIXMutex * m);
+extern CVMBool POSIXmutexTryLock(POSIXMutex * m);
+extern void POSIXmutexLock(POSIXMutex * m);
+extern void POSIXmutexUnlock(POSIXMutex * m);
+extern CVMBool POSIXcondvarInit(POSIXCondVar * c, POSIXMutex * m);
+extern void POSIXcondvarDestroy(POSIXCondVar * c);
+extern int POSIXcondvarWait(POSIXCondVar * c, POSIXMutex * m,
+ CVMJavaLong millis);
+extern void POSIXcondvarNotify(POSIXCondVar * c);
+extern void POSIXcondvarNotifyAll(POSIXCondVar * c);
+CVMBool linuxSyncInit(void);
+void linuxSyncInterruptWait(CVMThreadID *thread);
+void linuxSyncSuspend(CVMThreadID *thread);
+void linuxSyncResume(CVMThreadID *thread);
+struct CVMMutex {
+    POSIXMutex pmtx;
+};
+struct CVMCondVar {
+    POSIXCondVar pcv;
+    CVMThreadID *waiters;
+    CVMThreadID **last_p;
+};
+typedef enum {
+    CVM_CODE_MICROLOCK,
+    CVM_CONSTANTPOOL_MICROLOCK,
+    CVM_TOOLS_MICROLOCK,
+    CVM_GC_LOCKER_MICROLOCK,
+    CVM_METHOD_TRACE_MICROLOCK,
+    CVM_ACCESS_VOLATILE_MICROLOCK,
+    CVM_NUM_SYS_MICROLOCKS
+} CVMSysMicroLock;
+void
+CVMsysMicroLock(CVMExecEnv *ee, CVMSysMicroLock lock);
+void
+CVMsysMicroUnlock(CVMExecEnv *ee, CVMSysMicroLock lock);
+void
+CVMsysMicroLockAll(CVMExecEnv *ee);
+void
+CVMsysMicroUnlockAll(CVMExecEnv *ee);
+struct CVMReentrantMutex {
+    CVMExecEnv *owner;
+    CVMUint32 count;
+    CVMMutex mutex;
+};
+extern CVMBool CVMreentrantMutexInit (CVMReentrantMutex *rm,
+     CVMExecEnv *owner, CVMUint32 count);
+extern void CVMreentrantMutexDestroy(CVMReentrantMutex *rm);
+extern CVMBool CVMreentrantMutexTryLock(CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern void CVMreentrantMutexLock (CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern void CVMreentrantMutexUnlock (CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern CVMBool CVMreentrantMutexWait (CVMExecEnv *ee, CVMReentrantMutex *rm,
+     CVMCondVar *c, CVMInt64 millis);
+extern CVMBool CVMreentrantMutexIAmOwner(CVMExecEnv *ee, CVMReentrantMutex *rm);
+struct CVMSysMutex {
+    const char *name;
+    CVMUint8 rank;
+    CVMReentrantMutex rmutex;
+    CVMSysMutex *nextOwned;
+};
+extern CVMBool CVMsysMutexInit (CVMSysMutex* m,
+         const char *name,
+         CVMUint8 rank);
+extern void CVMsysMutexDestroy(CVMSysMutex* m);
+extern CVMBool CVMsysMutexTryLock(CVMExecEnv *ee, CVMSysMutex* m);
+extern void CVMsysMutexLock (CVMExecEnv *ee, CVMSysMutex* m);
+extern void CVMsysMutexUnlock (CVMExecEnv *ee, CVMSysMutex* m);
+extern CVMBool CVMsysMutexWait (CVMExecEnv *ee, CVMSysMutex* m,
+         CVMCondVar *c, CVMInt64 millis);
+typedef enum {
+    CVM_WAIT_OK,
+    CVM_WAIT_INTERRUPTED,
+    CVM_WAIT_NOT_OWNER
+} CVMWaitStatus;
+struct CVMSysMonitor {
+    CVMReentrantMutex rmutex;
+    CVMCondVar condvar;
+};
+extern CVMBool
+CVMsysMonitorInit(CVMSysMonitor* m, CVMExecEnv *owner, CVMUint32 count);
+extern void
+CVMsysMonitorDestroy(CVMSysMonitor* m);
+extern void
+CVMsysMonitorEnter(CVMExecEnv *ee, CVMSysMonitor* m);
+extern void
+CVMsysMonitorExit(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMBool
+CVMsysMonitorNotify(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMBool
+CVMsysMonitorNotifyAll(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMWaitStatus
+CVMsysMonitorWait(CVMExecEnv *ee, CVMSysMonitor* m, CVMInt64 millis);
+enum {
+    CVM_LOCKTYPE_UNKNOWN = 0,
+    CVM_LOCKTYPE_OBJ_MONITOR,
+    CVM_LOCKTYPE_NAMED_SYSMONITOR
+};
+struct CVMProfiledMonitor {
+    CVMSysMonitor _super;
+    CVMUint8 type;
+    CVMUint32 contentionCount;
+    CVMProfiledMonitor *next;
+    CVMProfiledMonitor **previousPtr;
+};
+extern CVMBool
+CVMprofiledMonitorInit(CVMProfiledMonitor *self, CVMExecEnv *owner,
+                       CVMUint32 count, CVMUint8 lockType);
+extern void
+CVMprofiledMonitorExit(CVMProfiledMonitor *self, CVMExecEnv *currentEE);
+extern CVMWaitStatus
+CVMprofiledMonitorWait(CVMProfiledMonitor *self, CVMExecEnv *currentEE,
+                       CVMInt64 millis);
+extern void
+CVMprofiledMonitorEnterUnsafe(CVMProfiledMonitor *self,
+         CVMExecEnv *currentEE, CVMBool doPost);
+extern void
+CVMprofiledMonitorEnterSafe(CVMProfiledMonitor *self, CVMExecEnv *currentEE, CVMBool doPost);
+extern void
+CVMdeleteUnreferencedMonitors(CVMExecEnv *ee,
+         CVMRefLivenessQueryFunc isLive,
+         void* isLiveData,
+         CVMRefCallbackFunc transitiveScanner,
+         void* transitiveScannerData);
+extern void
+CVMscanMonitors(CVMExecEnv *ee, CVMRefCallbackFunc refCallback, void* data);
+extern CVMBool
+CVMeeSyncInit(CVMExecEnv *ee);
+extern void
+CVMeeSyncDestroy(CVMExecEnv *ee);
+extern CVMBool
+CVMeeSyncInitGlobal(CVMExecEnv *ee, CVMGlobalState *gs);
+extern void
+CVMeeSyncDestroyGlobal(CVMExecEnv *ee, CVMGlobalState *gs);
+struct CVMObjectHeader {
+    volatile CVMClassBlock *clas;
+    volatile CVMAddr various32;
+};
+enum {
+    CVM_LOCKSTATE_LOCKED = 0,
+    CVM_LOCKSTATE_MONITOR = 1,
+    CVM_LOCKSTATE_UNLOCKED = 2
+};
+extern CVMInt32
+CVMobjectGetHashSafe(CVMExecEnv *ee, CVMObjectICell* indirectObj);
+extern CVMInt32
+CVMobjectGetHashNoSet(CVMExecEnv *ee, CVMObject* directObj);
+struct CVMjava_lang_ObjectICell { CVMjava_lang_Object * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMObjectICell { CVMObject * volatile ref_DONT_ACCESS_DIRECTLY; };
+enum {
+    CVM_OBJMON_OWNED_NEXT,
+    CVM_OBJMON_SCAN_NEXT,
+    CVM_OBJMON_NUM_LISTS
+};
+typedef enum {
+    CVM_OBJMON_FREE = 0,
+    CVM_OBJMON_BOUND = 1,
+    CVM_OBJMON_OWNED = 2,
+    CVM_OBJMON_BUSY = 0x4
+} CVMObjMonitorState;
+struct CVMObjMonitor {
+    CVMAddr bits;
+    CVMProfiledMonitor mon;
+    CVMUint32 magic;
+    CVMOwnedMonitor *owner;
+    CVMBool sticky;
+    CVMObject *obj;
+    CVMObjMonitorState state;
+    CVMObjMonitor *next;
+};
+extern CVMBool
+CVMobjMonitorInit(CVMExecEnv *ee, CVMObjMonitor *, CVMExecEnv *owner,
+    CVMUint32 count);
+extern void
+CVMobjMonitorDestroy(CVMObjMonitor *m);
+extern CVMObjMonitor *
+CVMobjectInflatePermanently(CVMExecEnv *ee, CVMObjectICell* indirectObj);
+typedef enum {
+    CVM_OWNEDMON_FAST = 0,
+    CVM_OWNEDMON_HEAVY = 1
+} CVMOwnedMonitorType;
+typedef enum {
+    CVM_OWNEDMON_FREE = 0,
+    CVM_OWNEDMON_OWNED = 1
+} CVMOwnedMonitorState;
+struct CVMOwnedMonitor {
+    CVMExecEnv *owner;
+    CVMOwnedMonitorType type;
+    CVMObject *object;
+    union {
+ struct {
+     CVMAddr bits;
+ } fast;
+ struct {
+     CVMObjMonitor *mon;
+ } heavy;
+    } u;
+    CVMOwnedMonitor *next;
+    CVMUint32 magic;
+    CVMOwnedMonitorState state;
+    volatile CVMAddr count;
+};
+void
+CVMsyncGCSafeAllMonitorScavenge(CVMExecEnv *ee);
+union CVMJavaVal32 {
+    CVMJavaInt i;
+    CVMJavaFloat f;
+    CVMObjectICell r;
+    CVMAddr raw;
+};
+union CVMJavaVal64 {
+    CVMJavaLong l;
+    CVMJavaDouble d;
+    CVMAddr v[2];
+};
+union CVMJavaVal16 {
+    CVMJavaShort s;
+    CVMJavaChar c;
+};
+union CVMJavaVal8 {
+    CVMJavaByte b;
+    CVMJavaBoolean z;
+};
+struct CVMjava_lang_Object {
+    volatile CVMObjectHeader hdr;
+    volatile CVMJavaVal32 fields[1];
+};
+struct CVMSyncVector {
+    CVMTryLockFunc *tryLock;
+    CVMLockFunc *lock;
+    CVMTryLockFunc *tryUnlock;
+    CVMLockFunc *unlock;
+    CVMWaitFunc *wait;
+    CVMNotifyFunc *notify;
+    CVMNotifyAllFunc *notifyAll;
+    void *dummyWord;
+};
+extern const CVMSyncVector CVMsyncKinds[];
+extern CVMTryLockFunc CVMfastTryLock, CVMfastTryUnlock;
+extern CVMBool CVMobjectLockedByCurrentThread(CVMExecEnv *ee,
+                                              CVMObjectICell *objICell);
+extern CVMBool CVMgcSafeObjectLock(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectUnlock(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectNotify(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectNotifyAll(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectWait(CVMExecEnv *ee, CVMObjectICell *o,
+       CVMInt64 millis);
+extern void CVMobjectMicroLock(CVMExecEnv *ee, CVMObject *obj);
+extern void CVMobjectMicroUnlock(CVMExecEnv *ee, CVMObject *obj);
+struct CVMArrayInfo {
+    CVMUint16 depth;
+    CVMBasicType baseType;
+    CVMClassBlock* baseCb;
+    CVMClassBlock* elementCb;
+};
+typedef CVMJavaVal32 CVMTwoJavaWords[2];
+struct CVMArrayOfByte { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaByte elems[1]; };
+struct CVMArrayOfShort { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaShort elems[1]; };
+struct CVMArrayOfChar { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaChar elems[1]; };
+struct CVMArrayOfBoolean { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaBoolean elems[1]; };
+struct CVMArrayOfInt { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaInt elems[1]; };
+struct CVMArrayOfRef { CVMObjectHeader hdr; CVMJavaInt length; CVMObjectICell elems[1]; };
+struct CVMArrayOfFloat { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaFloat elems[1]; };
+struct CVMArrayOfLong { CVMObjectHeader hdr; CVMJavaInt length; CVMTwoJavaWords elems[1]; };
+struct CVMArrayOfDouble { CVMObjectHeader hdr; CVMJavaInt length; CVMTwoJavaWords elems[1]; };
+struct CVMArrayOfAnyType { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaVal32 elems[1]; };
+struct CVMArrayOfByteICell { CVMArrayOfByte * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfShortICell { CVMArrayOfShort * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfCharICell { CVMArrayOfChar * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfBooleanICell { CVMArrayOfBoolean * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfIntICell { CVMArrayOfInt * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfRefICell { CVMArrayOfRef * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfFloatICell { CVMArrayOfFloat * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfLongICell { CVMArrayOfLong * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfDoubleICell { CVMArrayOfDouble * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfAnyTypeICell { CVMArrayOfAnyType * volatile ref_DONT_ACCESS_DIRECTLY; };
+typedef enum {
+    CVM_GC_SAFE,
+    CVM_NUM_CONSISTENT_STATES
+} CVMCStateID;
+struct CVMCState {
+    volatile CVMBool request;
+    CVMUint32 count;
+    volatile CVMBool reached;
+    CVMExecEnv *requester;
+    volatile CVMUint32 inconsistentThreadCount;
+    CVMSysMutex mutex;
+    CVMCondVar consistentCV;
+    CVMCondVar resumeCV;
+    const char *name;
+};
+struct CVMTCState {
+    volatile CVMBool isConsistent;
+    volatile CVMBool wasConsistent;
+};
+extern CVMBool CVMcsInit(CVMCState *,
+    const char *name,
+    CVMUint8 rank);
+extern void CVMcsDestroy(CVMCState *);
+extern void CVMtcsInit(CVMTCState *);
+extern void CVMtcsDestroy(CVMTCState *);
+extern void CVMcsReachConsistentState(CVMExecEnv *, CVMCStateID);
+extern void CVMcsResumeConsistentState(CVMExecEnv *, CVMCStateID);
+extern CVMBool CVMcsCheckRequest(CVMCState *);
+extern void CVMcsBecomeConsistent(CVMCState *, CVMTCState *);
+extern void CVMcsBecomeInconsistent(CVMCState *, CVMTCState *);
+extern void CVMcsRendezvous(CVMExecEnv *, CVMCState *, CVMTCState *,
+     CVMBool block);
+extern const char * const CVMcstateNames[CVM_NUM_CONSISTENT_STATES];
+typedef union {
+    CVMInt32 i;
+    CVMJavaFloat f;
+    CVMAddr v64[2];
+    void * o;
+} CVMJNIReturnValue;
+extern CVMInt32
+CVMjniInvokeNative(void * env, void * nativeCode, CVMAddr * args,
+     CVMUint32 * terseSig, CVMInt32 argsSize,
+     void * classObject,
+     CVMJNIReturnValue * returnValue);
+typedef enum {
+    CNI_VOID = 0,
+    CNI_SINGLE = 1,
+    CNI_DOUBLE = 2,
+    CNI_NEW_TRANSITION_FRAME = -1,
+    CNI_NEW_MB = -3,
+    CNI_EXCEPTION = -4
+} CNIResultCode;
+typedef CNIResultCode CNINativeMethod(CVMExecEnv* ee,
+          CVMStackVal32* arguments,
+          CVMMethodBlock** p_mb);
+typedef CVMJavaBoolean jboolean;
+typedef CVMJavaChar jchar;
+typedef CVMJavaShort jshort;
+typedef CVMJavaFloat jfloat;
+typedef CVMJavaDouble jdouble;
+typedef CVMJavaInt jint;
+typedef CVMJavaByte jbyte;
+typedef CVMJavaLong jlong;
+typedef jint jsize;
+typedef CVMObjectICell* jobject;
+typedef jobject jclass;
+typedef jobject jthrowable;
+typedef jobject jstring;
+typedef jobject jarray;
+typedef jarray jbooleanArray;
+typedef jarray jbyteArray;
+typedef jarray jcharArray;
+typedef jarray jshortArray;
+typedef jarray jintArray;
+typedef jarray jlongArray;
+typedef jarray jfloatArray;
+typedef jarray jdoubleArray;
+typedef jarray jobjectArray;
+typedef jobject jweak;
+typedef union jvalue {
+    jboolean z;
+    jbyte b;
+    jchar c;
+    jshort s;
+    jint i;
+    jlong j;
+    jfloat f;
+    jdouble d;
+    jobject l;
+} jvalue;
+typedef CVMMethodBlock* jmethodID;
+typedef CVMFieldBlock* jfieldID;
+typedef struct {
+    char *name;
+    char *signature;
+    void *fnPtr;
+} JNINativeMethod;
+struct JNIInvokeInterface;
+typedef const struct JNIInvokeInterface *JavaVM;
+struct JNINativeInterface {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    void *reserved3;
+    jint ( *GetVersion)(JNIEnv *env);
+    jclass ( *DefineClass)
+      (JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
+       jsize len);
+    jclass ( *FindClass)
+      (JNIEnv *env, const char *name);
+    jmethodID ( *FromReflectedMethod)
+      (JNIEnv *env, jobject method);
+    jfieldID ( *FromReflectedField)
+      (JNIEnv *env, jobject field);
+    jobject ( *ToReflectedMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);
+    jclass ( *GetSuperclass)
+      (JNIEnv *env, jclass sub);
+    jboolean ( *IsAssignableFrom)
+      (JNIEnv *env, jclass sub, jclass sup);
+    jobject ( *ToReflectedField)
+      (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);
+    jint ( *Throw)
+      (JNIEnv *env, jthrowable obj);
+    jint ( *ThrowNew)
+      (JNIEnv *env, jclass clazz, const char *msg);
+    jthrowable ( *ExceptionOccurred)
+      (JNIEnv *env);
+    void ( *ExceptionDescribe)
+      (JNIEnv *env);
+    void ( *ExceptionClear)
+      (JNIEnv *env);
+    void ( *FatalError)
+      (JNIEnv *env, const char *msg);
+    jint ( *PushLocalFrame)
+      (JNIEnv *env, jint capacity);
+    jobject ( *PopLocalFrame)
+      (JNIEnv *env, jobject result);
+    jobject ( *NewGlobalRef)
+      (JNIEnv *env, jobject lobj);
+    void ( *DeleteGlobalRef)
+      (JNIEnv *env, jobject gref);
+    void ( *DeleteLocalRef)
+      (JNIEnv *env, jobject obj);
+    jboolean ( *IsSameObject)
+      (JNIEnv *env, jobject obj1, jobject obj2);
+    jobject ( *NewLocalRef)
+      (JNIEnv *env, jobject ref);
+    jint ( *EnsureLocalCapacity)
+      (JNIEnv *env, jint capacity);
+    jobject ( *AllocObject)
+      (JNIEnv *env, jclass clazz);
+    jobject ( *NewObject)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject ( *NewObjectV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject ( *NewObjectA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jclass ( *GetObjectClass)
+      (JNIEnv *env, jobject obj);
+    jboolean ( *IsInstanceOf)
+      (JNIEnv *env, jobject obj, jclass clazz);
+    jmethodID ( *GetMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *CallObjectMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jobject ( *CallObjectMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jobject ( *CallObjectMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jboolean ( *CallBooleanMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jboolean ( *CallBooleanMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jboolean ( *CallBooleanMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jbyte ( *CallByteMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jbyte ( *CallByteMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jbyte ( *CallByteMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jchar ( *CallCharMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jchar ( *CallCharMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jchar ( *CallCharMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jshort ( *CallShortMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jshort ( *CallShortMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jshort ( *CallShortMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jint ( *CallIntMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jint ( *CallIntMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jint ( *CallIntMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jlong ( *CallLongMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jlong ( *CallLongMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jlong ( *CallLongMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jfloat ( *CallFloatMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jfloat ( *CallFloatMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jfloat ( *CallFloatMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jdouble ( *CallDoubleMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jdouble ( *CallDoubleMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jdouble ( *CallDoubleMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    void ( *CallVoidMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    void ( *CallVoidMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    void ( *CallVoidMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jobject ( *CallNonvirtualObjectMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jobject ( *CallNonvirtualObjectMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jobject ( *CallNonvirtualObjectMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jboolean ( *CallNonvirtualBooleanMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jboolean ( *CallNonvirtualBooleanMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jboolean ( *CallNonvirtualBooleanMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jbyte ( *CallNonvirtualByteMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jbyte ( *CallNonvirtualByteMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jbyte ( *CallNonvirtualByteMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jchar ( *CallNonvirtualCharMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jchar ( *CallNonvirtualCharMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jchar ( *CallNonvirtualCharMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jshort ( *CallNonvirtualShortMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jshort ( *CallNonvirtualShortMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jshort ( *CallNonvirtualShortMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jint ( *CallNonvirtualIntMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jint ( *CallNonvirtualIntMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jint ( *CallNonvirtualIntMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jlong ( *CallNonvirtualLongMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jlong ( *CallNonvirtualLongMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jlong ( *CallNonvirtualLongMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jfloat ( *CallNonvirtualFloatMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jfloat ( *CallNonvirtualFloatMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jfloat ( *CallNonvirtualFloatMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jdouble ( *CallNonvirtualDoubleMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jdouble ( *CallNonvirtualDoubleMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jdouble ( *CallNonvirtualDoubleMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    void ( *CallNonvirtualVoidMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    void ( *CallNonvirtualVoidMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    void ( *CallNonvirtualVoidMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jfieldID ( *GetFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *GetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jboolean ( *GetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jbyte ( *GetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jchar ( *GetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jshort ( *GetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jint ( *GetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jlong ( *GetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jfloat ( *GetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jdouble ( *GetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    void ( *SetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
+    void ( *SetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
+    void ( *SetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
+    void ( *SetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
+    void ( *SetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
+    void ( *SetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
+    void ( *SetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
+    void ( *SetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
+    void ( *SetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
+    jmethodID ( *GetStaticMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *CallStaticObjectMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject ( *CallStaticObjectMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject ( *CallStaticObjectMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jboolean ( *CallStaticBooleanMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jboolean ( *CallStaticBooleanMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jboolean ( *CallStaticBooleanMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jbyte ( *CallStaticByteMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jbyte ( *CallStaticByteMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jbyte ( *CallStaticByteMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jchar ( *CallStaticCharMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jchar ( *CallStaticCharMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jchar ( *CallStaticCharMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jshort ( *CallStaticShortMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jshort ( *CallStaticShortMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jshort ( *CallStaticShortMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jint ( *CallStaticIntMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jint ( *CallStaticIntMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jint ( *CallStaticIntMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jlong ( *CallStaticLongMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jlong ( *CallStaticLongMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jlong ( *CallStaticLongMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jfloat ( *CallStaticFloatMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jfloat ( *CallStaticFloatMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jfloat ( *CallStaticFloatMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jdouble ( *CallStaticDoubleMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jdouble ( *CallStaticDoubleMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jdouble ( *CallStaticDoubleMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    void ( *CallStaticVoidMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, ...);
+    void ( *CallStaticVoidMethodV)
+      (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
+    void ( *CallStaticVoidMethodA)
+      (JNIEnv *env, jclass cls, jmethodID methodID, const jvalue * args);
+    jfieldID ( *GetStaticFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *GetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jboolean ( *GetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jbyte ( *GetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jchar ( *GetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jshort ( *GetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jint ( *GetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jlong ( *GetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jfloat ( *GetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jdouble ( *GetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    void ( *SetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
+    void ( *SetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
+    void ( *SetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
+    void ( *SetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
+    void ( *SetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
+    void ( *SetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
+    void ( *SetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
+    void ( *SetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
+    void ( *SetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
+    jstring ( *NewString)
+      (JNIEnv *env, const jchar *unicode, jsize len);
+    jsize ( *GetStringLength)
+      (JNIEnv *env, jstring str);
+    const jchar *( *GetStringChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void ( *ReleaseStringChars)
+      (JNIEnv *env, jstring str, const jchar *chars);
+    jstring ( *NewStringUTF)
+      (JNIEnv *env, const char *utf);
+    jsize ( *GetStringUTFLength)
+      (JNIEnv *env, jstring str);
+    const char* ( *GetStringUTFChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void ( *ReleaseStringUTFChars)
+      (JNIEnv *env, jstring str, const char* chars);
+    jsize ( *GetArrayLength)
+      (JNIEnv *env, jarray array);
+    jobjectArray ( *NewObjectArray)
+      (JNIEnv *env, jsize len, jclass clazz, jobject init);
+    jobject ( *GetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index);
+    void ( *SetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index, jobject val);
+    jbooleanArray ( *NewBooleanArray)
+      (JNIEnv *env, jsize len);
+    jbyteArray ( *NewByteArray)
+      (JNIEnv *env, jsize len);
+    jcharArray ( *NewCharArray)
+      (JNIEnv *env, jsize len);
+    jshortArray ( *NewShortArray)
+      (JNIEnv *env, jsize len);
+    jintArray ( *NewIntArray)
+      (JNIEnv *env, jsize len);
+    jlongArray ( *NewLongArray)
+      (JNIEnv *env, jsize len);
+    jfloatArray ( *NewFloatArray)
+      (JNIEnv *env, jsize len);
+    jdoubleArray ( *NewDoubleArray)
+      (JNIEnv *env, jsize len);
+    jboolean * ( *GetBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
+    jbyte * ( *GetByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jboolean *isCopy);
+    jchar * ( *GetCharArrayElements)
+      (JNIEnv *env, jcharArray array, jboolean *isCopy);
+    jshort * ( *GetShortArrayElements)
+      (JNIEnv *env, jshortArray array, jboolean *isCopy);
+    jint * ( *GetIntArrayElements)
+      (JNIEnv *env, jintArray array, jboolean *isCopy);
+    jlong * ( *GetLongArrayElements)
+      (JNIEnv *env, jlongArray array, jboolean *isCopy);
+    jfloat * ( *GetFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jboolean *isCopy);
+    jdouble * ( *GetDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jboolean *isCopy);
+    void ( *ReleaseBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
+    void ( *ReleaseByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
+    void ( *ReleaseCharArrayElements)
+      (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
+    void ( *ReleaseShortArrayElements)
+      (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
+    void ( *ReleaseIntArrayElements)
+      (JNIEnv *env, jintArray array, jint *elems, jint mode);
+    void ( *ReleaseLongArrayElements)
+      (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
+    void ( *ReleaseFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
+    void ( *ReleaseDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
+    void ( *GetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void ( *GetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void ( *GetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void ( *GetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void ( *GetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void ( *GetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void ( *GetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void ( *GetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+    void ( *SetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l,
+       const jboolean *buf);
+    void ( *SetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte *buf);
+    void ( *SetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar *buf);
+    void ( *SetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len,
+       const jshort *buf);
+    void ( *SetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, const jint *buf);
+    void ( *SetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong *buf);
+    void ( *SetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len,
+       const jfloat *buf);
+    void ( *SetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len,
+       const jdouble *buf);
+    jint ( *RegisterNatives)
+      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods,
+       jint nMethods);
+    jint ( *UnregisterNatives)
+      (JNIEnv *env, jclass clazz);
+    jint ( *MonitorEnter)
+      (JNIEnv *env, jobject obj);
+    jint ( *MonitorExit)
+      (JNIEnv *env, jobject obj);
+    jint ( *GetJavaVM)
+      (JNIEnv *env, JavaVM **vm);
+    void ( *GetStringRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);
+    void ( *GetStringUTFRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);
+    void * ( *GetPrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, jboolean *isCopy);
+    void ( *ReleasePrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, void *carray, jint mode);
+    const jchar * ( *GetStringCritical)
+      (JNIEnv *env, jstring string, jboolean *isCopy);
+    void ( *ReleaseStringCritical)
+      (JNIEnv *env, jstring string, const jchar *cstring);
+    jweak ( *NewWeakGlobalRef)
+       (JNIEnv *env, jobject obj);
+    void ( *DeleteWeakGlobalRef)
+       (JNIEnv *env, jweak ref);
+    jboolean ( *ExceptionCheck)
+       (JNIEnv *env);
+    jobject ( *NewDirectByteBuffer)
+       (JNIEnv* env, void* address, jlong capacity);
+    void* ( *GetDirectBufferAddress)
+       (JNIEnv* env, jobject buf);
+    jlong ( *GetDirectBufferCapacity)
+       (JNIEnv* env, jobject buf);
+};
+typedef struct JavaVMOption {
+    char *optionString;
+    void *extraInfo;
+} JavaVMOption;
+typedef struct JavaVMInitArgs {
+    jint version;
+    jint nOptions;
+    JavaVMOption *options;
+    jboolean ignoreUnrecognized;
+} JavaVMInitArgs;
+typedef struct JavaVMAttachArgs {
+    jint version;
+    char *name;
+    jobject group;
+} JavaVMAttachArgs;
+struct JNIInvokeInterface {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    jint ( *DestroyJavaVM)(JavaVM *vm);
+    jint ( *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);
+    jint ( *DetachCurrentThread)(JavaVM *vm);
+    jint ( *GetEnv)(JavaVM *vm, void **penv, jint version);
+    jint ( *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
+};
+extern jint
+JNI_GetDefaultJavaVMInitArgs(void *args);
+extern jint
+JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);
+extern jint
+JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
+extern jint
+JNI_OnLoad(JavaVM *vm, void *reserved);
+extern void
+JNI_OnUnload(JavaVM *vm, void *reserved);
+union CVMConstantPoolEntry {
+    union {
+ struct {
+     CVMUint16 nameUtf8Idx;
+     CVMUint16 typeUtf8Idx;
+ } nameAndType;
+ struct {
+     CVMUint16 utf8Idx;
+ } clazz;
+ struct {
+     CVMUint16 utf8Idx;
+ } string;
+ CVMUtf8* utf8;
+    } intermediate;
+    union {
+ struct {
+     CVMUint16 classIdx;
+     CVMUint16 typeIDIdx;
+ } memberRef;
+ CVMMethodTypeID methodTypeID;
+ CVMFieldTypeID fieldTypeID;
+ CVMClassTypeID classTypeID;
+    } unresolved;
+    union {
+ CVMJavaVal32 val32;
+ CVMClassBlock* cb;
+ CVMFieldBlock* fb;
+ CVMMethodBlock* mb;
+ CVMStringObject* strObj;
+ CVMStringICell* strICell;
+    } resolved;
+};
+typedef CVMUint8 CVMConstantPoolEntryType;
+union CVMConstantPool {
+    CVMConstantPoolEntryType* cpTypesX;
+    CVMConstantPoolEntry entriesX[1];
+};
+struct CVMTransitionConstantPool {
+    CVMConstantPool cp;
+    CVMConstantPoolEntry entry1X;
+};
+enum CVMConstantPoolEntryTypeEnum {
+    CVM_CONSTANT_Utf8 = 1,
+    CVM_CONSTANT_Unicode = 2,
+    CVM_CONSTANT_Integer = 3,
+    CVM_CONSTANT_Float = 4,
+    CVM_CONSTANT_Long = 5,
+    CVM_CONSTANT_Double = 6,
+    CVM_CONSTANT_Class = 7,
+    CVM_CONSTANT_String = 8,
+    CVM_CONSTANT_Fieldref = 9,
+    CVM_CONSTANT_Methodref = 10,
+    CVM_CONSTANT_InterfaceMethodref = 11,
+    CVM_CONSTANT_NameAndType = 12,
+    CVM_CONSTANT_ClassTypeID = 13,
+    CVM_CONSTANT_MethodTypeID = 14,
+    CVM_CONSTANT_FieldTypeID = 15,
+    CVM_CONSTANT_ClassBlock = 19,
+    CVM_CONSTANT_FieldBlock = 20,
+    CVM_CONSTANT_MethodBlock = 21,
+    CVM_CONSTANT_StringObj = 22,
+    CVM_CONSTANT_StringICell = 23,
+    CVM_CONSTANT_Invalid = 24
+};
+typedef enum CVMConstantPoolEntryTypeEnum CVMConstantPoolEntryTypeEnum;
+extern CVMBool
+CVMprivate_cpExtractTypeIDFromUnresolvedEntry(CVMExecEnv* ee,
+           CVMClassBlock* currentCb,
+           CVMConstantPool* cp,
+           CVMUint16 cpIndex,
+           CVMTypeID* p_typeid);
+extern void
+CVMcpResolveCbEntriesWithoutClassLoading(CVMExecEnv* ee,
+                                         CVMClassBlock* cb);
+CVMBool
+CVMprivate_cpResolveEntryFromClass(CVMExecEnv* ee,
+       CVMClassBlock* currentCb,
+       CVMConstantPool* cp,
+       CVMUint16 cpIndex);
+CVMBool
+CVMprivate_cpResolveEntryWithoutClassLoading(CVMExecEnv* ee,
+          CVMClassBlock* currentCb,
+          CVMConstantPool* cp,
+          CVMUint16 cpIndex,
+          CVMTypeID* p_typeid);
+union CVMGCBitMap {
+    CVMAddr map;
+    CVMBigGCBitMap* bigmap;
+};
+struct CVMBigGCBitMap {
+    CVMUint16 maplen;
+    CVMAddr map[1];
+};
+struct CVMClassBlock {
+    CVMGCBitMap gcMapX;
+    CVMClassTypeID classNameX;
+    union {
+ CVMClassBlock* superclassCb;
+ CVMClassTypeID superclassTypeID;
+ CVMUint16 mirandaMethodCountX;
+    } superclassX;
+    union {
+ CVMConstantPool* constantpoolX;
+ CVMArrayInfo* arrayInfoX;
+    } cpX;
+    CVMInterfaces* interfacesX;
+    CVMMethodArray* methodsX;
+    CVMFieldArray* fieldsX;
+    union {
+ CVMJavaVal32* statics;
+ CVMClassBlock* freeClassLink;
+    } staticsX;
+    CVMUint16 constantpoolCountX;
+    CVMUint16 methodCountX;
+    CVMUint16 fieldCountX;
+    CVMUint16 methodTableCountX;
+    CVMUint16 accessFlagsX;
+    volatile CVMUint8 runtimeFlagsX;
+    CVMUint16 instanceSizeX;
+    CVMUint16 numStaticRefsX;
+    CVMClassICell* javaInstanceX;
+    char* theNameX;
+    CVMClassLoaderICell* classLoaderX;
+    CVMObjectICell* protectionDomainX;
+    union {
+ CVMExecEnv** eePtr;
+ CVMExecEnv* ee;
+ CVMClassBlock** classTableSlotPtr;
+    } clinitEEX;
+    CVMUint16* checkedExceptionsX;
+    char* sourceFileNameX;
+    CVMMethodBlock** methodTablePtrX;
+    CVMInnerClassesInfo* innerClassesInfoX;
+    CVMUint16 major_version;
+    CVMUint16 minor_version;
+};
+struct CVMInterfaceTable {
+    CVMClassBlock* interfaceCb;
+    union {
+ CVMUint16* methodTableIndicesX;
+ CVMClassTypeID interfaceTypeIDX;
+    } intfInfoX;
+};
+struct CVMInterfaces {
+    CVMUint16 interfaceCountX;
+    CVMUint16 implementsCountX;
+    CVMInterfaceTable itable[1];
+};
+struct CVMMethodBlockImmutable {
+    CVMMethodTypeID nameAndTypeIDX;
+    CVMUint16 methodTableIndexX;
+    CVMUint8 argsSizeX;
+    CVMUint8 methodIndexX;
+    CVMUint16 invokerAndAccessFlagsX;
+    CVMUint16 checkedExceptionsOffsetX;
+    union {
+ CVMJavaMethodDescriptor* jmd;
+ CVMUint8* nativeCode;
+ CVMAddr methodSlotIndex;
+ CVMMethodBlock* interfaceMb;
+    } codeX;
+};
+struct CVMMethodBlock {
+    CVMMethodBlockImmutable immutX;
+};
+struct CVMMethodRange {
+    CVMClassBlock* cb;
+    CVMMethodBlock mb[256];
+};
+struct CVMMethodArray {
+    CVMMethodRange ranges[1];
+};
+typedef CVMUint16 CVMCheckedException;
+struct CVMCheckedExceptions {
+    CVMUint16 numExceptions;
+    CVMCheckedException exceptions[1];
+};
+struct CVMJavaMethodDescriptor {
+    CVMUint16 maxLocalsX;
+    CVMUint16 flagsX;
+    CVMUint32 capacityX;
+    CVMUint16 exceptionTableLengthX;
+    CVMUint16 codeLengthX;
+    CVMUint16 lineNumberTableLengthX;
+    CVMUint16 localVariableTableLengthX;
+};
+struct CVMStackMapEntry {
+    CVMUint16 pc;
+    CVMUint16 state[1];
+};
+struct CVMStackMaps {
+    CVMStackMaps * next;
+    CVMStackMaps * prev;
+    CVMUint32 size;
+    CVMMethodBlock * mb;
+    CVMUint32 noGcPoints;
+    CVMStackMapEntry smEntries[1];
+};
+typedef struct CVMJavaMethodExtension {
+    CVMJavaMethodDescriptor* originalJmd;
+} CVMJavaMethodExtension;
+struct CVMExceptionHandler {
+    CVMUint16 startpc;
+    CVMUint16 endpc;
+    CVMUint16 handlerpc;
+    CVMUint16 catchtype;
+};
+struct CVMLineNumberEntry {
+    CVMUint16 startpc;
+    CVMUint16 lineNumber;
+};
+struct CVMLocalVariableEntry {
+    CVMUint16 startpc;
+    CVMUint16 length;
+    CVMUint16 index;
+    CVMTypeIDNamePart nameID;
+    CVMTypeIDTypePart typeID;
+};
+struct CVMFieldBlock {
+    CVMFieldTypeID nameAndTypeIDX;
+    CVMUint8 accessFlagsX;
+    CVMUint8 fbIndexX;
+    CVMUint16 offsetX;
+};
+struct CVMFieldRange {
+    CVMClassBlock* cb;
+    CVMFieldBlock fb[256];
+};
+struct CVMFieldArray {
+    CVMFieldRange ranges[1];
+};
+struct CVMInnerClassInfo {
+    CVMUint16 innerClassIndex;
+    CVMUint16 outerClassIndex;
+    CVMUint16 unused;
+    CVMUint16 innerClassAccessFlags;
+};
+struct CVMInnerClassesInfo {
+    CVMUint32 count;
+    CVMInnerClassInfo info[1];
+};
+enum {
+    CVM_INVOKE_JAVA_METHOD,
+    CVM_INVOKE_JAVA_SYNC_METHOD,
+    CVM_INVOKE_CNI_METHOD,
+    CVM_INVOKE_JNI_METHOD,
+    CVM_INVOKE_JNI_SYNC_METHOD,
+    CVM_INVOKE_ABSTRACT_METHOD,
+    CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD,
+    CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD,
+    CVM_INVOKE_LAZY_JNI_METHOD,
+    CVM_NUM_INVOKER_TYPES
+};
+CVMClassBlock*
+CVMclassLookupClassWithoutLoading(CVMExecEnv* ee, CVMClassTypeID typeID,
+      CVMClassLoaderICell* loader);
+extern CVMClassBlock*
+CVMclassLookupByNameFromClass(CVMExecEnv* ee, const char* name,
+         CVMBool init, CVMClassBlock* fromClass);
+extern CVMClassBlock*
+CVMclassLookupByTypeFromClass(CVMExecEnv* ee, CVMClassTypeID typeID,
+         CVMBool init, CVMClassBlock* fromClass);
+extern CVMClassBlock*
+CVMclassLookupByNameFromClassLoader(CVMExecEnv* ee, const char* name,
+        CVMBool init,
+        CVMClassLoaderICell* loader,
+        CVMObjectICell* pd,
+        CVMBool throwError);
+extern CVMClassBlock*
+CVMclassLookupByTypeFromClassLoader(CVMExecEnv* ee, CVMClassTypeID typeID,
+        CVMBool init,
+        CVMClassLoaderICell* loader,
+        CVMObjectICell* pd,
+        CVMBool throwError);
+CVMClassBlock*
+CVMclassGetArrayOfWithNoClassCreation(CVMExecEnv* ee, CVMClassBlock* elemCb);
+extern CVMClassBlock*
+CVMclassGetArrayOf(CVMExecEnv* ee, CVMClassBlock* elemCb);
+extern CVMMethodBlock*
+CVMclassGetMethodBlock(const CVMClassBlock* cb, const CVMMethodTypeID tid,
+         CVMBool isStatic);
+CVMMethodBlock*
+CVMclassGetDeclaredMethodBlockFromTID(const CVMClassBlock* cb,
+          CVMMethodTypeID tid);
+extern CVMMethodBlock*
+CVMclassGetDeclaredMethodBlock(CVMExecEnv *ee,
+          const CVMClassBlock* cb,
+          const char *name,
+          const char *sig);
+extern CVMFieldBlock*
+CVMclassGetFieldBlock(const CVMClassBlock* cb, const CVMFieldTypeID tid,
+        CVMBool isStatic);
+extern CVMBool
+CVMclassLinkSuperClasses(CVMExecEnv* ee, CVMClassBlock* cb);
+extern CVMClassBlock*
+CVMclassLoadClass(CVMExecEnv* ee, CVMClassLoaderICell* loader,
+    const char* classname, CVMClassTypeID classTypeID);
+CVMClassICell*
+CVMclassLoadBootClass(CVMExecEnv* ee, const char* classname);
+extern CVMClassICell*
+CVMclassCreateInternalClass(CVMExecEnv* ee,
+       const CVMUint8* externalClass,
+       CVMUint32 classSize,
+       CVMClassLoaderICell* loader,
+       const char* classname,
+       const char* dirNameOrZipFileName,
+       CVMBool isRedefine);
+extern void
+CVMclassFree(CVMExecEnv* ee, CVMClassBlock* cb);
+extern void
+CVMclassFreeJavaMethods(CVMExecEnv* ee, CVMClassBlock* cb,
+   CVMBool isPreloaded);
+extern void
+CVMclassFreeLocalVariableTableFieldIDs(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern void
+CVMclassDoClassUnloadingPass1(CVMExecEnv* ee,
+         CVMRefLivenessQueryFunc isLive,
+         void* isLiveData,
+         CVMRefCallbackFunc transitiveScanner,
+         void* transitiveScannerData,
+         CVMGCOptions* gcOpts);
+extern void
+CVMclassDoClassUnloadingPass2(CVMExecEnv* ee);
+extern CVMBool
+CVMclassVerify(CVMExecEnv* ee, CVMClassBlock* cb);
+enum { CVM_VERIFY_NONE = 0, CVM_VERIFY_REMOTE, CVM_VERIFY_ALL, CVM_VERIFY_UNRECOGNIZED };
+extern CVMInt32
+CVMclassVerificationSpecToEncoding(char* verifySpec);
+extern CVMBool
+CVMclassLink(CVMExecEnv* ee, CVMClassBlock* cb, CVMBool isRedefine);
+extern CVMBool
+CVMclassInit(CVMExecEnv* ee, CVMClassBlock* cb);
+extern int
+CVMclassInitNoCRecursion(CVMExecEnv* ee, CVMClassBlock* cb,
+    CVMMethodBlock **p_mb);
+extern CVMClassICell*
+CVMdefineClass(CVMExecEnv* ee, const char *name, CVMClassLoaderICell* loader,
+        const CVMUint8* buf, CVMUint32 bufLen, CVMObjectICell* pd,
+        CVMBool isRedefine);
+extern CVMClassBlock*
+CVMclassCreateMultiArrayClass(CVMExecEnv* ee, CVMClassTypeID arrayTypeId,
+         CVMClassLoaderICell* loader, CVMObjectICell* pd);
+typedef void (*CVMClassCallbackFunc)(CVMExecEnv* ee,
+         CVMClassBlock* cb,
+         void* data);
+typedef void (*CVMStackCallbackFunc)( CVMObject**, void*);
+extern void
+CVMclassIterateAllClasses(CVMExecEnv* ee,
+     CVMClassCallbackFunc callback,
+     void* data);
+extern void
+CVMclassIterateDynamicallyLoadedClasses(CVMExecEnv* ee,
+     CVMClassCallbackFunc callback,
+     void* data);
+extern void
+CVMclassTableFreeAllClasses(CVMExecEnv* ee);
+extern CVMClassBlock**
+CVMclassTableAllocateSlot(CVMExecEnv* ee);
+void
+CVMclassTableFreeSlot(CVMExecEnv* ee, CVMClassBlock** cbPtr);
+extern void
+CVMclassTableMarkUnscannedClasses(CVMExecEnv* ee,
+      CVMRefLivenessQueryFunc isLive,
+      void* isLiveData);
+extern void
+CVMclassTableIterate(CVMExecEnv* ee,
+       CVMClassCallbackFunc callback,
+       void* data);
+extern void
+CVMclassTableDump(CVMExecEnv* ee);
+extern CVMClassLoaderICell*
+CVMloaderCacheGetGlobalRootFromLoader(CVMExecEnv* ee,
+          CVMClassLoaderICell* loader);
+extern CVMBool
+CVMloaderCacheCheckPackageAccess(CVMExecEnv *ee, CVMClassLoaderICell* loader,
+     CVMClassBlock* cb, CVMObjectICell* pd);
+extern CVMClassBlock*
+CVMloaderCacheLookupWithProtectionDomain(CVMExecEnv* ee,
+      CVMClassTypeID classID,
+      CVMClassLoaderICell* loader,
+      CVMObjectICell* pd);
+extern CVMBool
+CVMloaderCacheAdd(CVMExecEnv* ee, CVMClassBlock* cb,
+    CVMClassLoaderICell* loader);
+extern void
+CVMloaderCacheMarkUnscannedClassesAndLoaders(CVMExecEnv* ee,
+           CVMRefLivenessQueryFunc isLive,
+           void* isLiveData);
+extern void
+CVMloaderCachePurgeUnscannedClassesAndLoaders(CVMExecEnv* ee);
+extern CVMBool
+CVMloaderCacheInit();
+extern void
+CVMloaderCacheDestroy(CVMExecEnv* ee);
+extern void
+CVMloaderCacheDump(CVMExecEnv* ee);
+typedef struct {
+    int index;
+    void *entry;
+} CVMLoaderCacheIterator;
+void
+CVMloaderCacheIterate(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMBool
+CVMloaderCacheIterateNext(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMObjectICell *
+CVMloaderCacheIterateGetLoader(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMClassBlock *
+CVMloaderCacheIterateGetCB(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMBool
+CVMloaderConstraintsCheckMethodSignatureLoaders(CVMExecEnv* ee,
+      CVMMethodTypeID methodID,
+      CVMClassLoaderICell* loader1,
+      CVMClassLoaderICell* loader2);
+CVMBool
+CVMloaderConstraintsCheckFieldSignatureLoaders(CVMExecEnv* ee,
+            CVMFieldTypeID fieldID,
+            CVMClassLoaderICell* loader1,
+            CVMClassLoaderICell* loader2);
+extern void
+CVMloaderConstraintsMarkUnscannedClassesAndLoaders(
+    CVMExecEnv* ee,
+    CVMRefLivenessQueryFunc isLive,
+    void* isLiveData);
+extern void
+CVMloaderConstraintsPurgeUnscannedClassesAndLoaders(CVMExecEnv* ee);
+extern void
+CVMloaderConstraintsDump(CVMExecEnv* ee);
+extern void
+CVMclassScan(CVMExecEnv* ee, CVMClassBlock* cb,
+      CVMRefCallbackFunc callback, void* data);
+extern CVMBool
+CVMclassModuleInit(CVMExecEnv* ee);
+extern void
+CVMclassModuleDestroy(CVMExecEnv* ee);
+extern CVMBool
+CVMclassBootClassPathInit(JNIEnv *env);
+extern CVMBool
+CVMclassClassPathInit(JNIEnv *env);
+extern void
+CVMclassBootClassPathDestroy(CVMExecEnv* ee);
+extern void
+CVMclassClassPathDestroy(CVMExecEnv* ee);
+extern jobject
+CVMclassFindContainer(JNIEnv *env, jobject tthis, jstring name);
+typedef struct {
+    CVMClassPathEntry* entries;
+    CVMUint16 numEntries;
+    char* pathString;
+    CVMBool initialized;
+} CVMClassPath;
+extern CVMBool
+CVMclassPathInit(JNIEnv* env, CVMClassPath* path, char* additionalPathString,
+       CVMBool doNotFailWhenPathNotFound, CVMBool initJavaSide);
+CVMClassLoaderICell*
+CVMclassGetSystemClassLoader(CVMExecEnv* ee);
+void
+CVMclassSetSystemClassLoader(CVMExecEnv* ee, jobject loader);
+CVMBool CVMclassIsValidClassBlock(CVMExecEnv *ee, CVMClassBlock *cb);
+typedef struct CVMGenSpace {
+    CVMUint32* allocPtr;
+    CVMUint32* allocBase;
+    CVMUint32* allocTop;
+} CVMGenSpace;
+typedef struct CVMGeneration {
+    CVMUint32* heapBase;
+    CVMUint32* heapTop;
+    CVMUint32* allocPtr;
+    CVMUint32* allocBase;
+    CVMUint32* allocTop;
+    CVMUint32* allocMark;
+    CVMUint32 generationNo;
+    struct CVMGeneration* nextGen;
+    struct CVMGeneration* prevGen;
+    CVMBool (*collect)(struct CVMGeneration* gen,
+     CVMExecEnv* ee,
+     CVMUint32 numBytes,
+     CVMGCOptions* gcOpts);
+    void (*scanOlderToYoungerPointers)(struct CVMGeneration* gen,
+          CVMExecEnv* ee,
+          CVMGCOptions* gcOpts,
+          CVMRefCallbackFunc callback,
+          void* callbackData);
+    CVMObject* (*promoteInto)(struct CVMGeneration* gen,
+         CVMObject* objectToPromote,
+         CVMUint32 objectSize);
+    void (*scanPromotedPointers)(struct CVMGeneration* gen,
+           CVMExecEnv* ee,
+           CVMGCOptions* gcOpts,
+           CVMRefCallbackFunc callback,
+           void* callbackData);
+    CVMGenSpace* (*getExtraSpace)(struct CVMGeneration* gen);
+    CVMUint32 (*totalMemory)(struct CVMGeneration* gen, CVMExecEnv* ee);
+    CVMUint32 (*freeMemory)(struct CVMGeneration* gen, CVMExecEnv* ee);
+} CVMGeneration;
+CVMBool
+CVMgenInGeneration(CVMGeneration *thisGen, CVMObject *ref);
+void
+CVMgenScanAllRoots(CVMGeneration* thisGen,
+     CVMExecEnv *ee, CVMGCOptions* gcOpts,
+     CVMRefCallbackFunc callback, void* data);
+void
+CVMgenBarrierObjectHeadersUpdate(CVMGeneration* gen, CVMExecEnv* ee,
+     CVMGCOptions* gcOpts,
+     CVMUint32* startRange,
+     CVMUint32* endRange);
+typedef union CVMGenSummaryTableEntry {
+    CVMUint8 offsets[4];
+    CVMUint32 intVersion;
+} CVMGenSummaryTableEntry;
+extern void
+CVMgenClearBarrierTable();
+extern void
+CVMgenBarrierPointersTraverse(CVMGeneration* gen, CVMExecEnv* ee,
+         CVMGCOptions* gcOpts,
+         CVMRefCallbackFunc callback,
+         void* callbackData);
+extern void CVMgenDumpSysInfo(CVMGCGlobalState* gc);
+struct CVMGCGlobalState {
+    CVMUint32 heapSize;
+    CVMGeneration* CVMgenGenerations[2];
+    CVMInt64 lastMajorGCTime;
+    CVMUint8* cardTable;
+    CVMUint8 volatile* cardTableVirtualBase;
+    CVMUint32 cardTableSize;
+    CVMUint8* cardTableEnd;
+    struct {
+ CVMUint32 youngGenSize;
+    } genGCAttributes;
+    CVMInt8* objectHeaderTable;
+    CVMGenSummaryTableEntry* summaryTable;
+    CVMUint32* heapBase;
+    CVMUint32* heapBaseMemoryArea;
+    CVMUint32 mappedTotalSize;
+    CVMUint32 memoryReserve;
+    CVMUint32 oldGenGrowThreshold;
+    CVMUint32 oldGenShrinkThreshold;
+    CVMUint32 oldGenLowWatermark;
+    CVMUint32 oldGenHighWatermark;
+    CVMUint32 heapMinSize;
+    CVMUint32 heapStartSize;
+    CVMUint32 heapMaxSize;
+    CVMUint32 heapCurrentSize;
+    CVMUint32 youngGenMinSize;
+    CVMUint32 youngGenStartSize;
+    CVMUint32 youngGenMaxSize;
+    CVMUint32 youngGenCurrentSize;
+    CVMUint32 oldGenMinSize;
+    CVMUint32 oldGenStartSize;
+    CVMUint32 oldGenMaxSize;
+    CVMUint32 oldGenCurrentSize;
+    CVMUint32 cardTableCurrentSize;
+    CVMUint32 objectHeaderTableCurrentSize;
+    CVMUint32 summaryTableCurrentSize;
+    CVMUint32* youngGenStart;
+    CVMUint32* oldGenStart;
+    CVMBool hasYoungGenInternedStrings;
+    CVMBool needToScanInternedStrings;
+    CVMBool hasYoungGenClassesOrLoaders;
+};
+extern void *memcpy (void *__restrict __dest,
+       __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+        int __c, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memchr (__const void *__s, int __c, size_t __n)
+      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern void *rawmemchr (__const void *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern void *memrchr (__const void *__s, int __c, size_t __n)
+      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcoll (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strxfrm (char *__restrict __dest,
+         __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
+    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
+extern char *strdup (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+extern char *strndup (__const char *__string, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+extern char *strchr (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strrchr (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strchrnul (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strspn (__const char *__s, __const char *__accept)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strpbrk (__const char *__s, __const char *__accept)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strstr (__const char *__haystack, __const char *__needle)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *__strtok_r (char *__restrict __s,
+    __const char *__restrict __delim,
+    char **__restrict __save_ptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+         char **__restrict __save_ptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern char *strcasestr (__const char *__haystack, __const char *__needle)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+       __const void *__needle, size_t __needlelen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));
+extern void *__mempcpy (void *__restrict __dest,
+   __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *mempcpy (void *__restrict __dest,
+        __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strlen (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strerror (int __errnum) __attribute__ ((__nothrow__));
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__));
+extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void bcopy (__const void *__src, void *__dest, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *index (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *rindex (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+__extension__ extern int ffsll (long long int __ll)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcasecmp_l (__const char *__s1, __const char *__s2,
+    __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int strncasecmp_l (__const char *__s1, __const char *__s2,
+     size_t __n, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
+extern char *strsep (char **__restrict __stringp,
+       __const char *__restrict __delim)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strsignal (int __sig) __attribute__ ((__nothrow__));
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *__stpncpy (char *__restrict __dest,
+   __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+typedef struct { unsigned char __arr[2]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR2;
+typedef struct { unsigned char __arr[3]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR3;
+typedef struct { unsigned char __arr[4]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR4;
+typedef struct { unsigned char __arr[5]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR5;
+typedef struct { unsigned char __arr[6]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR6;
+typedef struct { unsigned char __arr[7]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR7;
+typedef struct { unsigned char __arr[8]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR8;
+extern void *__rawmemchr (const void *__s, int __c);
+extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
+extern __inline size_t
+__strcspn_c1 (__const char *__s, int __reject)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
+         int __reject2);
+extern __inline size_t
+__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+  && __s[__result] != __reject2)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
+         int __reject2, int __reject3);
+extern __inline size_t
+__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
+       int __reject3)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+  && __s[__result] != __reject2 && __s[__result] != __reject3)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
+extern __inline size_t
+__strspn_c1 (__const char *__s, int __accept)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
+        int __accept2);
+extern __inline size_t
+__strspn_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept1 || __s[__result] == __accept2)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
+        int __accept2, int __accept3);
+extern __inline size_t
+__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept1 || __s[__result] == __accept2
+  || __s[__result] == __accept3)
+    ++__result;
+  return __result;
+}
+extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
+         int __accept2);
+extern __inline char *
+__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
+    ++__s;
+  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
+}
+extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
+         int __accept2, int __accept3);
+extern __inline char *
+__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
+       int __accept3)
+{
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
+  && *__s != __accept3)
+    ++__s;
+  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
+}
+extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
+extern __inline char *
+__strtok_r_1c (char *__s, char __sep, char **__nextp)
+{
+  char *__result;
+  if (__s == ((void *)0))
+    __s = *__nextp;
+  while (*__s == __sep)
+    ++__s;
+  __result = ((void *)0);
+  if (*__s != '\0')
+    {
+      __result = __s++;
+      while (*__s != '\0')
+ if (*__s++ == __sep)
+   {
+     __s[-1] = '\0';
+     break;
+   }
+    }
+  *__nextp = __s;
+  return __result;
+}
+extern char *__strsep_g (char **__stringp, __const char *__delim);
+extern __inline char *__strsep_1c (char **__s, char __reject);
+extern __inline char *
+__strsep_1c (char **__s, char __reject)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
+    *(*__s)++ = '\0';
+  return __retval;
+}
+extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
+extern __inline char *
+__strsep_2c (char **__s, char __reject1, char __reject2)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0))
+    {
+      register char *__cp = __retval;
+      while (1)
+ {
+   if (*__cp == '\0')
+     {
+       __cp = ((void *)0);
+   break;
+     }
+   if (*__cp == __reject1 || *__cp == __reject2)
+     {
+       *__cp++ = '\0';
+       break;
+     }
+   ++__cp;
+ }
+      *__s = __cp;
+    }
+  return __retval;
+}
+extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
+       char __reject3);
+extern __inline char *
+__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0))
+    {
+      register char *__cp = __retval;
+      while (1)
+ {
+   if (*__cp == '\0')
+     {
+       __cp = ((void *)0);
+   break;
+     }
+   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
+     {
+       *__cp++ = '\0';
+       break;
+     }
+   ++__cp;
+ }
+      *__s = __cp;
+    }
+  return __retval;
+}
+extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *calloc (size_t __nmemb, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern char *__strdup (__const char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
+extern char *__strndup (__const char *__string, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
+extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("memset used with constant zero length parameter; this could be due to transposed parameters")))
+                                                                                                   ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memmove (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) mempcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memset (void *__dest, int __ch, size_t __len)
+{
+  if (__builtin_constant_p (__len) && __len == 0)
+    {
+      __warn_memset_zero_len ();
+      return __dest;
+    }
+  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
+__attribute__ ((__nothrow__)) bcopy (__const void *__restrict __src, void *__restrict __dest, size_t __len)
+{
+  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
+__attribute__ ((__nothrow__)) bzero (void *__dest, size_t __len)
+{
+  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strcpy (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) stpcpy (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strncpy (char *__restrict __dest, __const char *__restrict __src, size_t __len)
+{
+  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
+}
+extern char *__stpncpy_chk (char *__dest, __const char *__src, size_t __n,
+       size_t __destlen) __attribute__ ((__nothrow__));
+extern char *__stpncpy_alias (char *__dest, __const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) stpncpy (char *__dest, __const char *__src, size_t __n)
+{
+  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
+      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))
+    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
+  return __stpncpy_alias (__dest, __src, __n);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strcat (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strncat (char *__restrict __dest, __const char *__restrict __src, size_t __len)
+{
+  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
+}
+union wait
+  {
+    int w_status;
+    struct
+      {
+ unsigned int __w_termsig:7;
+ unsigned int __w_coredump:1;
+ unsigned int __w_retcode:8;
+ unsigned int:16;
+      } __wait_terminated;
+    struct
+      {
+ unsigned int __w_stopval:8;
+ unsigned int __w_stopsig:8;
+ unsigned int:16;
+      } __wait_stopped;
+  };
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+typedef struct
+  {
+    int quot;
+    int rem;
+  } div_t;
+typedef struct
+  {
+    long int quot;
+    long int rem;
+  } ldiv_t;
+__extension__ typedef struct
+  {
+    long long int quot;
+    long long int rem;
+  } lldiv_t;
+extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern double atof (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int atoi (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int atol (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__ extern long long int atoll (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern double strtod (__const char *__restrict __nptr,
+        char **__restrict __endptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern float strtof (__const char *__restrict __nptr,
+       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long double strtold (__const char *__restrict __nptr,
+       char **__restrict __endptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int strtol (__const char *__restrict __nptr,
+   char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern unsigned long int strtoul (__const char *__restrict __nptr,
+      char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoq (__const char *__restrict __nptr,
+        char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtouq (__const char *__restrict __nptr,
+           char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoll (__const char *__restrict __nptr,
+         char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtoull (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int strtol_l (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base,
+     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+extern unsigned long int strtoul_l (__const char *__restrict __nptr,
+        char **__restrict __endptr,
+        int __base, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoll_l (__const char *__restrict __nptr,
+    char **__restrict __endptr, int __base,
+    __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
+       char **__restrict __endptr,
+       int __base, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+extern double strtod_l (__const char *__restrict __nptr,
+   char **__restrict __endptr, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern float strtof_l (__const char *__restrict __nptr,
+         char **__restrict __endptr, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern long double strtold_l (__const char *__restrict __nptr,
+         char **__restrict __endptr,
+         __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern __inline double
+__attribute__ ((__nothrow__)) atof (__const char *__nptr)
+{
+  return strtod (__nptr, (char **) ((void *)0));
+}
+extern __inline int
+__attribute__ ((__nothrow__)) atoi (__const char *__nptr)
+{
+  return (int) strtol (__nptr, (char **) ((void *)0), 10);
+}
+extern __inline long int
+__attribute__ ((__nothrow__)) atol (__const char *__nptr)
+{
+  return strtol (__nptr, (char **) ((void *)0), 10);
+}
+__extension__ extern __inline long long int
+__attribute__ ((__nothrow__)) atoll (__const char *__nptr)
+{
+  return strtoll (__nptr, (char **) ((void *)0), 10);
+}
+extern char *l64a (long int __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern long int a64l (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int random (void) __attribute__ ((__nothrow__));
+extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));
+extern char *initstate (unsigned int __seed, char *__statebuf,
+   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+struct random_data
+  {
+    int32_t *fptr;
+    int32_t *rptr;
+    int32_t *state;
+    int rand_type;
+    int rand_deg;
+    int rand_sep;
+    int32_t *end_ptr;
+  };
+extern int random_r (struct random_data *__restrict __buf,
+       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int srandom_r (unsigned int __seed, struct random_data *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+   size_t __statelen,
+   struct random_data *__restrict __buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
+extern int setstate_r (char *__restrict __statebuf,
+         struct random_data *__restrict __buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int rand (void) __attribute__ ((__nothrow__));
+extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));
+extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));
+extern double drand48 (void) __attribute__ ((__nothrow__));
+extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern long int lrand48 (void) __attribute__ ((__nothrow__));
+extern long int nrand48 (unsigned short int __xsubi[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern long int mrand48 (void) __attribute__ ((__nothrow__));
+extern long int jrand48 (unsigned short int __xsubi[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
+extern unsigned short int *seed48 (unsigned short int __seed16v[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+struct drand48_data
+  {
+    unsigned short int __x[3];
+    unsigned short int __old_x[3];
+    unsigned short int __c;
+    unsigned short int __init;
+    unsigned long long int __a;
+  };
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int erand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int nrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int jrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int seed48_r (unsigned short int __seed16v[3],
+       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int lcong48_r (unsigned short int __param[7],
+        struct drand48_data *__buffer)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *realloc (void *__ptr, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) __attribute__ ((__nothrow__));
+extern void cfree (void *__ptr) __attribute__ ((__nothrow__));
+extern void *alloca (size_t __size) __attribute__ ((__nothrow__));
+extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void quick_exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *__secure_getenv (__const char *__name)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int setenv (__const char *__name, __const char *__value, int __replace)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));
+extern int clearenv (void) __attribute__ ((__nothrow__));
+extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int system (__const char *__command) __attribute__ ((__warn_unused_result__));
+extern char *canonicalize_file_name (__const char *__name)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *realpath (__const char *__restrict __name,
+         char *__restrict __resolved) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+typedef __compar_fn_t comparison_fn_t;
+typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);
+extern void *bsearch (__const void *__key, __const void *__base,
+        size_t __nmemb, size_t __size, __compar_fn_t __compar)
+     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
+extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
+       __compar_d_fn_t __compar, void *__arg)
+  __attribute__ ((__nonnull__ (1, 4)));
+extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+__extension__ extern long long int llabs (long long int __x)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern div_t div (int __numer, int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+__extension__ extern lldiv_t lldiv (long long int __numer,
+        long long int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *gcvt (double __value, int __ndigit, char *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));
+extern char *qecvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *qfcvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *qgcvt (long double __value, int __ndigit, char *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));
+extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qecvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qfcvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int mbtowc (wchar_t *__restrict __pwc,
+     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern size_t mbstowcs (wchar_t *__restrict __pwcs,
+   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));
+extern size_t wcstombs (char *__restrict __s,
+   __const wchar_t *__restrict __pwcs, size_t __n)
+     __attribute__ ((__nothrow__));
+extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int getsubopt (char **__restrict __optionp,
+        char *__const *__restrict __tokens,
+        char **__restrict __valuep)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));
+extern int grantpt (int __fd) __attribute__ ((__nothrow__));
+extern int unlockpt (int __fd) __attribute__ ((__nothrow__));
+extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int getpt (void);
+extern int getloadavg (double __loadavg[], int __nelem)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern char *__realpath_chk (__const char *__restrict __name,
+        char *__restrict __resolved,
+        size_t __resolvedlen) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *__realpath_alias (__const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__))
+                                                 __attribute__ ((__warn_unused_result__));
+extern char *__realpath_chk_warn (__const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__))
+                                                __attribute__ ((__warn_unused_result__))
+     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
+                                      ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+__attribute__ ((__nothrow__)) realpath (__const char *__restrict __name, char *__restrict __resolved)
+{
+  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
+    {
+      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
+    }
+  return __realpath_alias (__name, __resolved);
+}
+extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
+       size_t __nreal) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__))
+     __attribute__ ((__nonnull__ (2)));
+extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__))
+     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
+                   ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
+{
+  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+ return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
+      if (__buflen > __builtin_object_size (__buf, 2 > 1))
+ return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
+    }
+  return __ptsname_r_alias (__fd, __buf, __buflen);
+}
+extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
+  __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__))
+              __attribute__ ((__warn_unused_result__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
+__attribute__ ((__nothrow__)) wctomb (char *__s, wchar_t __wchar)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
+    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
+  return __wctomb_alias (__s, __wchar);
+}
+extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
+         __const char *__restrict __src,
+         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__));
+extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__))
+                                  ;
+extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__))
+     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
+                        ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
+__attribute__ ((__nothrow__)) mbstowcs (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len)
+{
+  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+ return __mbstowcs_chk (__dst, __src, __len,
+          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
+      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
+ return __mbstowcs_chk_warn (__dst, __src, __len,
+         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
+    }
+  return __mbstowcs_alias (__dst, __src, __len);
+}
+extern size_t __wcstombs_chk (char *__restrict __dst,
+         __const wchar_t *__restrict __src,
+         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__));
+extern size_t __wcstombs_alias (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__))
+                                  ;
+extern size_t __wcstombs_chk_warn (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__))
+     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
+__attribute__ ((__nothrow__)) wcstombs (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len)
+{
+  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+ return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
+      if (__len > __builtin_object_size (__dst, 2 > 1))
+ return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
+    }
+  return __wcstombs_alias (__dst, __src, __len);
+}
+enum
+{
+  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
+  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
+  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
+  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
+  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
+  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
+  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
+  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
+  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
+  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
+  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
+  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
+};
+extern __const unsigned short int **__ctype_b_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern __const __int32_t **__ctype_tolower_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern __const __int32_t **__ctype_toupper_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern int isalnum (int) __attribute__ ((__nothrow__));
+extern int isalpha (int) __attribute__ ((__nothrow__));
+extern int iscntrl (int) __attribute__ ((__nothrow__));
+extern int isdigit (int) __attribute__ ((__nothrow__));
+extern int islower (int) __attribute__ ((__nothrow__));
+extern int isgraph (int) __attribute__ ((__nothrow__));
+extern int isprint (int) __attribute__ ((__nothrow__));
+extern int ispunct (int) __attribute__ ((__nothrow__));
+extern int isspace (int) __attribute__ ((__nothrow__));
+extern int isupper (int) __attribute__ ((__nothrow__));
+extern int isxdigit (int) __attribute__ ((__nothrow__));
+extern int tolower (int __c) __attribute__ ((__nothrow__));
+extern int toupper (int __c) __attribute__ ((__nothrow__));
+extern int isblank (int) __attribute__ ((__nothrow__));
+extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__));
+extern int isascii (int __c) __attribute__ ((__nothrow__));
+extern int toascii (int __c) __attribute__ ((__nothrow__));
+extern int _toupper (int) __attribute__ ((__nothrow__));
+extern int _tolower (int) __attribute__ ((__nothrow__));
+extern __inline int
+__attribute__ ((__nothrow__)) tolower (int __c)
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
+}
+extern __inline int
+__attribute__ ((__nothrow__)) toupper (int __c)
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
+}
+extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern char *program_invocation_name, *program_invocation_short_name;
+typedef int error_t;
+extern void __assert_fail (__const char *__assertion, __const char *__file,
+      unsigned int __line, __const char *__function)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void __assert_perror_fail (int __errnum, __const char *__file,
+      unsigned int __line,
+      __const char *__function)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void __assert (const char *__assertion, const char *__file, int __line)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+void CVMhalt(CVMInt32 status);
+void CVMsystemPanic( const char * msg );
+int CVMassertHook(const char *filename, int lineno, const char *expr);
+extern void
+CVMgcimplInitGlobalState(CVMGCGlobalState* globalState);
+extern CVMBool
+CVMgcimplInitHeap(CVMGCGlobalState* globalState,
+    CVMUint32 startBytes,
+    CVMUint32 minBytes,
+    CVMUint32 maxBytes,
+    CVMBool startIsUnspecified,
+    CVMBool minIsUnspecified,
+    CVMBool maxIsUnspecified);
+extern CVMObject*
+CVMgcimplAllocObject(CVMExecEnv* ee, CVMUint32 numBytes);
+extern CVMObject*
+CVMgcimplRetryAllocationAfterGC(CVMExecEnv* ee, CVMUint32 numBytes);
+void
+CVMgcimplDoGC(CVMExecEnv* ee, CVMUint32 numBytes);
+CVMUint32
+CVMgcimplFreeMemory(CVMExecEnv* ee);
+CVMUint32
+CVMgcimplTotalMemory(CVMExecEnv* ee);
+extern void
+CVMgcimplDestroyGlobalState(CVMGCGlobalState* globalState);
+extern CVMBool
+CVMgcimplDestroyHeap(CVMGCGlobalState* globalState);
+extern CVMInt64
+CVMgcimplTimeOfLastMajorGC();
+extern CVMBool
+CVMgcimplIterateHeap(CVMExecEnv* ee, CVMObjectCallbackFunc cback, void* data);
+void CVMgcimplDumpSysInfo();
+extern const CVMClassBlock*
+CVMpreloaderLookup(const char* className);
+const char *
+CVMpreloaderGetClassLoaderNames(CVMExecEnv *ee);
+void
+CVMpreloaderRegisterClassLoaderUnsafe(CVMExecEnv *ee, CVMInt32 index,
+    CVMClassLoaderICell *loader);
+extern CVMClassBlock*
+CVMpreloaderLookupFromType(CVMExecEnv *ee,
+    CVMClassTypeID typeID, CVMObjectICell *loader);
+extern CVMClassBlock*
+CVMpreloaderLookupPrimitiveClassFromType(CVMClassTypeID classType);
+extern void
+CVMpreloaderInit();
+extern CVMBool
+CVMpreloaderReallyInROM(CVMObject* ref);
+extern void
+CVMpreloaderInitializeStringInterning(CVMExecEnv* ee);
+extern void
+CVMpreloaderDestroy();
+extern void
+CVMpreloaderCheckROMClassInitState(CVMExecEnv* ee);
+extern CVMBool
+CVMpreloaderDisambiguateAllMethods(CVMExecEnv* ee);
+extern void
+CVMpreloaderIterateAllClasses(CVMExecEnv* ee,
+         CVMClassCallbackFunc callback,
+         void* data);
+CVMBool CVMpreloaderIsPreloadedObject(CVMObject *obj);
+CVMBool
+CVMpreloaderIteratePreloadedObjects(CVMExecEnv *ee,
+                                    CVMObjectCallbackFunc callback,
+                                    void *callbackData);
+extern const CVMClassBlock sun_misc_CVM_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_AppClassLoader_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_ClassContainer_Classblock;
+extern const CVMClassBlock sun_misc_ThreadRegistry_Classblock;
+extern const CVMClassBlock java_lang_Object_Classblock;
+extern const CVMClassBlock java_lang_AssertionStatusDirectives_Classblock;
+extern const CVMClassBlock java_lang_Class_Classblock;
+extern const CVMClassBlock java_lang_ClassLoader_Classblock;
+extern const CVMClassBlock java_lang_ClassLoader_NativeLibrary_Classblock;
+extern const CVMClassBlock java_lang_Math_Classblock;
+extern const CVMClassBlock java_lang_Shutdown_Classblock;
+extern const CVMClassBlock java_lang_String_Classblock;
+extern const CVMClassBlock java_lang_Thread_Classblock;
+extern const CVMClassBlock java_lang_ThreadGroup_Classblock;
+extern const CVMClassBlock java_lang_Throwable_Classblock;
+extern const CVMClassBlock java_lang_StackTraceElement_Classblock;
+extern const CVMClassBlock java_lang_Exception_Classblock;
+extern const CVMClassBlock java_lang_Error_Classblock;
+extern const CVMClassBlock java_lang_ThreadDeath_Classblock;
+extern const CVMClassBlock java_lang_Cloneable_Classblock;
+extern const CVMClassBlock java_lang_System_Classblock;
+extern const CVMClassBlock java_io_File_Classblock;
+extern const CVMClassBlock java_io_Serializable_Classblock;
+extern const CVMClassBlock java_net_URLConnection_Classblock;
+extern const CVMClassBlock java_lang_reflect_Field_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_Classblock;
+extern const CVMClassBlock java_lang_ref_SoftReference_Classblock;
+extern const CVMClassBlock java_lang_ref_WeakReference_Classblock;
+extern const CVMClassBlock java_lang_ref_PhantomReference_Classblock;
+extern const CVMClassBlock java_lang_ref_FinalReference_Classblock;
+extern const CVMClassBlock java_lang_ref_Finalizer_Classblock;
+extern const CVMClassBlock java_lang_ref_Reference_Classblock;
+extern const CVMClassBlock java_util_jar_JarFile_Classblock;
+extern const CVMClassBlock java_util_ResourceBundle_Classblock;
+extern const CVMClassBlock java_security_AccessController_Classblock;
+extern const CVMClassBlock java_security_CodeSource_Classblock;
+extern const CVMClassBlock java_security_SecureClassLoader_Classblock;
+extern const CVMClassBlock java_lang_ClassCircularityError_Classblock;
+extern const CVMClassBlock java_lang_ClassFormatError_Classblock;
+extern const CVMClassBlock java_lang_IllegalAccessError_Classblock;
+extern const CVMClassBlock java_lang_InstantiationError_Classblock;
+extern const CVMClassBlock java_lang_LinkageError_Classblock;
+extern const CVMClassBlock java_lang_UnsupportedClassVersionError_Classblock;
+extern const CVMClassBlock java_lang_VerifyError_Classblock;
+extern const CVMClassBlock java_lang_UnsatisfiedLinkError_Classblock;
+extern const CVMClassBlock java_lang_NegativeArraySizeException_Classblock;
+extern const CVMClassBlock java_lang_NoSuchFieldException_Classblock;
+extern const CVMClassBlock java_lang_NoSuchMethodException_Classblock;
+extern const CVMClassBlock java_lang_IncompatibleClassChangeError_Classblock;
+extern const CVMClassBlock java_lang_AbstractMethodError_Classblock;
+extern const CVMClassBlock java_lang_ArithmeticException_Classblock;
+extern const CVMClassBlock java_lang_ArrayIndexOutOfBoundsException_Classblock;
+extern const CVMClassBlock java_lang_ArrayStoreException_Classblock;
+extern const CVMClassBlock java_lang_ClassCastException_Classblock;
+extern const CVMClassBlock java_lang_ClassNotFoundException_Classblock;
+extern const CVMClassBlock java_lang_CloneNotSupportedException_Classblock;
+extern const CVMClassBlock java_lang_IllegalAccessException_Classblock;
+extern const CVMClassBlock java_lang_IllegalArgumentException_Classblock;
+extern const CVMClassBlock java_lang_IllegalMonitorStateException_Classblock;
+extern const CVMClassBlock java_lang_IllegalStateException_Classblock;
+extern const CVMClassBlock java_lang_InstantiationException_Classblock;
+extern const CVMClassBlock java_lang_InternalError_Classblock;
+extern const CVMClassBlock java_lang_InterruptedException_Classblock;
+extern const CVMClassBlock java_lang_NoClassDefFoundError_Classblock;
+extern const CVMClassBlock java_lang_NoSuchFieldError_Classblock;
+extern const CVMClassBlock java_lang_NoSuchMethodError_Classblock;
+extern const CVMClassBlock java_lang_NullPointerException_Classblock;
+extern const CVMClassBlock java_lang_OutOfMemoryError_Classblock;
+extern const CVMClassBlock java_lang_StackOverflowError_Classblock;
+extern const CVMClassBlock java_lang_StringIndexOutOfBoundsException_Classblock;
+extern const CVMClassBlock java_lang_UnsupportedOperationException_Classblock;
+extern const CVMClassBlock java_io_InvalidClassException_Classblock;
+extern const CVMClassBlock java_io_IOException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_ArgumentException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_AccessException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_ArgumentException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_AccessException_Classblock;
+extern const CVMClassBlock sun_io_ConversionBufferFullException_Classblock;
+extern const CVMClassBlock sun_io_UnknownCharacterException_Classblock;
+extern const CVMClassBlock sun_io_MalformedInputException_Classblock;
+extern const CVMClassBlock manufacturedArrayOfBoolean_Classblock;
+extern const CVMClassBlock manufacturedArrayOfChar_Classblock;
+extern const CVMClassBlock manufacturedArrayOfFloat_Classblock;
+extern const CVMClassBlock manufacturedArrayOfDouble_Classblock;
+extern const CVMClassBlock manufacturedArrayOfByte_Classblock;
+extern const CVMClassBlock manufacturedArrayOfShort_Classblock;
+extern const CVMClassBlock manufacturedArrayOfInt_Classblock;
+extern const CVMClassBlock manufacturedArrayOfLong_Classblock;
+extern const CVMClassBlock manufacturedArrayOfObject_Classblock;
+extern const CVMClassBlock primitiveClass_boolean_Classblock;
+extern const CVMClassBlock primitiveClass_char_Classblock;
+extern const CVMClassBlock primitiveClass_float_Classblock;
+extern const CVMClassBlock primitiveClass_double_Classblock;
+extern const CVMClassBlock primitiveClass_byte_Classblock;
+extern const CVMClassBlock primitiveClass_short_Classblock;
+extern const CVMClassBlock primitiveClass_int_Classblock;
+extern const CVMClassBlock primitiveClass_long_Classblock;
+extern const CVMClassBlock primitiveClass_void_Classblock;
+extern const CVMClassBlock java_lang_Boolean_Classblock;
+extern const CVMClassBlock java_lang_Character_Classblock;
+extern const CVMClassBlock java_lang_Float_Classblock;
+extern const CVMClassBlock java_lang_Double_Classblock;
+extern const CVMClassBlock java_lang_Byte_Classblock;
+extern const CVMClassBlock java_lang_Short_Classblock;
+extern const CVMClassBlock java_lang_Integer_Classblock;
+extern const CVMClassBlock java_lang_Long_Classblock;
+extern CVMAddr * const CVM_staticData;
+extern CVMUint32 CVM_nStaticData;
+extern CVMAddr CVM_StaticDataMaster[];
+extern const int CVM_nROMClasses;
+extern void
+CVMweakrefInit();
+extern void
+CVMweakrefDiscover(CVMExecEnv* ee, CVMObject* weakRef);
+extern void
+CVMweakrefProcessNonStrong(CVMExecEnv* ee,
+      CVMRefLivenessQueryFunc isLive,
+      void* isLiveData,
+      CVMRefCallbackFunc transitiveScanner,
+      void* transitiveScannerData,
+      CVMGCOptions* gcOpts);
+extern void
+CVMweakrefRollbackHandling(CVMExecEnv* ee,
+      CVMGCOptions* gcOpts,
+      CVMRefCallbackFunc rootRollbackFunction,
+      void* rootRollbackData);
+void
+CVMweakrefFinalizeProcessing(CVMExecEnv* ee,
+        CVMRefLivenessQueryFunc isLive, void* isLiveData,
+        CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData,
+        CVMGCOptions* gcOpts);
+extern void
+CVMweakrefUpdate(CVMExecEnv* ee,
+   CVMRefCallbackFunc refUpdate, void* updateData,
+   CVMGCOptions* gcOpts);
+extern void
+CVMweakrefCleanUpForGCAbort(CVMExecEnv* ee);
+extern CVMBool CVMinitVMTargetGlobalState();
+extern void CVMdestroyVMTargetGlobalState();
+typedef struct CVMpathInfo CVMpathInfo;
+struct CVMpathInfo {
+    char *basePath;
+    char *libPath;
+    char *dllPath;
+    char *preBootclasspath;
+    char *postBootclasspath;
+};
+extern CVMBool CVMinitStaticState(CVMpathInfo *);
+extern void CVMdestroyStaticState();
+typedef struct {
+    const char *library_path;
+    const char *dll_dir;
+    const char *java_home;
+    const char *ext_dirs;
+    const char *sysclasspath;
+} CVMProperties;
+extern const CVMProperties *CVMgetProperties(void);
+struct CVMTargetGlobalState {
+    int dummy;
+    CVMThreadID *io_queue;
+};
+extern CVMBool
+linuxSegvHandlerInit(void);
+extern CVMTargetGlobalState * const CVMtargetGlobals;
+extern CNINativeMethod CNIsun_misc_CVM_setSystemClassLoader;
+extern CNINativeMethod CNIsun_misc_CVM_checkDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_clearDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_restoreDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_checkDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_clearDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_restoreDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_copyBooleanArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyByteArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyCharArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyShortArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyIntArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyFloatArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyLongArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyDoubleArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyObjectArray;
+extern CNINativeMethod CNIsun_misc_CVM_executeClinit;
+extern CNINativeMethod CNIsun_misc_CVM_freeClinit;
+extern CNINativeMethod CNIsun_misc_CVM_executeLoadSuperClasses;
+extern CNINativeMethod CNIsun_misc_CVM_disableRemoteExceptions;
+extern CNINativeMethod CNIsun_misc_CVM_enableRemoteExceptions;
+extern CNINativeMethod CNIsun_misc_CVM_throwRemoteException;
+extern CNINativeMethod CNIsun_misc_CVM_maskInterrupts;
+extern CNINativeMethod CNIsun_misc_CVM_unmaskInterrupts;
+extern CNINativeMethod CNIsun_misc_CVM_throwLocalException;
+extern CNINativeMethod CNIsun_misc_CVM_setContextArtificial;
+extern CNINativeMethod CNIsun_misc_CVM_callerCLIsMIDCLs;
+extern CNINativeMethod CNIsun_misc_CVM_isMIDPContext;
+extern CNINativeMethod CNIsun_misc_CVM_inMainLVM;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapSimple;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapVerbose;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapStats;
+extern CNINativeMethod CNIsun_misc_CVM_trace;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugEvents;
+extern CNINativeMethod CNIsun_misc_CVM_postThreadExit;
+extern CNINativeMethod CNIsun_misc_CVM_objectInflatePermanently;
+extern CNINativeMethod CNIsun_misc_CVM_setThreadNoCompilationsFlag;
+extern CNINativeMethod CNIsun_misc_CVM_getCallerClass;
+extern CNINativeMethod CNIsun_misc_CVM_isCompilerSupported;
+extern CNINativeMethod CNIsun_misc_CVM_dumpCompilerProfileData;
+extern CNINativeMethod CNIsun_misc_CVM_dumpStats;
+extern CNINativeMethod CNIsun_misc_CVM_markCodeBuffer;
+extern CNINativeMethod CNIsun_misc_CVM_initializeJITPolicy;
+extern CNINativeMethod CNIsun_misc_CVM_initializeAOTCode;
+extern CNINativeMethod CNIsun_misc_CVM_parseVerifyOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXoptOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXgcOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXssOption;
+extern CNINativeMethod CNIsun_misc_CVM_parseAssertionOptions;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibSupported;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibInitialize;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibProcess;
+extern CNINativeMethod CNIsun_misc_CVM_xrunSupported;
+extern CNINativeMethod CNIsun_misc_CVM_xrunInitialize;
+extern CNINativeMethod CNIsun_misc_CVM_xrunProcess;
+extern CNINativeMethod CNIsun_misc_CVM_xdebugSet;
+extern CNINativeMethod CNIsun_misc_CVM_simpleLockGrab;
+extern CNINativeMethod CNIsun_misc_CVM_simpleLockRelease;
+extern CNINativeMethod CNIsun_misc_CVM_getBuildOptionString;
+extern CNINativeMethod CNIsun_misc_CVM_nanoTime;
+extern CNINativeMethod CNIsun_misc_CVM_setURLConnectionDefaultUseCaches;
+extern CNINativeMethod CNIsun_misc_CVM_clearURLClassLoaderUcpField;
+void CVMconsolePrintf(const char* format, ...);
+void
+CVMdumpException(CVMExecEnv* ee);
+extern CVMInt32
+CVMcheckDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMsetDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMclearDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMrestoreDebugFlags(CVMInt32 flags, CVMInt32 oldvalue);
+extern void CVMlong2String(CVMInt64, char*, char*);
+void
+CVMdumpThread(JNIEnv* env);
+void
+CVMprintThreadName(JNIEnv* env, CVMObjectICell* threadICell);
+extern char*
+CVMclassname2String(CVMClassTypeID classTypeID, char *dst, int size);
+extern CVMSize
+CVMutfLength(const char *);
+extern int
+CVMutfCountedCopyIntoCharArray(
+    const char * utf8Bytes, CVMJavaChar* unicodeChars, CVMSize unicodeLength );
+extern void
+CVMutfCopyIntoCharArray(const char* utf8Bytes, CVMJavaChar* unicodeChars);
+extern char*
+CVMutfCopyFromCharArray(const CVMJavaChar* unicodeChars,
+   char* utf8Bytes, CVMInt32 count);
+extern CVMJavaChar
+CVMutfNextUnicodeChar(const char** utf8String_p);
+size_t
+CVMformatString(char *buf, size_t bufSize, const char *format, ...);
+size_t
+CVMformatStringVaList(char *buf, size_t bufSize,
+    const char *format, va_list ap);
+extern void
+CVMnewStringUTF(CVMExecEnv* ee, CVMStringICell* resultICell,
+  const char* utf8Bytes);
+extern void
+CVMnewString(CVMExecEnv* ee, CVMStringICell* resultICell,
+      const CVMJavaChar* unicodeChars, CVMUint32 len);
+CVMBool CVMisSameClassPackage(CVMExecEnv* ee,
+         CVMClassBlock* class1, CVMClassBlock* class2);
+extern CVMClassBlock*
+CVMgcSafeClassRef2ClassBlock(CVMExecEnv* ee, CVMClassICell *clazz);
+extern CVMClassBlock *
+CVMgcUnsafeClassRef2ClassBlock(CVMExecEnv *ee, CVMClassICell *clazz);
+extern void
+CVMrandomInit();
+extern CVMInt32
+CVMrandomNext();
+CVMBool
+CVMgcSafeJavaWrap(CVMExecEnv* ee, jvalue v,
+    CVMBasicType fromType,
+    CVMObjectICell* result);
+CVMBool
+CVMgcSafeJavaUnwrap(CVMExecEnv* ee, CVMObjectICell* obj,
+      jvalue* v, CVMBasicType* toType,
+      CVMClassBlock* exceptionCb);
+CVMBool
+CVMgcUnsafeJavaUnwrap(CVMExecEnv* ee, CVMObject* obj,
+        jvalue* v, CVMBasicType* toType,
+        CVMClassBlock* exceptionCb);
+CVMBool
+CVMputProp(JNIEnv* env, jmethodID putID,
+    jobject props, const char* key, const char* val);
+CVMBool
+CVMputPropForPlatformCString(JNIEnv* env, jmethodID putID,
+        jobject props, const char* key, const char* val);
+CVMUint32 CVMpackSizeBy(CVMUint32 sizeToPack, CVMUint32 packingIncrement);
+extern CVMInt32
+CVMoptionToInt32(const char* optionString);
+typedef struct {
+    CVMUint32 numOptions;
+    char** options;
+} CVMParsedSubOptions;
+extern CVMBool
+CVMinitParsedSubOptions(CVMParsedSubOptions* subOptions,
+   const char* subOptionsString);
+extern void
+CVMdestroyParsedSubOptions(CVMParsedSubOptions *opts);
+extern const char *
+CVMgetParsedSubOption(const CVMParsedSubOptions* subOptions,
+        const char* subOptionName);
+typedef enum {
+    CVM_NULL_OPTION = 0,
+    CVM_INTEGER_OPTION,
+    CVM_BOOLEAN_OPTION,
+    CVM_PERCENT_OPTION,
+    CVM_STRING_OPTION,
+    CVM_MULTI_STRING_OPTION,
+    CVM_ENUM_OPTION
+} CVMSubOptionKindEnum;
+typedef struct {
+    const char *name;
+    CVMUint32 value;
+} CVMSubOptionEnumData;
+typedef struct {
+    const char* name;
+    const char* description;
+    CVMSubOptionKindEnum kind;
+    union {
+ struct {
+     int minValue;
+     CVMAddr maxValue;
+     CVMAddr defaultValue;
+ } intData;
+ struct {
+     int ignored1;
+     const char* helpSyntax;
+     const char* defaultValue;
+ } strData;
+ struct {
+     int numPossibleValues;
+     const char** possibleValues;
+     CVMAddr defaultValue;
+ } multiStrData;
+        struct {
+            int numPossibleValues;
+            const CVMSubOptionEnumData* possibleValues;
+            CVMAddr defaultValue;
+        } enumData;
+    } data;
+    const void* valuePtr;
+} CVMSubOptionData;
+extern CVMBool
+CVMprocessSubOptions(const CVMSubOptionData* knownSubOptions,
+       const char* optionName,
+       CVMParsedSubOptions *parsedSubOptions);
+extern void
+CVMprintSubOptionValues(const CVMSubOptionData* knownSubOptions);
+extern void
+CVMprintSubOptionsUsageString(const CVMSubOptionData* knownSubOptions);
+extern CVMBool
+CVMinitPathValues(void *propsPtr, CVMpathInfo *pathInfo,
+                  char **userBootclasspath);
+extern void CVMdestroyPathInfo(CVMpathInfo *);
+extern void
+CVMdestroyPathValues(void *propsPtr);
+extern char*
+CVMconvertJavaStringToCString(CVMExecEnv* ee, jobject stringobj);
+typedef struct CVMGCCommonGlobalState CVMGCCommonGlobalState;
+struct CVMGCCommonGlobalState {
+    CVMParsedSubOptions gcOptions;
+    CVMUint32 maxStackMapsMemorySize;
+    CVMBool doClassCleanup;
+    CVMBool stringInternedSinceLastGC;
+    CVMBool classCreatedSinceLastGC;
+    CVMBool loaderCreatedSinceLastGC;
+    CVMStackMaps *firstStackMaps;
+    CVMStackMaps *lastStackMaps;
+    CVMUint32 stackMapsTotalMemoryUsed;
+};
+struct CVMGCOptions {
+    CVMBool isUpdatingObjectPointers;
+    CVMBool discoverWeakReferences;
+    CVMBool isProfilingPass;
+};
+enum CVMGCRefType {
+    CVMGCRefType_INVALID = 0,
+    CVMGCRefType_GLOBAL_ROOT,
+    CVMGCRefType_PRELOADER_STATICS,
+    CVMGCRefType_CLASS_STATICS,
+    CVMGCRefType_LOCAL_ROOTS,
+    CVMGCRefType_UNKNOWN_STACK_FRAME,
+    CVMGCRefType_JAVA_FRAME,
+    CVMGCRefType_JNI_FRAME,
+    CVMGCRefType_TRANSITION_FRAME,
+    CVMGCRefType_OBJECT_FIELD
+};
+typedef enum CVMGCRefType CVMGCRefType;
+typedef struct CVMGCProfilingInfo CVMGCProfilingInfo;
+struct CVMGCProfilingInfo {
+    CVMGCRefType type;
+    void *data;
+    union {
+        struct {
+            CVMClassBlock *cb;
+        } clazz;
+        struct {
+            CVMExecEnv *ee;
+            CVMInt32 frameNumber;
+        } frame;
+    } u;
+};
+typedef struct CVMGCLocker CVMGCLocker;
+struct CVMGCLocker
+{
+    volatile CVMUint32 lockCount;
+    volatile CVMBool wasContended;
+};
+void CVMgcLockerInit(CVMGCLocker *self);
+void CVMgcLockerLock(CVMGCLocker *self, CVMExecEnv *current_ee);
+void CVMgcLockerUnlock(CVMGCLocker *self, CVMExecEnv *current_ee);
+extern CVMBool
+CVMgcInitHeap(CVMOptions *options);
+extern char *
+CVMgcGetGCAttributeVal(char* attrName);
+extern CVMObject*
+CVMgcAllocNewInstance(CVMExecEnv* ee, CVMClassBlock* cb);
+extern CVMObject*
+CVMgcAllocNewClassInstance(CVMExecEnv* ee, CVMClassBlock* cbOfJavaLangClass);
+extern CVMArrayOfAnyType*
+CVMgcAllocNewArray(CVMExecEnv* ee, CVMBasicType typeCode,
+     CVMClassBlock* arrayCb, CVMJavaInt len);
+extern CVMArrayOfAnyType*
+CVMgcAllocNewArrayWithInstanceSize(CVMExecEnv* ee, CVMJavaInt instanceSize,
+       CVMClassBlock* arrayCb, CVMJavaInt len);
+extern CVMJavaLong
+CVMgcFreeMemory(CVMExecEnv* ee);
+extern CVMJavaLong
+CVMgcTotalMemory(CVMExecEnv* ee);
+extern CVMBool
+CVMgcStopTheWorldAndGC(CVMExecEnv* ee, CVMUint32 numBytes);
+extern CVMBool
+CVMgcStopTheWorldAndDoAction(CVMExecEnv *ee, void *data,
+                 CVMUint32 (*preActionCallback)(CVMExecEnv *ee, void *data),
+                 CVMBool (*actionCallback)(CVMExecEnv *ee, void *data),
+                 void (*postActionCallback)(CVMExecEnv *ee, void *data,
+                                            CVMBool actionSuccess,
+                                            CVMUint32 preActionStatus),
+   void (*retryAfterActionCallback)(CVMExecEnv *ee, void *data),
+   void* retryData);
+extern void
+CVMgcStartGC(CVMExecEnv* ee);
+extern void
+CVMgcClearClassMarks(CVMExecEnv* ee, CVMGCOptions* gcOpts);
+extern void
+CVMgcEndGC(CVMExecEnv* ee);
+extern void
+CVMgcRunGC(CVMExecEnv* ee);
+extern void
+CVMnullFrameScanner(CVMFrame* frame, CVMStackChunk* chunk,
+      CVMRefCallbackFunc callback, void* data);
+extern void
+CVMgcProcessSpecialWithLivenessInfo(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefLivenessQueryFunc isLive,
+        void* isLiveData,
+                                    CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData);
+void
+CVMgcProcessWeakrefWithLivenessInfo(CVMExecEnv* ee,
+    CVMGCOptions* gcOpts, CVMRefLivenessQueryFunc isLive, void* isLiveData,
+    CVMRefCallbackFunc transitiveScanner, void* transitiveScannerData);
+void
+CVMgcProcessInternedStringsWithLivenessInfo(CVMExecEnv* ee,
+    CVMGCOptions* gcOpts, CVMRefLivenessQueryFunc isLive, void* isLiveData,
+    CVMRefCallbackFunc transitiveScanner, void* transitiveScannerData);
+extern void
+CVMgcProcessSpecialWithLivenessInfoWithoutWeakRefs(
+                                    CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefLivenessQueryFunc isLive,
+        void* isLiveData,
+                                    CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData);
+extern void
+CVMgcScanSpecial(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+   CVMRefCallbackFunc callback, void* data);
+extern void
+CVMgcScanRoots(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefCallbackFunc callback, void* data);
+extern CVMBool
+CVMgcEnsureStackmapsForRootScans(CVMExecEnv *ee);
+extern CVMBool
+CVMgcDestroyHeap();
+extern CVMBool
+CVMgcScanObjectRange(CVMExecEnv* ee, CVMUint32* base, CVMUint32* top,
+                     CVMObjectCallbackFunc callback, void* callbackData);
+struct CVMStackWalkContext {
+    CVMFrame* frame;
+    CVMStackChunk* chunk;
+};
+extern void
+CVMstackwalkInit(CVMStack* stack, CVMStackWalkContext* c);
+extern void
+CVMstackwalkDestroy(CVMStackWalkContext* c);
+extern void
+CVMstackwalkPrev(CVMStackWalkContext* c);
+typedef union CVMSlotVal32 {
+    CVMJavaVal32 j;
+    CVMUint8* a;
+} CVMSlotVal32;
+union CVMStackVal32 {
+    CVMJavaVal32 j;
+    CVMSlotVal32 s;
+    CVMObjectICell ref;
+    CVMStackVal32* next;
+};
+struct CVMStackChunk {
+    CVMStackChunk* prev;
+    CVMStackChunk* next;
+    CVMStackVal32* end_data;
+    CVMStackVal32 data[1];
+};
+struct CVMStack {
+    CVMStackChunk* firstStackChunk;
+    CVMStackChunk* currentStackChunk;
+    CVMUint32 minStackChunkSize;
+    CVMUint32 maxStackSize;
+    CVMUint32 stackSize;
+    CVMFrame* volatile currentFrame;
+    CVMStackVal32* stackChunkStart;
+    CVMStackVal32* stackChunkEnd;
+};
+typedef enum {
+    CVM_FRAMETYPE_NONE,
+    CVM_FRAMETYPE_JAVA,
+    CVM_FRAMETYPE_TRANSITION,
+    CVM_FRAMETYPE_FREELIST,
+    CVM_FRAMETYPE_LOCALROOT,
+    CVM_FRAMETYPE_GLOBALROOT,
+    CVM_FRAMETYPE_CLASSTABLE,
+    CVM_NUM_FRAMETYPES
+} CVMFrameType;
+typedef enum {
+    CVM_FRAMEFLAG_ARTIFICIAL = 0x1,
+    CVM_FRAMEFLAG_EXCEPTION = 0x2
+} CVMFrameFlags;
+extern CVMFrameGCScannerFunc * const CVMframeScanners[CVM_NUM_FRAMETYPES];
+struct CVMFrame {
+    CVMFrame* prevX;
+    CVMUint8 type;
+    CVMUint8 flags;
+    CVMStackVal32* volatile topOfStack;
+    CVMMethodBlock* volatile mb;
+};
+struct CVMFreelistFrame {
+    CVMFrame frame;
+    CVMUint32 inUse;
+    CVMStackVal32* freeList;
+    CVMStackVal32 vals[1];
+};
+extern
+CVMStackVal32* CVMexpandStack(CVMExecEnv* ee, CVMStack* s,
+         CVMUint32 capacity,
+         CVMBool throwException,
+         CVMBool justChecking);
+extern CVMBool
+CVMensureCapacity(CVMExecEnv* ee, CVMStack* stack, int capacity);
+extern CVMBool
+CVMstackDeleteLastChunk(CVMStack *stack, CVMStackChunk *chunk);
+extern void
+CVMstackEnableReserved(CVMStack *curStack);
+extern void
+CVMstackDisableReserved(CVMStack *curStack);
+extern CVMBool
+CVMinitStack(CVMExecEnv *ee, CVMStack* s,
+      CVMUint32 initialStackSize, CVMUint32 maxStackSize,
+      CVMUint32 minStackChunkSize, CVMUint32 initialFrameCapacity,
+      CVMFrameType frameType);
+extern void
+CVMdestroyStack(CVMStack* stack);
+extern CVMBool
+CVMinitGCRootStack(CVMExecEnv *ee, CVMStack* s, CVMUint32 initialStackSize,
+     CVMUint32 maxStackSize, CVMUint32 minStackChunkSize,
+     CVMFrameType frameType);
+extern void
+CVMdestroyGCRootStack(CVMStack* stack);
+extern void
+CVMdumpStack(CVMStack* s, CVMBool verbose, CVMBool includeData,
+      CVMInt32 frameLimit);
+extern CVMStackChunk*
+CVMdumpFrame(CVMFrame* frame, CVMStackChunk* startChunk,
+      CVMBool verbose, CVMBool includeData);
+extern CVMBool
+CVMCstackCheckSize(CVMExecEnv *ee, CVMUint32 redzone, char *func_name, CVMBool exceptionThrow);
+typedef void (*CVMFrameCallbackFunc)(CVMFrame *thisFrame);
+extern void
+CVMscanStack(CVMStack* stack, CVMFrameCallbackFunc frameCallback);
+extern void
+CVMscanStackForGC(CVMStack* stack);
+typedef CVMFreelistFrame CVMJNIFrame;
+extern CVMObjectICell *
+CVMjniCreateLocalRef(CVMExecEnv *);
+extern CVMObjectICell *
+CVMjniCreateLocalRef0(CVMExecEnv *, CVMExecEnv *targetEE);
+typedef struct {
+    JNIEnv vector;
+} CVMJNIEnv;
+extern void CVMinitJNIEnv(CVMJNIEnv *);
+extern void CVMdestroyJNIEnv(CVMJNIEnv *);
+struct JNIInvokeInterface;
+typedef struct {
+    const struct JNIInvokeInterface * vector;
+    volatile CVMBool directBufferSupportInitialized;
+    volatile CVMBool directBufferSupportInitializeFailed;
+    jclass bufferClass;
+    jclass directBufferClass;
+    jclass directByteBufferClass;
+    jmethodID directByteBufferLongConstructor;
+    jmethodID directByteBufferIntConstructor;
+    jfieldID directBufferAddressLongField;
+    jfieldID directBufferAddressIntField;
+    jfieldID bufferCapacityField;
+} CVMJNIJavaVM;
+extern void
+CVMinitJNIJavaVM(CVMJNIJavaVM *);
+extern void
+CVMdestroyJNIJavaVM(CVMJNIJavaVM *);
+extern struct JNINativeInterface *
+CVMjniGetInstrumentableJNINativeInterface();
+extern jint CVMjniGetVersion(JNIEnv *env);
+extern jclass CVMjniFindClass(JNIEnv *env, const char *name);
+extern jmethodID CVMjniFromReflectedMethod(JNIEnv* env,
+         jobject method);
+extern jfieldID CVMjniFromReflectedField(JNIEnv* env, jobject field);
+extern jobject CVMjniToReflectedMethod(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            jboolean isStatic);
+extern jboolean CVMjniIsAssignableFrom(JNIEnv* env,
+            jclass clazz1, jclass clazz2);
+extern jobject CVMjniToReflectedField(JNIEnv *env, jclass clazz,
+           jfieldID fieldID,
+           jboolean isStatic);
+extern jint CVMjniThrow(JNIEnv *env, jthrowable obj);
+extern jint CVMjniThrowNew(JNIEnv *env,
+       jclass clazz, const char *message);
+extern jthrowable CVMjniExceptionOccurred(JNIEnv *env);
+extern void CVMjniExceptionDescribe(JNIEnv *env);
+extern void CVMjniExceptionClear(JNIEnv *env);
+extern void CVMjniFatalError(JNIEnv *env, const char *msg);
+extern jint CVMjniPushLocalFrame(JNIEnv *env, jint capacity);
+extern jobject CVMjniPopLocalFrame(JNIEnv *env, jobject resultArg);
+extern jobject CVMjniNewGlobalRef(JNIEnv *env, jobject ref);
+extern void CVMjniDeleteGlobalRef(JNIEnv *env, jobject ref);
+extern void CVMjniDeleteLocalRef(JNIEnv *env, jobject obj);
+extern jboolean CVMjniIsSameObject(JNIEnv *env,
+        jobject ref1, jobject ref2);
+extern jobject CVMjniNewLocalRef(JNIEnv *env, jobject obj);
+extern jint CVMjniEnsureLocalCapacity(JNIEnv *env, jint capacity);
+extern jobject CVMjniAllocObject(JNIEnv *env, jclass clazz);
+extern jobject CVMjniNewObject(JNIEnv *env, jclass clazz,
+           jmethodID methodID, ...);
+extern jobject CVMjniNewObjectV(JNIEnv *env, jclass clazz,
+     jmethodID methodID, va_list args);
+extern jobject CVMjniNewObjectA(JNIEnv *env, jclass clazz,
+     jmethodID methodID, const jvalue *args);
+extern jclass CVMjniGetObjectClass(JNIEnv *env, jobject obj);
+extern jboolean CVMjniIsInstanceOf(JNIEnv* env, jobject obj,
+        jclass clazz);
+extern jmethodID CVMjniGetMethodID(JNIEnv *env, jclass clazz,
+        const char *name, const char *sig);
+extern jobject CVMjniCallObjectMethod(JNIEnv *env, jobject obj,
+           jmethodID methodID, ...);
+extern jobject CVMjniCallObjectMethodV(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            va_list args);
+extern jobject CVMjniCallObjectMethodA(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            const jvalue *args);
+extern jboolean CVMjniCallBooleanMethod(JNIEnv *env, jobject obj,
+      jmethodID methodID, ...);
+extern jboolean CVMjniCallBooleanMethodV(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       va_list args);
+extern jboolean CVMjniCallBooleanMethodA(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       const jvalue *args);
+extern jbyte CVMjniCallByteMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jbyte CVMjniCallByteMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jbyte CVMjniCallByteMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jchar CVMjniCallCharMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jchar CVMjniCallCharMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jchar CVMjniCallCharMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jshort CVMjniCallShortMethod(JNIEnv *env, jobject obj,
+         jmethodID methodID, ...);
+extern jshort CVMjniCallShortMethodV(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          va_list args);
+extern jshort CVMjniCallShortMethodA(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          const jvalue *args);
+extern jint CVMjniCallIntMethod(JNIEnv *env, jobject obj,
+     jmethodID methodID, ...);
+extern jint CVMjniCallIntMethodV(JNIEnv *env, jobject obj,
+      jmethodID methodID,
+      va_list args);
+extern jint CVMjniCallIntMethodA(JNIEnv *env, jobject obj,
+      jmethodID methodID,
+      const jvalue *args);
+extern jlong CVMjniCallLongMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jlong CVMjniCallLongMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jlong CVMjniCallLongMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jfloat CVMjniCallFloatMethod(JNIEnv *env, jobject obj,
+         jmethodID methodID, ...);
+extern jfloat CVMjniCallFloatMethodV(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          va_list args);
+extern jfloat CVMjniCallFloatMethodA(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          const jvalue *args);
+extern jdouble CVMjniCallDoubleMethod(JNIEnv *env, jobject obj,
+           jmethodID methodID, ...);
+extern jdouble CVMjniCallDoubleMethodV(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            va_list args);
+extern jdouble CVMjniCallDoubleMethodA(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            const jvalue *args);
+extern void CVMjniCallVoidMethod(JNIEnv *env, jobject obj,
+      jmethodID methodID, ...);
+extern void CVMjniCallVoidMethodV(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       va_list args);
+extern void CVMjniCallVoidMethodA(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       const jvalue *args);
+extern jobject CVMjniCallNonvirtualObjectMethod(JNIEnv *env,
+       jobject obj,
+       jclass clazz,
+       jmethodID methodID,
+       ...);
+extern jobject CVMjniCallNonvirtualObjectMethodV(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        va_list args);
+extern jobject CVMjniCallNonvirtualObjectMethodA(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        const jvalue *args);
+extern jboolean CVMjniCallNonvirtualBooleanMethod(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         ...);
+extern jboolean CVMjniCallNonvirtualBooleanMethodV(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          va_list args);
+extern jboolean CVMjniCallNonvirtualBooleanMethodA(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          const jvalue *args);
+extern jbyte CVMjniCallNonvirtualByteMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jbyte CVMjniCallNonvirtualByteMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jbyte CVMjniCallNonvirtualByteMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jchar CVMjniCallNonvirtualCharMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jchar CVMjniCallNonvirtualCharMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jchar CVMjniCallNonvirtualCharMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jshort CVMjniCallNonvirtualShortMethod(JNIEnv *env,
+            jobject obj,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jshort CVMjniCallNonvirtualShortMethodV(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jshort CVMjniCallNonvirtualShortMethodA(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jint CVMjniCallNonvirtualIntMethod(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        ...);
+extern jint CVMjniCallNonvirtualIntMethodV(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jint CVMjniCallNonvirtualIntMethodA(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jlong CVMjniCallNonvirtualLongMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jlong CVMjniCallNonvirtualLongMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jlong CVMjniCallNonvirtualLongMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jfloat CVMjniCallNonvirtualFloatMethod(JNIEnv *env,
+            jobject obj,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jfloat CVMjniCallNonvirtualFloatMethodV(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jfloat CVMjniCallNonvirtualFloatMethodA(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jdouble CVMjniCallNonvirtualDoubleMethod(JNIEnv *env,
+       jobject obj,
+       jclass clazz,
+       jmethodID methodID,
+       ...);
+extern jdouble CVMjniCallNonvirtualDoubleMethodV(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        va_list args);
+extern jdouble CVMjniCallNonvirtualDoubleMethodA(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        const jvalue *args);
+extern void CVMjniCallNonvirtualVoidMethod(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         ...);
+extern void CVMjniCallNonvirtualVoidMethodV(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          va_list args);
+extern void CVMjniCallNonvirtualVoidMethodA(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          const jvalue *args);
+extern jfieldID CVMjniGetFieldID(JNIEnv *env, jclass clazz,
+      const char *name, const char *sig);
+extern jobject CVMjniGetObjectField(JNIEnv* env, jobject obj,
+         jfieldID fid);
+extern jboolean CVMjniGetBooleanField(JNIEnv* env, jobject obj,
+           jfieldID fid);
+extern jbyte CVMjniGetByteField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jchar CVMjniGetCharField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jshort CVMjniGetShortField(JNIEnv* env, jobject obj,
+       jfieldID fid);
+extern jint CVMjniGetIntField(JNIEnv* env, jobject obj,
+          jfieldID fid);
+extern jlong CVMjniGetLongField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jfloat CVMjniGetFloatField(JNIEnv* env, jobject obj,
+       jfieldID fid);
+extern jdouble CVMjniGetDoubleField(JNIEnv* env, jobject obj,
+         jfieldID fid);
+extern void CVMjniSetObjectField(JNIEnv* env, jobject obj,
+      jfieldID fid, jobject rhs);
+extern void CVMjniSetBooleanField(JNIEnv* env, jobject obj,
+       jfieldID fid, jboolean rhs);
+extern void CVMjniSetByteField(JNIEnv* env, jobject obj,
+           jfieldID fid, jbyte rhs);
+extern void CVMjniSetCharField(JNIEnv* env, jobject obj,
+           jfieldID fid, jchar rhs);
+extern void CVMjniSetShortField(JNIEnv* env, jobject obj,
+     jfieldID fid, jshort rhs);
+extern void CVMjniSetIntField(JNIEnv* env, jobject obj,
+          jfieldID fid, jint rhs);
+extern void CVMjniSetLongField(JNIEnv* env, jobject obj,
+           jfieldID fid, jlong rhs);
+extern void CVMjniSetFloatField(JNIEnv* env, jobject obj,
+     jfieldID fid, jfloat rhs);
+extern void CVMjniSetDoubleField(JNIEnv* env, jobject obj,
+      jfieldID fid, jdouble rhs);
+extern jmethodID CVMjniGetStaticMethodID(JNIEnv *env, jclass clazz,
+       const char *name,
+       const char *sig);
+extern jobject CVMjniCallStaticObjectMethod(JNIEnv *env, jclass clazz,
+          jmethodID methodID, ...);
+extern jobject CVMjniCallStaticObjectMethodV(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jobject CVMjniCallStaticObjectMethodA(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jboolean CVMjniCallStaticBooleanMethod(JNIEnv *env,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jboolean CVMjniCallStaticBooleanMethodV(JNIEnv *env,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jboolean CVMjniCallStaticBooleanMethodA(JNIEnv *env,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jbyte CVMjniCallStaticByteMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jbyte CVMjniCallStaticByteMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jbyte CVMjniCallStaticByteMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jchar CVMjniCallStaticCharMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jchar CVMjniCallStaticCharMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jchar CVMjniCallStaticCharMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jshort CVMjniCallStaticShortMethod(JNIEnv *env, jclass clazz,
+        jmethodID methodID, ...);
+extern jshort CVMjniCallStaticShortMethodV(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jshort CVMjniCallStaticShortMethodA(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jint CVMjniCallStaticIntMethod(JNIEnv *env, jclass clazz,
+           jmethodID methodID, ...);
+extern jint CVMjniCallStaticIntMethodV(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            va_list args);
+extern jint CVMjniCallStaticIntMethodA(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            const jvalue *args);
+extern jlong CVMjniCallStaticLongMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jlong CVMjniCallStaticLongMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jlong CVMjniCallStaticLongMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jfloat CVMjniCallStaticFloatMethod(JNIEnv *env, jclass clazz,
+        jmethodID methodID, ...);
+extern jfloat CVMjniCallStaticFloatMethodV(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jfloat CVMjniCallStaticFloatMethodA(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jdouble CVMjniCallStaticDoubleMethod(JNIEnv *env, jclass clazz,
+          jmethodID methodID, ...);
+extern jdouble CVMjniCallStaticDoubleMethodV(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jdouble CVMjniCallStaticDoubleMethodA(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern void CVMjniCallStaticVoidMethod(JNIEnv *env, jclass clazz,
+            jmethodID methodID, ...);
+extern void CVMjniCallStaticVoidMethodV(JNIEnv *env, jclass clazz,
+      jmethodID methodID,
+      va_list args);
+extern void CVMjniCallStaticVoidMethodA(JNIEnv *env, jclass clazz,
+      jmethodID methodID,
+      const jvalue *args);
+extern jfieldID CVMjniGetStaticFieldID(JNIEnv *env,
+            jclass clazz,
+            const char *name,
+            const char *sig);
+extern jobject CVMjniGetStaticObjectField(JNIEnv* env,
+        jclass clazz, jfieldID fid);
+extern jboolean CVMjniGetStaticBooleanField(JNIEnv* env, jclass clazz,
+          jfieldID fid);
+extern jbyte CVMjniGetStaticByteField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jchar CVMjniGetStaticCharField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jshort CVMjniGetStaticShortField(JNIEnv* env, jclass clazz,
+      jfieldID fid);
+extern jint CVMjniGetStaticIntField(JNIEnv* env, jclass clazz,
+         jfieldID fid);
+extern jlong CVMjniGetStaticLongField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jfloat CVMjniGetStaticFloatField(JNIEnv* env, jclass clazz,
+      jfieldID fid);
+extern jdouble CVMjniGetStaticDoubleField(JNIEnv* env, jclass clazz,
+        jfieldID fid);
+extern void CVMjniSetStaticObjectField(JNIEnv* env, jclass clazz,
+            jfieldID fid, jobject rhs);
+extern void CVMjniSetStaticBooleanField(JNIEnv* env, jclass clazz,
+      jfieldID fid, jboolean rhs);
+extern void CVMjniSetStaticByteField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jbyte rhs);
+extern void CVMjniSetStaticCharField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jchar rhs);
+extern void CVMjniSetStaticShortField(JNIEnv* env, jclass clazz,
+           jfieldID fid, jshort rhs);
+extern void CVMjniSetStaticIntField(JNIEnv* env, jclass clazz,
+         jfieldID fid, jint rhs);
+extern void CVMjniSetStaticLongField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jlong rhs);
+extern void CVMjniSetStaticFloatField(JNIEnv* env, jclass clazz,
+           jfieldID fid, jfloat rhs);
+extern void CVMjniSetStaticDoubleField(JNIEnv* env, jclass clazz,
+            jfieldID fid, jdouble rhs);
+extern jstring CVMjniNewString(JNIEnv *env, const jchar* unicodeChars,
+           jsize len);
+extern jsize CVMjniGetStringLength(JNIEnv* env, jstring string);
+extern const jchar* CVMjniGetStringChars(JNIEnv *env, jstring string,
+       jboolean *isCopy);
+extern void CVMjniReleaseStringChars(JNIEnv *env, jstring str,
+          const jchar *chars);
+extern jstring CVMjniNewStringUTF(JNIEnv* env, const char* utf8Bytes);
+extern jsize CVMjniGetStringUTFLength(JNIEnv *env, jstring string);
+extern const char* CVMjniGetStringUTFChars(JNIEnv *env,
+         jstring string,
+         jboolean *isCopy);
+extern void CVMjniReleaseStringUTFChars(JNIEnv *env, jstring str,
+      const char *chars);
+extern jsize CVMjniGetArrayLength(JNIEnv* env, jarray arrArg);
+extern jarray CVMjniNewObjectArray(JNIEnv* env, jsize length,
+        jclass elementClass,
+        jobject initialElement);
+extern jobject CVMjniGetObjectArrayElement(JNIEnv* env,
+         jarray arrArg, jsize index);
+extern void CVMjniSetObjectArrayElement(JNIEnv* env, jarray arrArg,
+      jsize index, jobject value);
+extern jbooleanArray CVMjniNewBooleanArray(JNIEnv *env, jsize length);
+extern jbyteArray CVMjniNewByteArray(JNIEnv *env, jsize length);
+extern jcharArray CVMjniNewCharArray(JNIEnv *env, jsize length);
+extern jshortArray CVMjniNewShortArray(JNIEnv *env, jsize length);
+extern jintArray CVMjniNewIntArray(JNIEnv *env, jsize length);
+extern jlongArray CVMjniNewLongArray(JNIEnv *env, jsize length);
+extern jfloatArray CVMjniNewFloatArray(JNIEnv *env, jsize length);
+extern jdoubleArray CVMjniNewDoubleArray(JNIEnv *env, jsize length);
+extern jboolean * CVMjniGetBooleanArrayElements(JNIEnv *env,
+       jbooleanArray array,
+       jboolean *isCopy);
+extern jbyte * CVMjniGetByteArrayElements(JNIEnv *env,
+        jbyteArray array,
+        jboolean *isCopy);
+extern jchar * CVMjniGetCharArrayElements(JNIEnv *env,
+        jcharArray array,
+        jboolean *isCopy);
+extern jshort * CVMjniGetShortArrayElements(JNIEnv *env,
+          jshortArray array,
+          jboolean *isCopy);
+extern jint * CVMjniGetIntArrayElements(JNIEnv *env,
+      jintArray array,
+      jboolean *isCopy);
+extern jlong * CVMjniGetLongArrayElements(JNIEnv *env,
+        jlongArray array,
+        jboolean *isCopy);
+extern jfloat * CVMjniGetFloatArrayElements(JNIEnv *env,
+          jfloatArray array,
+          jboolean *isCopy);
+extern jdouble * CVMjniGetDoubleArrayElements(JNIEnv *env,
+            jdoubleArray array,
+            jboolean *isCopy);
+extern void CVMjniReleaseBooleanArrayElements(JNIEnv *env,
+            jbooleanArray array,
+            jboolean *elems,
+            jint mode);
+extern void CVMjniReleaseByteArrayElements(JNIEnv *env,
+         jbyteArray array,
+         jbyte *elems,
+         jint mode);
+extern void CVMjniReleaseCharArrayElements(JNIEnv *env,
+         jcharArray array,
+         jchar *elems,
+         jint mode);
+extern void CVMjniReleaseShortArrayElements(JNIEnv *env,
+          jshortArray array,
+          jshort *elems,
+          jint mode);
+extern void CVMjniReleaseIntArrayElements(JNIEnv *env,
+        jintArray array,
+        jint *elems,
+        jint mode);
+extern void CVMjniReleaseLongArrayElements(JNIEnv *env,
+         jlongArray array,
+         jlong *elems,
+         jint mode);
+extern void CVMjniReleaseFloatArrayElements(JNIEnv *env,
+          jfloatArray array,
+          jfloat *elems,
+          jint mode);
+extern void CVMjniReleaseDoubleArrayElements(JNIEnv *env,
+           jdoubleArray array,
+           jdouble *elems,
+           jint mode);
+extern void CVMjniGetBooleanArrayRegion(JNIEnv *env,
+      jbooleanArray array,
+      jsize start, jsize len,
+      jboolean *buf);
+extern void CVMjniGetByteArrayRegion(JNIEnv *env,
+          jbyteArray array,
+          jsize start, jsize len,
+          jbyte *buf);
+extern void CVMjniGetCharArrayRegion(JNIEnv *env,
+          jcharArray array,
+          jsize start, jsize len,
+          jchar *buf);
+extern void CVMjniGetShortArrayRegion(JNIEnv *env,
+           jshortArray array,
+           jsize start, jsize len,
+           jshort *buf);
+extern void CVMjniGetIntArrayRegion(JNIEnv *env,
+         jintArray array,
+         jsize start, jsize len,
+         jint *buf);
+extern void CVMjniGetLongArrayRegion(JNIEnv *env,
+          jlongArray array,
+          jsize start, jsize len,
+          jlong *buf);
+extern void CVMjniGetFloatArrayRegion(JNIEnv *env,
+           jfloatArray array,
+           jsize start, jsize len,
+           jfloat *buf);
+extern void CVMjniGetDoubleArrayRegion(JNIEnv *env,
+            jdoubleArray array,
+            jsize start, jsize len,
+            jdouble *buf);
+extern void CVMjniSetBooleanArrayRegion(JNIEnv *env,
+      jbooleanArray array,
+      jsize start, jsize len,
+      const jboolean *buf);
+extern void CVMjniSetByteArrayRegion(JNIEnv *env,
+          jbyteArray array,
+          jsize start, jsize len,
+          const jbyte *buf);
+extern void CVMjniSetCharArrayRegion(JNIEnv *env,
+          jcharArray array,
+          jsize start, jsize len,
+          const jchar *buf);
+extern void CVMjniSetShortArrayRegion(JNIEnv *env,
+           jshortArray array,
+           jsize start, jsize len,
+           const jshort *buf);
+extern void CVMjniSetIntArrayRegion(JNIEnv *env,
+         jintArray array,
+         jsize start, jsize len,
+         const jint *buf);
+extern void CVMjniSetLongArrayRegion(JNIEnv *env,
+          jlongArray array,
+          jsize start, jsize len,
+          const jlong *buf);
+extern void CVMjniSetFloatArrayRegion(JNIEnv *env,
+           jfloatArray array,
+           jsize start, jsize len,
+           const jfloat *buf);
+extern void CVMjniSetDoubleArrayRegion(JNIEnv *env,
+            jdoubleArray array,
+            jsize start, jsize len,
+            const jdouble *buf);
+extern jint CVMjniRegisterNatives(JNIEnv *env, jclass clazz,
+       const JNINativeMethod *methods,
+       jint nMethods);
+extern jint CVMjniUnregisterNatives(JNIEnv *env, jclass clazz);
+extern jint CVMjniMonitorEnter(JNIEnv *env, jobject obj);
+extern jint CVMjniMonitorExit(JNIEnv *env, jobject obj);
+extern jint CVMjniGetJavaVM(JNIEnv *env, JavaVM **p_jvm);
+extern void CVMjniGetStringRegion(JNIEnv *env,
+       jstring string, jsize start,
+       jsize len, jchar *buf);
+extern void CVMjniGetStringUTFRegion(JNIEnv *env,
+          jstring string, jsize start,
+          jsize len, char *buf);
+extern void* CVMjniGetPrimitiveArrayCritical(JNIEnv *env,
+           jarray array,
+           jboolean *isCopy);
+extern void CVMjniReleasePrimitiveArrayCritical(JNIEnv *env,
+       jarray array,
+       void* buf, jint mode);
+extern const jchar* CVMjniGetStringCritical(JNIEnv *env,
+          jstring string,
+          jboolean *isCopy);
+extern void CVMjniReleaseStringCritical(JNIEnv *env, jstring str,
+      const jchar *chars);
+extern jboolean CVMjniExceptionCheck(JNIEnv *env);
+extern jobject
+CVMjniNewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity);
+extern void*
+CVMjniGetDirectBufferAddress(JNIEnv *env, jobject buf);
+extern jlong
+CVMjniGetDirectBufferCapacity(JNIEnv *env, jobject buf);
+extern CVMBool CVMthreadCreate(CVMThreadID *thread,
+    CVMSize stackSize, CVMInt32 priority,
+    void (*func)(void *), void *arg);
+extern void CVMthreadYield(void);
+extern void CVMthreadSetPriority(CVMThreadID *thread, CVMInt32 prio);
+extern void CVMthreadSuspend(CVMThreadID *thread);
+extern void CVMthreadResume(CVMThreadID *thread);
+extern CVMBool CVMthreadAttach(CVMThreadID *self, CVMBool orphan);
+extern void CVMthreadDetach(CVMThreadID *self);
+extern CVMThreadID * CVMthreadSelf(void);
+extern void CVMthreadInterruptWait(CVMThreadID *thread);
+extern CVMBool CVMthreadIsInterrupted(CVMThreadID *thread,
+    CVMBool clearInterrupted);
+extern CVMBool CVMthreadStackCheck(CVMThreadID *self, CVMUint32 redZone);
+extern CVMBool POSIXthreadInitStaticState();
+extern void POSIXthreadDestroyStaticState();
+extern CVMBool POSIXthreadCreate(CVMThreadID *tid,
+    CVMSize stackSize, CVMInt32 priority,
+    void (*func)(void *), void *arg);
+extern CVMThreadID * POSIXthreadGetSelf();
+extern CVMBool POSIXthreadAttach(CVMThreadID *self, CVMBool orphan);
+extern void POSIXthreadDetach(CVMThreadID *self);
+extern void POSIXthreadSetPriority(CVMThreadID *t, CVMInt32 priority);
+extern void POSIXthreadGetPriority(CVMThreadID *t, CVMInt32 *priority);
+typedef struct CVMThreadArchData {
+    int dummy;
+} CVMThreadArchData;
+struct __jmp_buf_tag
+  {
+    __jmp_buf __jmpbuf;
+    int __mask_was_saved;
+    __sigset_t __saved_mask;
+  };
+typedef struct __jmp_buf_tag jmp_buf[1];
+extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));
+extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));
+extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
+extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+typedef struct __jmp_buf_tag sigjmp_buf[1];
+extern void siglongjmp (sigjmp_buf __env, int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+struct CVMThreadID {
+    pthread_t pthreadCookie;
+    void *stackTop;
+    POSIXMutex locked;
+    volatile CVMBool isSuspended;
+    volatile CVMBool isInSuspendHandler;
+    volatile CVMBool isMutexBlocked;
+    volatile CVMBool isWaitBlocked;
+    CVMBool interrupted;
+    CVMBool notified;
+    pthread_mutex_t wait_mutex;
+    pthread_cond_t wait_cv;
+    int value;
+    int fd;
+    CVMThreadArchData archData;
+    CVMThreadID *next;
+    CVMThreadID **prev_p;
+};
+extern void linuxCaptureInitialStack();
+enum {
+    JVMTI_VERSION_1 = 0x30010000,
+    JVMTI_VERSION_1_0 = 0x30010000,
+    JVMTI_VERSION_1_1 = 0x30010100,
+    JVMTI_VERSION = 0x30000000 + (1 * 0x10000) + (1 * 0x100) + 102
+};
+extern jint
+Agent_OnLoad(JavaVM *vm, char *options, void *reserved);
+extern jint
+Agent_OnAttach(JavaVM* vm, char* options, void* reserved);
+extern void
+Agent_OnUnload(JavaVM *vm);
+struct _jvmtiEnv;
+struct jvmtiInterface_1_;
+typedef const struct jvmtiInterface_1_ *jvmtiEnv;
+typedef jobject jthread;
+typedef jobject jthreadGroup;
+typedef jlong jlocation;
+struct _jrawMonitorID;
+typedef struct _jrawMonitorID *jrawMonitorID;
+typedef struct JNINativeInterface jniNativeInterface;
+enum {
+    JVMTI_THREAD_STATE_ALIVE = 0x0001,
+    JVMTI_THREAD_STATE_TERMINATED = 0x0002,
+    JVMTI_THREAD_STATE_RUNNABLE = 0x0004,
+    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400,
+    JVMTI_THREAD_STATE_WAITING = 0x0080,
+    JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010,
+    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020,
+    JVMTI_THREAD_STATE_SLEEPING = 0x0040,
+    JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100,
+    JVMTI_THREAD_STATE_PARKED = 0x0200,
+    JVMTI_THREAD_STATE_SUSPENDED = 0x100000,
+    JVMTI_THREAD_STATE_INTERRUPTED = 0x200000,
+    JVMTI_THREAD_STATE_IN_NATIVE = 0x400000,
+    JVMTI_THREAD_STATE_VENDOR_1 = 0x10000000,
+    JVMTI_THREAD_STATE_VENDOR_2 = 0x20000000,
+    JVMTI_THREAD_STATE_VENDOR_3 = 0x40000000
+};
+enum {
+    JVMTI_JAVA_LANG_THREAD_STATE_MASK = JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,
+    JVMTI_JAVA_LANG_THREAD_STATE_NEW = 0,
+    JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = JVMTI_THREAD_STATE_TERMINATED,
+    JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE,
+    JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
+    JVMTI_JAVA_LANG_THREAD_STATE_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,
+    JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT
+};
+enum {
+    JVMTI_THREAD_MIN_PRIORITY = 1,
+    JVMTI_THREAD_NORM_PRIORITY = 5,
+    JVMTI_THREAD_MAX_PRIORITY = 10
+};
+enum {
+    JVMTI_HEAP_FILTER_TAGGED = 0x4,
+    JVMTI_HEAP_FILTER_UNTAGGED = 0x8,
+    JVMTI_HEAP_FILTER_CLASS_TAGGED = 0x10,
+    JVMTI_HEAP_FILTER_CLASS_UNTAGGED = 0x20
+};
+enum {
+    JVMTI_VISIT_OBJECTS = 0x100,
+    JVMTI_VISIT_ABORT = 0x8000
+};
+typedef enum {
+    JVMTI_HEAP_REFERENCE_CLASS = 1,
+    JVMTI_HEAP_REFERENCE_FIELD = 2,
+    JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
+    JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
+    JVMTI_HEAP_REFERENCE_SIGNERS = 5,
+    JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
+    JVMTI_HEAP_REFERENCE_INTERFACE = 7,
+    JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
+    JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
+    JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
+    JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
+    JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
+    JVMTI_HEAP_REFERENCE_MONITOR = 23,
+    JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
+    JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
+    JVMTI_HEAP_REFERENCE_THREAD = 26,
+    JVMTI_HEAP_REFERENCE_OTHER = 27
+} jvmtiHeapReferenceKind;
+typedef enum {
+    JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90,
+    JVMTI_PRIMITIVE_TYPE_BYTE = 66,
+    JVMTI_PRIMITIVE_TYPE_CHAR = 67,
+    JVMTI_PRIMITIVE_TYPE_SHORT = 83,
+    JVMTI_PRIMITIVE_TYPE_INT = 73,
+    JVMTI_PRIMITIVE_TYPE_LONG = 74,
+    JVMTI_PRIMITIVE_TYPE_FLOAT = 70,
+    JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
+} jvmtiPrimitiveType;
+typedef enum {
+    JVMTI_HEAP_OBJECT_TAGGED = 1,
+    JVMTI_HEAP_OBJECT_UNTAGGED = 2,
+    JVMTI_HEAP_OBJECT_EITHER = 3
+} jvmtiHeapObjectFilter;
+typedef enum {
+    JVMTI_HEAP_ROOT_JNI_GLOBAL = 1,
+    JVMTI_HEAP_ROOT_SYSTEM_CLASS = 2,
+    JVMTI_HEAP_ROOT_MONITOR = 3,
+    JVMTI_HEAP_ROOT_STACK_LOCAL = 4,
+    JVMTI_HEAP_ROOT_JNI_LOCAL = 5,
+    JVMTI_HEAP_ROOT_THREAD = 6,
+    JVMTI_HEAP_ROOT_OTHER = 7
+} jvmtiHeapRootKind;
+typedef enum {
+    JVMTI_REFERENCE_CLASS = 1,
+    JVMTI_REFERENCE_FIELD = 2,
+    JVMTI_REFERENCE_ARRAY_ELEMENT = 3,
+    JVMTI_REFERENCE_CLASS_LOADER = 4,
+    JVMTI_REFERENCE_SIGNERS = 5,
+    JVMTI_REFERENCE_PROTECTION_DOMAIN = 6,
+    JVMTI_REFERENCE_INTERFACE = 7,
+    JVMTI_REFERENCE_STATIC_FIELD = 8,
+    JVMTI_REFERENCE_CONSTANT_POOL = 9
+} jvmtiObjectReferenceKind;
+typedef enum {
+    JVMTI_ITERATION_CONTINUE = 1,
+    JVMTI_ITERATION_IGNORE = 2,
+    JVMTI_ITERATION_ABORT = 0
+} jvmtiIterationControl;
+enum {
+    JVMTI_CLASS_STATUS_VERIFIED = 1,
+    JVMTI_CLASS_STATUS_PREPARED = 2,
+    JVMTI_CLASS_STATUS_INITIALIZED = 4,
+    JVMTI_CLASS_STATUS_ERROR = 8,
+    JVMTI_CLASS_STATUS_ARRAY = 16,
+    JVMTI_CLASS_STATUS_PRIMITIVE = 32
+};
+typedef enum {
+    JVMTI_ENABLE = 1,
+    JVMTI_DISABLE = 0
+} jvmtiEventMode;
+typedef enum {
+    JVMTI_TYPE_JBYTE = 101,
+    JVMTI_TYPE_JCHAR = 102,
+    JVMTI_TYPE_JSHORT = 103,
+    JVMTI_TYPE_JINT = 104,
+    JVMTI_TYPE_JLONG = 105,
+    JVMTI_TYPE_JFLOAT = 106,
+    JVMTI_TYPE_JDOUBLE = 107,
+    JVMTI_TYPE_JBOOLEAN = 108,
+    JVMTI_TYPE_JOBJECT = 109,
+    JVMTI_TYPE_JTHREAD = 110,
+    JVMTI_TYPE_JCLASS = 111,
+    JVMTI_TYPE_JVALUE = 112,
+    JVMTI_TYPE_JFIELDID = 113,
+    JVMTI_TYPE_JMETHODID = 114,
+    JVMTI_TYPE_CCHAR = 115,
+    JVMTI_TYPE_CVOID = 116,
+    JVMTI_TYPE_JNIENV = 117
+} jvmtiParamTypes;
+typedef enum {
+    JVMTI_KIND_IN = 91,
+    JVMTI_KIND_IN_PTR = 92,
+    JVMTI_KIND_IN_BUF = 93,
+    JVMTI_KIND_ALLOC_BUF = 94,
+    JVMTI_KIND_ALLOC_ALLOC_BUF = 95,
+    JVMTI_KIND_OUT = 96,
+    JVMTI_KIND_OUT_BUF = 97
+} jvmtiParamKind;
+typedef enum {
+    JVMTI_TIMER_USER_CPU = 30,
+    JVMTI_TIMER_TOTAL_CPU = 31,
+    JVMTI_TIMER_ELAPSED = 32
+} jvmtiTimerKind;
+typedef enum {
+    JVMTI_PHASE_ONLOAD = 1,
+    JVMTI_PHASE_PRIMORDIAL = 2,
+    JVMTI_PHASE_START = 6,
+    JVMTI_PHASE_LIVE = 4,
+    JVMTI_PHASE_DEAD = 8
+} jvmtiPhase;
+enum {
+    JVMTI_VERSION_INTERFACE_JNI = 0x00000000,
+    JVMTI_VERSION_INTERFACE_JVMTI = 0x30000000
+};
+enum {
+    JVMTI_VERSION_MASK_INTERFACE_TYPE = 0x70000000,
+    JVMTI_VERSION_MASK_MAJOR = 0x0FFF0000,
+    JVMTI_VERSION_MASK_MINOR = 0x0000FF00,
+    JVMTI_VERSION_MASK_MICRO = 0x000000FF
+};
+enum {
+    JVMTI_VERSION_SHIFT_MAJOR = 16,
+    JVMTI_VERSION_SHIFT_MINOR = 8,
+    JVMTI_VERSION_SHIFT_MICRO = 0
+};
+typedef enum {
+    JVMTI_VERBOSE_OTHER = 0,
+    JVMTI_VERBOSE_GC = 1,
+    JVMTI_VERBOSE_CLASS = 2,
+    JVMTI_VERBOSE_JNI = 4
+} jvmtiVerboseFlag;
+typedef enum {
+    JVMTI_JLOCATION_JVMBCI = 1,
+    JVMTI_JLOCATION_MACHINEPC = 2,
+    JVMTI_JLOCATION_OTHER = 0
+} jvmtiJlocationFormat;
+enum {
+    JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = 0x0001,
+    JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = 0x0002,
+    JVMTI_RESOURCE_EXHAUSTED_THREADS = 0x0004
+};
+typedef enum {
+    JVMTI_ERROR_NONE = 0,
+    JVMTI_ERROR_INVALID_THREAD = 10,
+    JVMTI_ERROR_INVALID_THREAD_GROUP = 11,
+    JVMTI_ERROR_INVALID_PRIORITY = 12,
+    JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13,
+    JVMTI_ERROR_THREAD_SUSPENDED = 14,
+    JVMTI_ERROR_THREAD_NOT_ALIVE = 15,
+    JVMTI_ERROR_INVALID_OBJECT = 20,
+    JVMTI_ERROR_INVALID_CLASS = 21,
+    JVMTI_ERROR_CLASS_NOT_PREPARED = 22,
+    JVMTI_ERROR_INVALID_METHODID = 23,
+    JVMTI_ERROR_INVALID_LOCATION = 24,
+    JVMTI_ERROR_INVALID_FIELDID = 25,
+    JVMTI_ERROR_NO_MORE_FRAMES = 31,
+    JVMTI_ERROR_OPAQUE_FRAME = 32,
+    JVMTI_ERROR_TYPE_MISMATCH = 34,
+    JVMTI_ERROR_INVALID_SLOT = 35,
+    JVMTI_ERROR_DUPLICATE = 40,
+    JVMTI_ERROR_NOT_FOUND = 41,
+    JVMTI_ERROR_INVALID_MONITOR = 50,
+    JVMTI_ERROR_NOT_MONITOR_OWNER = 51,
+    JVMTI_ERROR_INTERRUPT = 52,
+    JVMTI_ERROR_INVALID_CLASS_FORMAT = 60,
+    JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61,
+    JVMTI_ERROR_FAILS_VERIFICATION = 62,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64,
+    JVMTI_ERROR_INVALID_TYPESTATE = 65,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67,
+    JVMTI_ERROR_UNSUPPORTED_VERSION = 68,
+    JVMTI_ERROR_NAMES_DONT_MATCH = 69,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71,
+    JVMTI_ERROR_UNMODIFIABLE_CLASS = 79,
+    JVMTI_ERROR_NOT_AVAILABLE = 98,
+    JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99,
+    JVMTI_ERROR_NULL_POINTER = 100,
+    JVMTI_ERROR_ABSENT_INFORMATION = 101,
+    JVMTI_ERROR_INVALID_EVENT_TYPE = 102,
+    JVMTI_ERROR_ILLEGAL_ARGUMENT = 103,
+    JVMTI_ERROR_NATIVE_METHOD = 104,
+    JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106,
+    JVMTI_ERROR_OUT_OF_MEMORY = 110,
+    JVMTI_ERROR_ACCESS_DENIED = 111,
+    JVMTI_ERROR_WRONG_PHASE = 112,
+    JVMTI_ERROR_INTERNAL = 113,
+    JVMTI_ERROR_UNATTACHED_THREAD = 115,
+    JVMTI_ERROR_INVALID_ENVIRONMENT = 116,
+    JVMTI_ERROR_MAX = 116
+} jvmtiError;
+typedef enum {
+    JVMTI_MIN_EVENT_TYPE_VAL = 50,
+    JVMTI_EVENT_VM_INIT = 50,
+    JVMTI_EVENT_VM_DEATH = 51,
+    JVMTI_EVENT_THREAD_START = 52,
+    JVMTI_EVENT_THREAD_END = 53,
+    JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = 54,
+    JVMTI_EVENT_CLASS_LOAD = 55,
+    JVMTI_EVENT_CLASS_PREPARE = 56,
+    JVMTI_EVENT_VM_START = 57,
+    JVMTI_EVENT_EXCEPTION = 58,
+    JVMTI_EVENT_EXCEPTION_CATCH = 59,
+    JVMTI_EVENT_SINGLE_STEP = 60,
+    JVMTI_EVENT_FRAME_POP = 61,
+    JVMTI_EVENT_BREAKPOINT = 62,
+    JVMTI_EVENT_FIELD_ACCESS = 63,
+    JVMTI_EVENT_FIELD_MODIFICATION = 64,
+    JVMTI_EVENT_METHOD_ENTRY = 65,
+    JVMTI_EVENT_METHOD_EXIT = 66,
+    JVMTI_EVENT_NATIVE_METHOD_BIND = 67,
+    JVMTI_EVENT_COMPILED_METHOD_LOAD = 68,
+    JVMTI_EVENT_COMPILED_METHOD_UNLOAD = 69,
+    JVMTI_EVENT_DYNAMIC_CODE_GENERATED = 70,
+    JVMTI_EVENT_DATA_DUMP_REQUEST = 71,
+    JVMTI_EVENT_MONITOR_WAIT = 73,
+    JVMTI_EVENT_MONITOR_WAITED = 74,
+    JVMTI_EVENT_MONITOR_CONTENDED_ENTER = 75,
+    JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = 76,
+    JVMTI_EVENT_RESOURCE_EXHAUSTED = 80,
+    JVMTI_EVENT_GARBAGE_COLLECTION_START = 81,
+    JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = 82,
+    JVMTI_EVENT_OBJECT_FREE = 83,
+    JVMTI_EVENT_VM_OBJECT_ALLOC = 84,
+    JVMTI_MAX_EVENT_TYPE_VAL = 84
+} jvmtiEvent;
+struct _jvmtiThreadInfo;
+typedef struct _jvmtiThreadInfo jvmtiThreadInfo;
+struct _jvmtiMonitorStackDepthInfo;
+typedef struct _jvmtiMonitorStackDepthInfo jvmtiMonitorStackDepthInfo;
+struct _jvmtiThreadGroupInfo;
+typedef struct _jvmtiThreadGroupInfo jvmtiThreadGroupInfo;
+struct _jvmtiFrameInfo;
+typedef struct _jvmtiFrameInfo jvmtiFrameInfo;
+struct _jvmtiStackInfo;
+typedef struct _jvmtiStackInfo jvmtiStackInfo;
+struct _jvmtiHeapReferenceInfoField;
+typedef struct _jvmtiHeapReferenceInfoField jvmtiHeapReferenceInfoField;
+struct _jvmtiHeapReferenceInfoArray;
+typedef struct _jvmtiHeapReferenceInfoArray jvmtiHeapReferenceInfoArray;
+struct _jvmtiHeapReferenceInfoConstantPool;
+typedef struct _jvmtiHeapReferenceInfoConstantPool jvmtiHeapReferenceInfoConstantPool;
+struct _jvmtiHeapReferenceInfoStackLocal;
+typedef struct _jvmtiHeapReferenceInfoStackLocal jvmtiHeapReferenceInfoStackLocal;
+struct _jvmtiHeapReferenceInfoJniLocal;
+typedef struct _jvmtiHeapReferenceInfoJniLocal jvmtiHeapReferenceInfoJniLocal;
+struct _jvmtiHeapReferenceInfoReserved;
+typedef struct _jvmtiHeapReferenceInfoReserved jvmtiHeapReferenceInfoReserved;
+union _jvmtiHeapReferenceInfo;
+typedef union _jvmtiHeapReferenceInfo jvmtiHeapReferenceInfo;
+struct _jvmtiHeapCallbacks;
+typedef struct _jvmtiHeapCallbacks jvmtiHeapCallbacks;
+struct _jvmtiClassDefinition;
+typedef struct _jvmtiClassDefinition jvmtiClassDefinition;
+struct _jvmtiMonitorUsage;
+typedef struct _jvmtiMonitorUsage jvmtiMonitorUsage;
+struct _jvmtiLineNumberEntry;
+typedef struct _jvmtiLineNumberEntry jvmtiLineNumberEntry;
+struct _jvmtiLocalVariableEntry;
+typedef struct _jvmtiLocalVariableEntry jvmtiLocalVariableEntry;
+struct _jvmtiParamInfo;
+typedef struct _jvmtiParamInfo jvmtiParamInfo;
+struct _jvmtiExtensionFunctionInfo;
+typedef struct _jvmtiExtensionFunctionInfo jvmtiExtensionFunctionInfo;
+struct _jvmtiExtensionEventInfo;
+typedef struct _jvmtiExtensionEventInfo jvmtiExtensionEventInfo;
+struct _jvmtiTimerInfo;
+typedef struct _jvmtiTimerInfo jvmtiTimerInfo;
+struct _jvmtiAddrLocationMap;
+typedef struct _jvmtiAddrLocationMap jvmtiAddrLocationMap;
+typedef void ( *jvmtiStartFunction)
+    (jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg);
+typedef jint ( *jvmtiHeapIterationCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data);
+typedef jint ( *jvmtiHeapReferenceCallback)
+    (jvmtiHeapReferenceKind reference_kind, const jvmtiHeapReferenceInfo* reference_info, jlong class_tag, jlong referrer_class_tag, jlong size, jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data);
+typedef jint ( *jvmtiPrimitiveFieldCallback)
+    (jvmtiHeapReferenceKind kind, const jvmtiHeapReferenceInfo* info, jlong object_class_tag, jlong* object_tag_ptr, jvalue value, jvmtiPrimitiveType value_type, void* user_data);
+typedef jint ( *jvmtiArrayPrimitiveValueCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, jint element_count, jvmtiPrimitiveType element_type, const void* elements, void* user_data);
+typedef jint ( *jvmtiStringPrimitiveValueCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, const jchar* value, jint value_length, void* user_data);
+typedef jint ( *jvmtiReservedCallback)
+    ();
+typedef jvmtiIterationControl ( *jvmtiHeapObjectCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiHeapRootCallback)
+    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiStackReferenceCallback)
+    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong thread_tag, jint depth, jmethodID method, jint slot, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiObjectReferenceCallback)
+    (jvmtiObjectReferenceKind reference_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong referrer_tag, jint referrer_index, void* user_data);
+typedef jvmtiError ( *jvmtiExtensionFunction)
+    (jvmtiEnv* jvmti_env, ...);
+typedef void ( *jvmtiExtensionEvent)
+    (jvmtiEnv* jvmti_env, ...);
+struct _jvmtiThreadInfo {
+    char* name;
+    jint priority;
+    jboolean is_daemon;
+    jthreadGroup thread_group;
+    jobject context_class_loader;
+};
+struct _jvmtiMonitorStackDepthInfo {
+    jobject monitor;
+    jint stack_depth;
+};
+struct _jvmtiThreadGroupInfo {
+    jthreadGroup parent;
+    char* name;
+    jint max_priority;
+    jboolean is_daemon;
+};
+struct _jvmtiFrameInfo {
+    jmethodID method;
+    jlocation location;
+};
+struct _jvmtiStackInfo {
+    jthread thread;
+    jint state;
+    jvmtiFrameInfo* frame_buffer;
+    jint frame_count;
+};
+struct _jvmtiHeapReferenceInfoField {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoArray {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoConstantPool {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoStackLocal {
+    jlong thread_tag;
+    jlong thread_id;
+    jint depth;
+    jmethodID method;
+    jlocation location;
+    jint slot;
+};
+struct _jvmtiHeapReferenceInfoJniLocal {
+    jlong thread_tag;
+    jlong thread_id;
+    jint depth;
+    jmethodID method;
+};
+struct _jvmtiHeapReferenceInfoReserved {
+    jlong reserved1;
+    jlong reserved2;
+    jlong reserved3;
+    jlong reserved4;
+    jlong reserved5;
+    jlong reserved6;
+    jlong reserved7;
+    jlong reserved8;
+};
+union _jvmtiHeapReferenceInfo {
+    jvmtiHeapReferenceInfoField field;
+    jvmtiHeapReferenceInfoArray array;
+    jvmtiHeapReferenceInfoConstantPool constant_pool;
+    jvmtiHeapReferenceInfoStackLocal stack_local;
+    jvmtiHeapReferenceInfoJniLocal jni_local;
+    jvmtiHeapReferenceInfoReserved other;
+};
+struct _jvmtiHeapCallbacks {
+    jvmtiHeapIterationCallback heap_iteration_callback;
+    jvmtiHeapReferenceCallback heap_reference_callback;
+    jvmtiPrimitiveFieldCallback primitive_field_callback;
+    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
+    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
+    jvmtiReservedCallback reserved5;
+    jvmtiReservedCallback reserved6;
+    jvmtiReservedCallback reserved7;
+    jvmtiReservedCallback reserved8;
+    jvmtiReservedCallback reserved9;
+    jvmtiReservedCallback reserved10;
+    jvmtiReservedCallback reserved11;
+    jvmtiReservedCallback reserved12;
+    jvmtiReservedCallback reserved13;
+    jvmtiReservedCallback reserved14;
+    jvmtiReservedCallback reserved15;
+};
+struct _jvmtiClassDefinition {
+    jclass klass;
+    jint class_byte_count;
+    const unsigned char* class_bytes;
+};
+struct _jvmtiMonitorUsage {
+    jthread owner;
+    jint entry_count;
+    jint waiter_count;
+    jthread* waiters;
+    jint notify_waiter_count;
+    jthread* notify_waiters;
+};
+struct _jvmtiLineNumberEntry {
+    jlocation start_location;
+    jint line_number;
+};
+struct _jvmtiLocalVariableEntry {
+    jlocation start_location;
+    jint length;
+    char* name;
+    char* signature;
+    char* generic_signature;
+    jint slot;
+};
+struct _jvmtiParamInfo {
+    char* name;
+    jvmtiParamKind kind;
+    jvmtiParamTypes base_type;
+    jboolean null_ok;
+};
+struct _jvmtiExtensionFunctionInfo {
+    jvmtiExtensionFunction func;
+    char* id;
+    char* short_description;
+    jint param_count;
+    jvmtiParamInfo* params;
+    jint error_count;
+    jvmtiError* errors;
+};
+struct _jvmtiExtensionEventInfo {
+    jint extension_event_index;
+    char* id;
+    char* short_description;
+    jint param_count;
+    jvmtiParamInfo* params;
+};
+struct _jvmtiTimerInfo {
+    jlong max_value;
+    jboolean may_skip_forward;
+    jboolean may_skip_backward;
+    jvmtiTimerKind kind;
+    jlong reserved1;
+    jlong reserved2;
+};
+struct _jvmtiAddrLocationMap {
+    const void* start_address;
+    jlocation location;
+};
+typedef struct {
+    unsigned int can_tag_objects : 1;
+    unsigned int can_generate_field_modification_events : 1;
+    unsigned int can_generate_field_access_events : 1;
+    unsigned int can_get_bytecodes : 1;
+    unsigned int can_get_synthetic_attribute : 1;
+    unsigned int can_get_owned_monitor_info : 1;
+    unsigned int can_get_current_contended_monitor : 1;
+    unsigned int can_get_monitor_info : 1;
+    unsigned int can_pop_frame : 1;
+    unsigned int can_redefine_classes : 1;
+    unsigned int can_signal_thread : 1;
+    unsigned int can_get_source_file_name : 1;
+    unsigned int can_get_line_numbers : 1;
+    unsigned int can_get_source_debug_extension : 1;
+    unsigned int can_access_local_variables : 1;
+    unsigned int can_maintain_original_method_order : 1;
+    unsigned int can_generate_single_step_events : 1;
+    unsigned int can_generate_exception_events : 1;
+    unsigned int can_generate_frame_pop_events : 1;
+    unsigned int can_generate_breakpoint_events : 1;
+    unsigned int can_suspend : 1;
+    unsigned int can_redefine_any_class : 1;
+    unsigned int can_get_current_thread_cpu_time : 1;
+    unsigned int can_get_thread_cpu_time : 1;
+    unsigned int can_generate_method_entry_events : 1;
+    unsigned int can_generate_method_exit_events : 1;
+    unsigned int can_generate_all_class_hook_events : 1;
+    unsigned int can_generate_compiled_method_load_events : 1;
+    unsigned int can_generate_monitor_events : 1;
+    unsigned int can_generate_vm_object_alloc_events : 1;
+    unsigned int can_generate_native_method_bind_events : 1;
+    unsigned int can_generate_garbage_collection_events : 1;
+    unsigned int can_generate_object_free_events : 1;
+    unsigned int can_force_early_return : 1;
+    unsigned int can_get_owned_monitor_stack_depth_info : 1;
+    unsigned int can_get_constant_pool : 1;
+    unsigned int can_set_native_method_prefix : 1;
+    unsigned int can_retransform_classes : 1;
+    unsigned int can_retransform_any_class : 1;
+    unsigned int can_generate_resource_exhaustion_heap_events : 1;
+    unsigned int can_generate_resource_exhaustion_threads_events : 1;
+    unsigned int : 7;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+} jvmtiCapabilities;
+typedef void ( *jvmtiEventReserved)(void);
+typedef void ( *jvmtiEventBreakpoint)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location);
+typedef void ( *jvmtiEventClassFileLoadHook)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jclass class_being_redefined,
+     jobject loader,
+     const char* name,
+     jobject protection_domain,
+     jint class_data_len,
+     const unsigned char* class_data,
+     jint* new_class_data_len,
+     unsigned char** new_class_data);
+typedef void ( *jvmtiEventClassLoad)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jclass klass);
+typedef void ( *jvmtiEventClassPrepare)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jclass klass);
+typedef void ( *jvmtiEventCompiledMethodLoad)
+    (jvmtiEnv *jvmti_env,
+     jmethodID method,
+     jint code_size,
+     const void* code_addr,
+     jint map_length,
+     const jvmtiAddrLocationMap* map,
+     const void* compile_info);
+typedef void ( *jvmtiEventCompiledMethodUnload)
+    (jvmtiEnv *jvmti_env,
+     jmethodID method,
+     const void* code_addr);
+typedef void ( *jvmtiEventDataDumpRequest)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventDynamicCodeGenerated)
+    (jvmtiEnv *jvmti_env,
+     const char* name,
+     const void* address,
+     jint length);
+typedef void ( *jvmtiEventException)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jobject exception,
+     jmethodID catch_method,
+     jlocation catch_location);
+typedef void ( *jvmtiEventExceptionCatch)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jobject exception);
+typedef void ( *jvmtiEventFieldAccess)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jclass field_klass,
+     jobject object,
+     jfieldID field);
+typedef void ( *jvmtiEventFieldModification)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jclass field_klass,
+     jobject object,
+     jfieldID field,
+     char signature_type,
+     jvalue new_value);
+typedef void ( *jvmtiEventFramePop)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jboolean was_popped_by_exception);
+typedef void ( *jvmtiEventGarbageCollectionFinish)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventGarbageCollectionStart)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventMethodEntry)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method);
+typedef void ( *jvmtiEventMethodExit)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jboolean was_popped_by_exception,
+     jvalue return_value);
+typedef void ( *jvmtiEventMonitorContendedEnter)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object);
+typedef void ( *jvmtiEventMonitorContendedEntered)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object);
+typedef void ( *jvmtiEventMonitorWait)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jlong timeout);
+typedef void ( *jvmtiEventMonitorWaited)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jboolean timed_out);
+typedef void ( *jvmtiEventNativeMethodBind)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     void* address,
+     void** new_address_ptr);
+typedef void ( *jvmtiEventObjectFree)
+    (jvmtiEnv *jvmti_env,
+     jlong tag);
+typedef void ( *jvmtiEventResourceExhausted)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jint flags,
+     const void* reserved,
+     const char* description);
+typedef void ( *jvmtiEventSingleStep)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location);
+typedef void ( *jvmtiEventThreadEnd)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventThreadStart)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventVMDeath)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env);
+typedef void ( *jvmtiEventVMInit)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventVMObjectAlloc)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jclass object_klass,
+     jlong size);
+typedef void ( *jvmtiEventVMStart)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env);
+typedef struct {
+    jvmtiEventVMInit VMInit;
+    jvmtiEventVMDeath VMDeath;
+    jvmtiEventThreadStart ThreadStart;
+    jvmtiEventThreadEnd ThreadEnd;
+    jvmtiEventClassFileLoadHook ClassFileLoadHook;
+    jvmtiEventClassLoad ClassLoad;
+    jvmtiEventClassPrepare ClassPrepare;
+    jvmtiEventVMStart VMStart;
+    jvmtiEventException Exception;
+    jvmtiEventExceptionCatch ExceptionCatch;
+    jvmtiEventSingleStep SingleStep;
+    jvmtiEventFramePop FramePop;
+    jvmtiEventBreakpoint Breakpoint;
+    jvmtiEventFieldAccess FieldAccess;
+    jvmtiEventFieldModification FieldModification;
+    jvmtiEventMethodEntry MethodEntry;
+    jvmtiEventMethodExit MethodExit;
+    jvmtiEventNativeMethodBind NativeMethodBind;
+    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
+    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
+    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
+    jvmtiEventDataDumpRequest DataDumpRequest;
+    jvmtiEventReserved reserved72;
+    jvmtiEventMonitorWait MonitorWait;
+    jvmtiEventMonitorWaited MonitorWaited;
+    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
+    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
+    jvmtiEventReserved reserved77;
+    jvmtiEventReserved reserved78;
+    jvmtiEventReserved reserved79;
+    jvmtiEventResourceExhausted ResourceExhausted;
+    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
+    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
+    jvmtiEventObjectFree ObjectFree;
+    jvmtiEventVMObjectAlloc VMObjectAlloc;
+} jvmtiEventCallbacks;
+typedef struct jvmtiInterface_1_ {
+  void *reserved1;
+  jvmtiError ( *SetEventNotificationMode) (jvmtiEnv* env,
+    jvmtiEventMode mode,
+    jvmtiEvent event_type,
+    jthread event_thread,
+     ...);
+  void *reserved3;
+  jvmtiError ( *GetAllThreads) (jvmtiEnv* env,
+    jint* threads_count_ptr,
+    jthread** threads_ptr);
+  jvmtiError ( *SuspendThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *ResumeThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *StopThread) (jvmtiEnv* env,
+    jthread thread,
+    jobject exception);
+  jvmtiError ( *InterruptThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *GetThreadInfo) (jvmtiEnv* env,
+    jthread thread,
+    jvmtiThreadInfo* info_ptr);
+  jvmtiError ( *GetOwnedMonitorInfo) (jvmtiEnv* env,
+    jthread thread,
+    jint* owned_monitor_count_ptr,
+    jobject** owned_monitors_ptr);
+  jvmtiError ( *GetCurrentContendedMonitor) (jvmtiEnv* env,
+    jthread thread,
+    jobject* monitor_ptr);
+  jvmtiError ( *RunAgentThread) (jvmtiEnv* env,
+    jthread thread,
+    jvmtiStartFunction proc,
+    const void* arg,
+    jint priority);
+  jvmtiError ( *GetTopThreadGroups) (jvmtiEnv* env,
+    jint* group_count_ptr,
+    jthreadGroup** groups_ptr);
+  jvmtiError ( *GetThreadGroupInfo) (jvmtiEnv* env,
+    jthreadGroup group,
+    jvmtiThreadGroupInfo* info_ptr);
+  jvmtiError ( *GetThreadGroupChildren) (jvmtiEnv* env,
+    jthreadGroup group,
+    jint* thread_count_ptr,
+    jthread** threads_ptr,
+    jint* group_count_ptr,
+    jthreadGroup** groups_ptr);
+  jvmtiError ( *GetFrameCount) (jvmtiEnv* env,
+    jthread thread,
+    jint* count_ptr);
+  jvmtiError ( *GetThreadState) (jvmtiEnv* env,
+    jthread thread,
+    jint* thread_state_ptr);
+  jvmtiError ( *GetCurrentThread) (jvmtiEnv* env,
+    jthread* thread_ptr);
+  jvmtiError ( *GetFrameLocation) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jmethodID* method_ptr,
+    jlocation* location_ptr);
+  jvmtiError ( *NotifyFramePop) (jvmtiEnv* env,
+    jthread thread,
+    jint depth);
+  jvmtiError ( *GetLocalObject) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jobject* value_ptr);
+  jvmtiError ( *GetLocalInt) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jint* value_ptr);
+  jvmtiError ( *GetLocalLong) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jlong* value_ptr);
+  jvmtiError ( *GetLocalFloat) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jfloat* value_ptr);
+  jvmtiError ( *GetLocalDouble) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jdouble* value_ptr);
+  jvmtiError ( *SetLocalObject) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jobject value);
+  jvmtiError ( *SetLocalInt) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jint value);
+  jvmtiError ( *SetLocalLong) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jlong value);
+  jvmtiError ( *SetLocalFloat) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jfloat value);
+  jvmtiError ( *SetLocalDouble) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jdouble value);
+  jvmtiError ( *CreateRawMonitor) (jvmtiEnv* env,
+    const char* name,
+    jrawMonitorID* monitor_ptr);
+  jvmtiError ( *DestroyRawMonitor) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorEnter) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorExit) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorWait) (jvmtiEnv* env,
+    jrawMonitorID monitor,
+    jlong millis);
+  jvmtiError ( *RawMonitorNotify) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorNotifyAll) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *SetBreakpoint) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation location);
+  jvmtiError ( *ClearBreakpoint) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation location);
+  void *reserved40;
+  jvmtiError ( *SetFieldAccessWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *ClearFieldAccessWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *SetFieldModificationWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *ClearFieldModificationWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *IsModifiableClass) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_modifiable_class_ptr);
+  jvmtiError ( *Allocate) (jvmtiEnv* env,
+    jlong size,
+    unsigned char** mem_ptr);
+  jvmtiError ( *Deallocate) (jvmtiEnv* env,
+    unsigned char* mem);
+  jvmtiError ( *GetClassSignature) (jvmtiEnv* env,
+    jclass klass,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetClassStatus) (jvmtiEnv* env,
+    jclass klass,
+    jint* status_ptr);
+  jvmtiError ( *GetSourceFileName) (jvmtiEnv* env,
+    jclass klass,
+    char** source_name_ptr);
+  jvmtiError ( *GetClassModifiers) (jvmtiEnv* env,
+    jclass klass,
+    jint* modifiers_ptr);
+  jvmtiError ( *GetClassMethods) (jvmtiEnv* env,
+    jclass klass,
+    jint* method_count_ptr,
+    jmethodID** methods_ptr);
+  jvmtiError ( *GetClassFields) (jvmtiEnv* env,
+    jclass klass,
+    jint* field_count_ptr,
+    jfieldID** fields_ptr);
+  jvmtiError ( *GetImplementedInterfaces) (jvmtiEnv* env,
+    jclass klass,
+    jint* interface_count_ptr,
+    jclass** interfaces_ptr);
+  jvmtiError ( *IsInterface) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_interface_ptr);
+  jvmtiError ( *IsArrayClass) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_array_class_ptr);
+  jvmtiError ( *GetClassLoader) (jvmtiEnv* env,
+    jclass klass,
+    jobject* classloader_ptr);
+  jvmtiError ( *GetObjectHashCode) (jvmtiEnv* env,
+    jobject object,
+    jint* hash_code_ptr);
+  jvmtiError ( *GetObjectMonitorUsage) (jvmtiEnv* env,
+    jobject object,
+    jvmtiMonitorUsage* info_ptr);
+  jvmtiError ( *GetFieldName) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    char** name_ptr,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetFieldDeclaringClass) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jclass* declaring_class_ptr);
+  jvmtiError ( *GetFieldModifiers) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jint* modifiers_ptr);
+  jvmtiError ( *IsFieldSynthetic) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jboolean* is_synthetic_ptr);
+  jvmtiError ( *GetMethodName) (jvmtiEnv* env,
+    jmethodID method,
+    char** name_ptr,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetMethodDeclaringClass) (jvmtiEnv* env,
+    jmethodID method,
+    jclass* declaring_class_ptr);
+  jvmtiError ( *GetMethodModifiers) (jvmtiEnv* env,
+    jmethodID method,
+    jint* modifiers_ptr);
+  void *reserved67;
+  jvmtiError ( *GetMaxLocals) (jvmtiEnv* env,
+    jmethodID method,
+    jint* max_ptr);
+  jvmtiError ( *GetArgumentsSize) (jvmtiEnv* env,
+    jmethodID method,
+    jint* size_ptr);
+  jvmtiError ( *GetLineNumberTable) (jvmtiEnv* env,
+    jmethodID method,
+    jint* entry_count_ptr,
+    jvmtiLineNumberEntry** table_ptr);
+  jvmtiError ( *GetMethodLocation) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation* start_location_ptr,
+    jlocation* end_location_ptr);
+  jvmtiError ( *GetLocalVariableTable) (jvmtiEnv* env,
+    jmethodID method,
+    jint* entry_count_ptr,
+    jvmtiLocalVariableEntry** table_ptr);
+  jvmtiError ( *SetNativeMethodPrefix) (jvmtiEnv* env,
+    const char* prefix);
+  jvmtiError ( *SetNativeMethodPrefixes) (jvmtiEnv* env,
+    jint prefix_count,
+    char** prefixes);
+  jvmtiError ( *GetBytecodes) (jvmtiEnv* env,
+    jmethodID method,
+    jint* bytecode_count_ptr,
+    unsigned char** bytecodes_ptr);
+  jvmtiError ( *IsMethodNative) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_native_ptr);
+  jvmtiError ( *IsMethodSynthetic) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_synthetic_ptr);
+  jvmtiError ( *GetLoadedClasses) (jvmtiEnv* env,
+    jint* class_count_ptr,
+    jclass** classes_ptr);
+  jvmtiError ( *GetClassLoaderClasses) (jvmtiEnv* env,
+    jobject initiating_loader,
+    jint* class_count_ptr,
+    jclass** classes_ptr);
+  jvmtiError ( *PopFrame) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *ForceEarlyReturnObject) (jvmtiEnv* env,
+    jthread thread,
+    jobject value);
+  jvmtiError ( *ForceEarlyReturnInt) (jvmtiEnv* env,
+    jthread thread,
+    jint value);
+  jvmtiError ( *ForceEarlyReturnLong) (jvmtiEnv* env,
+    jthread thread,
+    jlong value);
+  jvmtiError ( *ForceEarlyReturnFloat) (jvmtiEnv* env,
+    jthread thread,
+    jfloat value);
+  jvmtiError ( *ForceEarlyReturnDouble) (jvmtiEnv* env,
+    jthread thread,
+    jdouble value);
+  jvmtiError ( *ForceEarlyReturnVoid) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *RedefineClasses) (jvmtiEnv* env,
+    jint class_count,
+    const jvmtiClassDefinition* class_definitions);
+  jvmtiError ( *GetVersionNumber) (jvmtiEnv* env,
+    jint* version_ptr);
+  jvmtiError ( *GetCapabilities) (jvmtiEnv* env,
+    jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *GetSourceDebugExtension) (jvmtiEnv* env,
+    jclass klass,
+    char** source_debug_extension_ptr);
+  jvmtiError ( *IsMethodObsolete) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_obsolete_ptr);
+  jvmtiError ( *SuspendThreadList) (jvmtiEnv* env,
+    jint request_count,
+    const jthread* request_list,
+    jvmtiError* results);
+  jvmtiError ( *ResumeThreadList) (jvmtiEnv* env,
+    jint request_count,
+    const jthread* request_list,
+    jvmtiError* results);
+  void *reserved94;
+  void *reserved95;
+  void *reserved96;
+  void *reserved97;
+  void *reserved98;
+  void *reserved99;
+  jvmtiError ( *GetAllStackTraces) (jvmtiEnv* env,
+    jint max_frame_count,
+    jvmtiStackInfo** stack_info_ptr,
+    jint* thread_count_ptr);
+  jvmtiError ( *GetThreadListStackTraces) (jvmtiEnv* env,
+    jint thread_count,
+    const jthread* thread_list,
+    jint max_frame_count,
+    jvmtiStackInfo** stack_info_ptr);
+  jvmtiError ( *GetThreadLocalStorage) (jvmtiEnv* env,
+    jthread thread,
+    void** data_ptr);
+  jvmtiError ( *SetThreadLocalStorage) (jvmtiEnv* env,
+    jthread thread,
+    const void* data);
+  jvmtiError ( *GetStackTrace) (jvmtiEnv* env,
+    jthread thread,
+    jint start_depth,
+    jint max_frame_count,
+    jvmtiFrameInfo* frame_buffer,
+    jint* count_ptr);
+  void *reserved105;
+  jvmtiError ( *GetTag) (jvmtiEnv* env,
+    jobject object,
+    jlong* tag_ptr);
+  jvmtiError ( *SetTag) (jvmtiEnv* env,
+    jobject object,
+    jlong tag);
+  jvmtiError ( *ForceGarbageCollection) (jvmtiEnv* env);
+  jvmtiError ( *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
+    jobject object,
+    jvmtiObjectReferenceCallback object_reference_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverReachableObjects) (jvmtiEnv* env,
+    jvmtiHeapRootCallback heap_root_callback,
+    jvmtiStackReferenceCallback stack_ref_callback,
+    jvmtiObjectReferenceCallback object_ref_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverHeap) (jvmtiEnv* env,
+    jvmtiHeapObjectFilter object_filter,
+    jvmtiHeapObjectCallback heap_object_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverInstancesOfClass) (jvmtiEnv* env,
+    jclass klass,
+    jvmtiHeapObjectFilter object_filter,
+    jvmtiHeapObjectCallback heap_object_callback,
+    const void* user_data);
+  void *reserved113;
+  jvmtiError ( *GetObjectsWithTags) (jvmtiEnv* env,
+    jint tag_count,
+    const jlong* tags,
+    jint* count_ptr,
+    jobject** object_result_ptr,
+    jlong** tag_result_ptr);
+  jvmtiError ( *FollowReferences) (jvmtiEnv* env,
+    jint heap_filter,
+    jclass klass,
+    jobject initial_object,
+    const jvmtiHeapCallbacks* callbacks,
+    const void* user_data);
+  jvmtiError ( *IterateThroughHeap) (jvmtiEnv* env,
+    jint heap_filter,
+    jclass klass,
+    const jvmtiHeapCallbacks* callbacks,
+    const void* user_data);
+  void *reserved117;
+  void *reserved118;
+  void *reserved119;
+  jvmtiError ( *SetJNIFunctionTable) (jvmtiEnv* env,
+    const jniNativeInterface* function_table);
+  jvmtiError ( *GetJNIFunctionTable) (jvmtiEnv* env,
+    jniNativeInterface** function_table);
+  jvmtiError ( *SetEventCallbacks) (jvmtiEnv* env,
+    const jvmtiEventCallbacks* callbacks,
+    jint size_of_callbacks);
+  jvmtiError ( *GenerateEvents) (jvmtiEnv* env,
+    jvmtiEvent event_type);
+  jvmtiError ( *GetExtensionFunctions) (jvmtiEnv* env,
+    jint* extension_count_ptr,
+    jvmtiExtensionFunctionInfo** extensions);
+  jvmtiError ( *GetExtensionEvents) (jvmtiEnv* env,
+    jint* extension_count_ptr,
+    jvmtiExtensionEventInfo** extensions);
+  jvmtiError ( *SetExtensionEventCallback) (jvmtiEnv* env,
+    jint extension_event_index,
+    jvmtiExtensionEvent callback);
+  jvmtiError ( *DisposeEnvironment) (jvmtiEnv* env);
+  jvmtiError ( *GetErrorName) (jvmtiEnv* env,
+    jvmtiError error,
+    char** name_ptr);
+  jvmtiError ( *GetJLocationFormat) (jvmtiEnv* env,
+    jvmtiJlocationFormat* format_ptr);
+  jvmtiError ( *GetSystemProperties) (jvmtiEnv* env,
+    jint* count_ptr,
+    char*** property_ptr);
+  jvmtiError ( *GetSystemProperty) (jvmtiEnv* env,
+    const char* property,
+    char** value_ptr);
+  jvmtiError ( *SetSystemProperty) (jvmtiEnv* env,
+    const char* property,
+    const char* value);
+  jvmtiError ( *GetPhase) (jvmtiEnv* env,
+    jvmtiPhase* phase_ptr);
+  jvmtiError ( *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetCurrentThreadCpuTime) (jvmtiEnv* env,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetThreadCpuTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetThreadCpuTime) (jvmtiEnv* env,
+    jthread thread,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetTime) (jvmtiEnv* env,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetPotentialCapabilities) (jvmtiEnv* env,
+    jvmtiCapabilities* capabilities_ptr);
+  void *reserved141;
+  jvmtiError ( *AddCapabilities) (jvmtiEnv* env,
+    const jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *RelinquishCapabilities) (jvmtiEnv* env,
+    const jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *GetAvailableProcessors) (jvmtiEnv* env,
+    jint* processor_count_ptr);
+  jvmtiError ( *GetClassVersionNumbers) (jvmtiEnv* env,
+    jclass klass,
+    jint* minor_version_ptr,
+    jint* major_version_ptr);
+  jvmtiError ( *GetConstantPool) (jvmtiEnv* env,
+    jclass klass,
+    jint* constant_pool_count_ptr,
+    jint* constant_pool_byte_count_ptr,
+    unsigned char** constant_pool_bytes_ptr);
+  jvmtiError ( *GetEnvironmentLocalStorage) (jvmtiEnv* env,
+    void** data_ptr);
+  jvmtiError ( *SetEnvironmentLocalStorage) (jvmtiEnv* env,
+    const void* data);
+  jvmtiError ( *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
+    const char* segment);
+  jvmtiError ( *SetVerboseFlag) (jvmtiEnv* env,
+    jvmtiVerboseFlag flag,
+    jboolean value);
+  jvmtiError ( *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
+    const char* segment);
+  jvmtiError ( *RetransformClasses) (jvmtiEnv* env,
+    jint class_count,
+    const jclass* classes);
+  jvmtiError ( *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
+    jthread thread,
+    jint* monitor_info_count_ptr,
+    jvmtiMonitorStackDepthInfo** monitor_info_ptr);
+  jvmtiError ( *GetObjectSize) (jvmtiEnv* env,
+    jobject object,
+    jlong* size_ptr);
+} jvmtiInterface_1;
+struct _jvmtiEnv {
+    const struct jvmtiInterface_1_ *functions;
+};
+struct bkpt {
+    CVMUint8* pc;
+    CVMUint8 opcode;
+    jobject classRef;
+};
+struct fpop {
+    CVMFrame* frame;
+};
+struct fieldWatch {
+    CVMFieldBlock* fb;
+    jclass classRef;
+};
+enum {
+    JVMTI_INTERNAL_CAPABILITY_COUNT = 39
+};
+typedef struct CVMJvmtiMethodNode CVMJvmtiMethodNode;
+struct CVMJvmtiMethodNode {
+    CVMUint32 mid;
+    CVMMethodBlock *mb;
+    CVMBool isObsolete;
+    CVMConstantPool *cp;
+    CVMJvmtiMethodNode *next;
+};
+typedef struct CVMJvmtiTagNode CVMJvmtiTagNode;
+struct CVMJvmtiTagNode {
+    jlong tag;
+    jobject ref;
+    CVMJvmtiTagNode *next;
+};
+enum {
+    JVMTI_MAGIC = 0x71EE,
+    BAD_MAGIC = 0xDEAD
+};
+typedef struct CVMJvmtiEventEnabled CVMJvmtiEventEnabled;
+struct CVMJvmtiEventEnabled{
+    jlong enabledBits;
+};
+typedef struct CVMJvmtiVisitStack CVMJvmtiVisitStack;
+struct CVMJvmtiVisitStack {
+    CVMObject **stackBase;
+    CVMObject **stackPtr;
+    jvmtiEnv *env;
+    int stackSize;
+};
+typedef struct CVMJvmtiDumpContext CVMJvmtiDumpContext;
+struct CVMJvmtiDumpContext {
+    jint heapFilter;
+    jclass klass;
+    const jvmtiHeapCallbacks *callbacks;
+    const void *userData;
+    CVMExecEnv *ee;
+    JNIEnv *env;
+    CVMFrame *frame;
+    jint frameCount;
+    CVMObjectICell *icell;
+};
+typedef struct CVMJvmtiEnvEventEnable CVMJvmtiEnvEventEnable;
+struct CVMJvmtiEnvEventEnable {
+    CVMJvmtiEventEnabled eventUserEnabled;
+    CVMJvmtiEventEnabled eventCallbackEnabled;
+    CVMJvmtiEventEnabled eventEnabled;
+};
+typedef struct CVMJvmtiContext CVMJvmtiContext;
+struct CVMJvmtiContext {
+    jvmtiEnv jvmtiExternal;
+    const void *envLocalStorage;
+    jvmtiEventCallbacks eventCallbacks;
+    jboolean isValid;
+    jboolean threadEventsEnabled;
+    jint magic;
+    jint index;
+    CVMJvmtiEnvEventEnable envEventEnable;
+    jvmtiCapabilities currentCapabilities;
+    jvmtiCapabilities prohibitedCapabilities;
+    jboolean classFileLoadHookEverEnabled;
+    char** nativeMethodPrefixes;
+    int nativeMethodPrefixCount;
+};
+jvmtiError CVMjvmtiVisitStackPush(CVMObject *obj);
+CVMBool CVMjvmtiVisitStackEmpty();
+void CVMjvmtiCleanupMarked();
+void CVMjvmtiRecomputeEnabled(CVMJvmtiEnvEventEnable *);
+jlong CVMjvmtiRecomputeThreadEnabled(CVMExecEnv *ee, CVMJvmtiEnvEventEnable *);
+int CVMjvmtiDestroyContext(CVMJvmtiContext *context);
+CVMClassBlock *CVMjvmtiClassRef2ClassBlock(CVMExecEnv *ee, jclass clazz);
+CVMBool CVMjvmtiIsGCOwner();
+void CVMjvmtiSetGCOwner(CVMBool);
+typedef struct CVMJvmtiThreadNode CVMJvmtiThreadNode;
+struct CVMJvmtiThreadNode {
+    CVMObjectICell* thread;
+    jobject lastDetectedException;
+    jvmtiStartFunction startFunction;
+    const void *startFunctionArg;
+    CVMJvmtiContext *context;
+    void *jvmtiPrivateData;
+    CVMClassBlock *oldCb;
+    CVMClassBlock *redefineCb;
+    CVMBool startEventSent;
+    CVMJvmtiThreadNode *next;
+};
+typedef struct CVMJvmtiGlobals CVMJvmtiGlobals;
+struct CVMJvmtiGlobals {
+    struct {
+ int fieldAccessCount;
+ int fieldModificationCount;
+ jboolean canGetSourceDebugExtension;
+ jboolean canExamineOrDeoptAnywhere;
+ jboolean canMaintainOriginalMethodOrder;
+ jboolean canPostInterpreterEvents;
+ jboolean canHotswapOrPostBreakpoint;
+ jboolean canModifyAnyClass;
+ jboolean canWalkAnySpace;
+ jboolean canAccessLocalVariables;
+ jboolean canPostExceptions;
+ jboolean canPostBreakpoint;
+ jboolean canPostFieldAccess;
+ jboolean canPostFieldModification;
+ jboolean canPostMethodEntry;
+ jboolean canPostMethodExit;
+ jboolean canPopFrame;
+ jboolean canForceEarlyReturn;
+ jboolean shouldPostSingleStep;
+ jboolean shouldPostFieldAccess;
+ jboolean shouldPostFieldModification;
+ jboolean shouldPostClassLoad;
+ jboolean shouldPostClassPrepare;
+ jboolean shouldPostClassUnload;
+ jboolean shouldPostClassFileLoadHook;
+ jboolean shouldPostNativeMethodBind;
+ jboolean shouldPostCompiledMethodLoad;
+ jboolean shouldPostCompiledMethodUnload;
+ jboolean shouldPostDynamicCodeGenerated;
+ jboolean shouldPostMonitorContendedEnter;
+ jboolean shouldPostMonitorContendedEntered;
+ jboolean shouldPostMonitorWait;
+ jboolean shouldPostMonitorWaited;
+ jboolean shouldPostDataDump;
+ jboolean shouldPostGarbageCollectionStart;
+ jboolean shouldPostGarbageCollectionFinish;
+ jboolean shouldPostThreadLife;
+ jboolean shouldPostObjectFree;
+ jboolean shouldCleanUpHeapObjects;
+ jboolean shouldPostVmObjectAlloc;
+ jboolean hasRedefinedAClass;
+ jboolean allDependenciesAreRecorded;
+    } exports;
+    CVMBool dataDumpRequested;
+    CVMBool isEnabled;
+    CVMBool isInDebugMode;
+    CVMBool debugOptionSet;
+    CVMBool isWatchingFieldAccess;
+    CVMBool isWatchingFieldModification;
+    struct {
+ JavaVM* vm;
+ struct CVMBag* breakpoints;
+ struct CVMBag* framePops;
+ struct CVMBag* watchedFieldModifications;
+ struct CVMBag* watchedFieldAccesses;
+ volatile CVMJvmtiThreadNode *threadList;
+ CVMJvmtiContext *context;
+ jvmtiPhase currentPhase;
+ CVMJvmtiMethodNode *nodeByMB[1531];
+ jfieldID nameID;
+ jfieldID priorityID;
+ jfieldID daemonID;
+ jfieldID groupID;
+ jfieldID loaderID;
+ jfieldID tgParentID;
+ jfieldID tgNameID;
+ jfieldID tgMaxPriorityID;
+ jfieldID tgDaemonID;
+ jfieldID nthreadsID;
+ jfieldID threadsID;
+ jfieldID ngroupsID;
+ jfieldID groupsID;
+ CVMJvmtiVisitStack currentStack;
+ CVMJvmtiTagNode *romObjects[1531];
+ CVMJvmtiTagNode *objectsByRef[1531];
+    } statics;
+    struct {
+ jvmtiCapabilities always;
+ jvmtiCapabilities onload;
+ jvmtiCapabilities always_solo;
+ jvmtiCapabilities onload_solo;
+ jvmtiCapabilities always_solo_remaining;
+ jvmtiCapabilities onload_solo_remaining;
+ jvmtiCapabilities acquired;
+    } capabilities;
+};
+void CVMjvmtiSetCanGetSourceDebugExtension(jboolean on);
+void CVMjvmtiSetCanExamineOrDeoptAnywhere(jboolean on);
+void CVMjvmtiSetCanMaintainOriginalMethodOrder(jboolean on);
+void CVMjvmtiSetCanPostInterpreterEvents(jboolean on);
+void CVMjvmtiSetCanHotswapOrPostBreakpoint(jboolean on);
+void CVMjvmtiSetCanModifyAnyClass(jboolean on);
+void CVMjvmtiSetCanWalkAnySpace(jboolean on);
+void CVMjvmtiSetCanAccessLocalVariables(jboolean on);
+void CVMjvmtiSetCanPostExceptions(jboolean on);
+void CVMjvmtiSetCanPostBreakpoint(jboolean on);
+void CVMjvmtiSetCanPostFieldAccess(jboolean on);
+void CVMjvmtiSetCanPostFieldModification(jboolean on);
+void CVMjvmtiSetCanPostMethodEntry(jboolean on);
+void CVMjvmtiSetCanPostMethodExit(jboolean on);
+void CVMjvmtiSetCanPopFrame(jboolean on);
+void CVMjvmtiSetCanForceEarlyReturn(jboolean on);
+void CVMjvmtiSetShouldPostSingleStep(jboolean on);
+void CVMjvmtiSetShouldPostFieldAccess(jboolean on);
+void CVMjvmtiSetShouldPostFieldModification(jboolean on);
+void CVMjvmtiSetShouldPostClassLoad(jboolean on);
+void CVMjvmtiSetShouldPostClassPrepare(jboolean on);
+void CVMjvmtiSetShouldPostClassUnload(jboolean on);
+void CVMjvmtiSetShouldPostClassFileLoadHook(jboolean on);
+void CVMjvmtiSetShouldPostNativeMethodBind(jboolean on);
+void CVMjvmtiSetShouldPostCompiledMethodLoad(jboolean on);
+void CVMjvmtiSetShouldPostCompiledMethodUnload(jboolean on);
+void CVMjvmtiSetShouldPostDynamicCodeGenerated(jboolean on);
+void CVMjvmtiSetShouldPostMonitorContendedEnter(jboolean on);
+void CVMjvmtiSetShouldPostMonitorContendedEntered(jboolean on);
+void CVMjvmtiSetShouldPostMonitorWait(jboolean on);
+void CVMjvmtiSetShouldPostMonitorWaited(jboolean on);
+void CVMjvmtiSetShouldPostGarbageCollectionStart(jboolean on);
+void CVMjvmtiSetShouldPostGarbageCollectionFinish(jboolean on);
+void CVMjvmtiSetShouldPostDataDump(jboolean on);
+void CVMjvmtiSetShouldPostObjectFree(jboolean on);
+void CVMjvmtiSetShouldPostVmObjectAlloc(jboolean on);
+void CVMjvmtiSetShouldPostThreadLife(jboolean on);
+void CVMjvmtiSetShouldCleanUpHeapObjects(jboolean on);
+jlong CVMjvmtiGetThreadEventEnabled(CVMExecEnv *ee);
+void CVMjvmtiSetShouldPostAnyThreadEvent(CVMExecEnv *ee, jlong enabled);
+enum {
+    JVMTIVERSIONMASK = 0x70000000,
+    JVMTIVERSIONVALUE = 0x30000000,
+    JVMDIVERSIONVALUE = 0x20000000
+};
+void CVMjvmtiEnterPrimordialPhase();
+void CVMjvmtiEnterOnloadPhase();
+void CVMjvmtiEnterStartPhase();
+void CVMjvmtiEnterLivePhase();
+void CVMjvmtiEnterDeadPhase();
+jvmtiPhase CVMjvmtiGetPhase();
+jboolean CVMjvmtiCanGetSourceDebugExtension();
+jboolean CVMjvmtiCanExamineOrDeoptAnywhere();
+jboolean CVMjvmtiCanMaintainOriginalMethodOrder();
+jboolean CVMjvmtiCanPostInterpreterEvents();
+jboolean CVMjvmtiCanHotswapOrPostBreakpoint();
+jboolean CVMjvmtiCanModifyAnyClass();
+jboolean CVMjvmtiCanWalkAnySpace();
+jboolean CVMjvmtiCanAccessLocalVariables();
+jboolean CVMjvmtiCanPostExceptions();
+jboolean CVMjvmtiCanPostBreakpoint();
+jboolean CVMjvmtiCanPostFieldAccess();
+jboolean CVMjvmtiCanPostFieldModification();
+jboolean CVMjvmtiCanPostMethodEntry();
+jboolean CVMjvmtiCanPostMethodExit();
+jboolean CVMjvmtiCanPopFrame();
+jboolean CVMjvmtiCanForceEarlyReturn();
+jboolean CVMjvmtiShouldPostThreadLife();
+jboolean CVMjvmtiShouldPostSingleStep();
+jboolean CVMjvmtiShouldPostFieldAccess();
+jboolean CVMjvmtiShouldPostFieldModification();
+jboolean CVMjvmtiShouldPostClassLoad();
+jboolean CVMjvmtiShouldPostClassPrepare();
+jboolean CVMjvmtiShouldPostClassUnload();
+jboolean CVMjvmtiShouldPostClassFileLoadHook();
+jboolean CVMjvmtiShouldPostNativeMethodBind();
+jboolean CVMjvmtiShouldPostCompiledMethodLoad();
+jboolean CVMjvmtiShouldPostCompiledMethodUnload();
+jboolean CVMjvmtiShouldPostDynamicCodeGenerated();
+jboolean CVMjvmtiShouldPostMonitorContendedEnter();
+jboolean CVMjvmtiShouldPostMonitorContendedEntered();
+jboolean CVMjvmtiShouldPostMonitorWait();
+jboolean CVMjvmtiShouldPostMonitorWaited();
+jboolean CVMjvmtiShouldPostDataDump();
+jboolean CVMjvmtiShouldPostGarbageCollectionStart();
+jboolean CVMjvmtiShouldPostGarbageCollectionFinish();
+jboolean CVMjvmtiShouldPostObjectFree();
+jboolean CVMjvmtiShouldPostVmObjectAlloc();
+char** getAllNativeMethodPrefixes(int* countPtr);
+void cmsRefProcessingEpilogue();
+typedef struct AttachOperation_ {
+  char *args;
+} AttachOperation;
+typedef enum CVMJvmtiLoadKind CVMJvmtiLoadKind;
+enum CVMJvmtiLoadKind {
+  JVMTICLASSLOADKINDNORMAL = 0,
+  JVMTICLASSLOADKINDREDEFINE,
+  JVMDICLASSLOADKINDRETRANSFORM
+};
+typedef struct CVMJvmtiLockInfo CVMJvmtiLockInfo;
+struct CVMJvmtiLockInfo {
+    CVMJvmtiLockInfo *next;
+    CVMOwnedMonitor *lock;
+};
+typedef struct CVMJvmtiExecEnv CVMJvmtiExecEnv;
+struct CVMJvmtiExecEnv {
+    CVMBool debugEventsEnabled;
+    CVMBool jvmtiSingleStepping;
+    CVMBool jvmtiNeedFramePop;
+    CVMBool jvmtiNeedEarlyReturn;
+    CVMBool jvmtiDataDumpRequested;
+    CVMBool jvmtiNeedProcessing;
+    CVMJvmtiEventEnabled jvmtiUserEventEnabled;
+    CVMJvmtiEventEnabled jvmtiEventEnabled;
+    jvalue jvmtiEarlyReturnValue;
+    CVMUint32 jvmtiEarlyRetOpcode;
+    CVMJvmtiLockInfo *jvmtiLockInfoFreelist;
+    void *jvmtiProfilerData;
+};
+void CVMjvmtiPostExceptionEvent(CVMExecEnv* ee,
+    CVMUint8* pc,
+    CVMObjectICell* object);
+void CVMjvmtiPostExceptionCatchEvent(CVMExecEnv* ee,
+         CVMUint8* pc,
+         CVMObjectICell* object);
+void CVMjvmtiPostSingleStepEvent(CVMExecEnv* ee,
+     CVMUint8* pc);
+void CVMjvmtiPostFieldAccessEvent(CVMExecEnv* ee,
+      CVMObjectICell* obj,
+      CVMFieldBlock* fb);
+void CVMjvmtiPostFieldModificationEvent(CVMExecEnv* ee,
+     CVMObjectICell* obj,
+     CVMFieldBlock* fb,
+            jvalue jval);
+void CVMjvmtiPostThreadStartEvent(CVMExecEnv* ee,
+      CVMObjectICell* thread);
+void CVMjvmtiPostThreadEndEvent(CVMExecEnv* ee,
+    CVMObjectICell* thread);
+void CVMjvmtiPostFramePushEvent(CVMExecEnv* ee);
+void CVMjvmtiPostFramePopEvent(CVMExecEnv* ee, CVMBool isRef,
+          CVMBool isException, jvalue *retValue);
+void CVMjvmtiPostClassLoadEvent(CVMExecEnv* ee,
+    CVMObjectICell* clazz);
+void CVMjvmtiPostClassPrepareEvent(CVMExecEnv* ee,
+       CVMObjectICell* clazz);
+void CVMjvmtiPostClassUnloadEvent(CVMExecEnv* ee,
+      CVMObjectICell* clazz);
+void CVMjvmtiPostVmStartEvent(CVMExecEnv* ee);
+void CVMjvmtiPostVmInitEvent(CVMExecEnv* ee);
+void CVMjvmtiPostVmExitEvent(CVMExecEnv* ee);
+CVMUint8 CVMjvmtiGetBreakpointOpcode(CVMExecEnv* ee, CVMUint8* pc,
+         CVMBool notify);
+CVMBool CVMjvmtiSetBreakpointOpcode(CVMExecEnv* ee, CVMUint8* pc,
+        CVMUint8 opcode);
+void CVMjvmtiPostClassLoadHookEvent(jclass klass,
+        CVMClassLoaderICell *loader,
+        const char *className,
+        jobject protectionDomain,
+        CVMInt32 bufferLength,
+        CVMUint8 *buffer,
+        CVMInt32 *newBufferLength,
+        CVMUint8 **newBuffer);
+void CVMjvmtiPostCompiledMethodLoadEvent(CVMExecEnv *ee,
+      CVMMethodBlock *mb);
+void CVMjvmtiPostCompiledMethodUnloadEvent(CVMExecEnv *ee,
+        CVMMethodBlock* mb);
+void CVMjvmtiPostDataDumpRequest(void);
+void CVMjvmtiPostGCStartEvent(void);
+void CVMjvmtiPostGCFinishEvent(void);
+void CVMjvmtiPostStartUpEvents(CVMExecEnv *ee);
+void CVMjvmtiPostNativeMethodBind(CVMExecEnv *ee, CVMMethodBlock *mb,
+      CVMUint8 *nativeCode,
+      CVMUint8 **newNativeCode);
+void CVMjvmtiPostMonitorContendedEnterEvent(CVMExecEnv *ee,
+         CVMProfiledMonitor *pm);
+void CVMjvmtiPostMonitorContendedEnteredEvent(CVMExecEnv *ee,
+                                              CVMProfiledMonitor *pm);
+void CVMjvmtiPostMonitorWaitEvent(CVMExecEnv *ee,
+      jobject obj, jlong millis);
+void CVMjvmtiPostMonitorWaitedEvent(CVMExecEnv *ee,
+        jobject obj, CVMBool timedout);
+void CVMjvmtiPostObjectFreeEvent(CVMObject *obj);
+CVMBool CVMjvmtiDataDumpWasRequested(void);
+void CVMjvmtiResetDataDumpRequested(void);
+jint CVMjvmtiGetInterface(JavaVM *interfacesVm, void **penv);
+void CVMjvmtiInitializeGlobals(CVMJvmtiGlobals *globals);
+void CVMjvmtiDestroyGlobals(CVMJvmtiGlobals *globals);
+jvmtiError CVMjvmtiInitialize(JavaVM *vm);
+void CVMjvmtiDestroy(CVMJvmtiGlobals *globals);
+CVMJvmtiThreadNode *
+CVMjvmtiFindThread(CVMExecEnv* ee, CVMObjectICell* thread);
+CVMJvmtiThreadNode *
+CVMjvmtiInsertThread(CVMExecEnv* ee, CVMObjectICell* thread);
+jboolean CVMjvmtiRemoveThread(CVMExecEnv* ee, CVMObjectICell *thread);
+jvmtiError CVMjvmtiAllocate(jlong size, unsigned char **mem);
+jvmtiError CVMjvmtiDeallocate(unsigned char *mem);
+CVMBool CVMjvmtiClassBeingRedefined(CVMExecEnv *ee, CVMClassBlock *cb);
+CVMClassBlock *CVMjvmtiClassObject2ClassBlock(CVMExecEnv *ee, CVMObject *obj);
+void CVMjvmtiRehash(void);
+CVMUint32 CVMjvmtiUniqueID();
+void CVMjvmtiMarkAsObsolete(CVMMethodBlock *oldmb, CVMConstantPool *cp);
+CVMBool CVMjvmtiMbIsObsoleteX(CVMMethodBlock *mb);
+CVMConstantPool * CVMjvmtiMbConstantPool(CVMMethodBlock *mb);
+CVMBool CVMjvmtiCheckLockInfo(CVMExecEnv *ee);
+void CVMjvmtiAddLockInfo(CVMExecEnv *ee, CVMObjMonitor *mon,
+                                CVMOwnedMonitor *o,
+                                CVMBool okToBecomeGCSafe);
+void CVMjvmtiRemoveLockInfo(CVMExecEnv *ee, CVMObjMonitor *mon,
+                                   CVMOwnedMonitor *o);
+CVMClassBlock* CVMjvmtiGetCurrentRedefinedClass(CVMExecEnv *ee);
+void CVMjvmtiDestroyLockInfo(CVMExecEnv *ee);
+typedef enum {
+    CVM_THREAD_RUNNING = 0x0,
+    CVM_THREAD_TERMINATED = 0x2,
+    CVM_THREAD_WAITING_INDEFINITE = 0x10,
+    CVM_THREAD_WAITING_TIMEOUT = 0x20,
+    CVM_THREAD_SLEEPING = 0x40,
+    CVM_THREAD_WAITING = 0x80,
+    CVM_THREAD_OBJECT_WAIT = 0x100,
+    CVM_THREAD_BLOCKED_MONITOR_ENTER = 0x400,
+    CVM_THREAD_SUSPENDED = 0x100000,
+    CVM_THREAD_INTERRUPTED = 0x200000,
+    CVM_THREAD_IN_NATIVE = 0x400000,
+    CVM_THREAD_STACK_MUTATOR_LOCK = 0x800000
+} CVMThreadState;
+typedef enum {
+    CVM_EXCEPTION_NONE = 0,
+    CVM_EXCEPTION_TOP,
+    CVM_EXCEPTION_UNWINDING
+}CVMExceptionState;
+struct CVMExecEnv {
+    CVMTCState tcstate[CVM_NUM_CONSISTENT_STATES];
+    CVMUint8 isThrowingAnException;
+    CVMUint8 isHandlingAnException;
+    CVMUint16 remoteExceptionsDisabledCount;
+    CVMThrowableICell* localExceptionICell;
+    CVMThrowableICell* remoteExceptionICell;
+    CVMThrowableICell* currentExceptionICell;
+    union {
+ struct {
+     CVMUint8 remote;
+     CVMUint8 local;
+ } oneflag;
+ CVMUint16 bothflags;
+    } exceptionFlags;
+    CVMThreadICell* threadICell;
+    CVMObjectICell* miscICell;
+    CVMObjectICell* syncICell;
+    CVMObjectICell* finalizerRegisterICell;
+    CVMJNIEnv jniEnv;
+    CVMExecEnv **prevEEPtr;
+    CVMExecEnv *nextEE;
+    CVMStack interpreterStack;
+    CVMStack localRootsStack;
+    CVMBool cstackBufferFlag;
+    char *cstackBuffer;
+    void * nativeRunInfo;
+    CVMObjMonitor * volatile objLockCurrent;
+    CVMObjMonitor *objLocksFreeUnlocked;
+    CVMOwnedMonitor *objLocksOwned;
+    CVMOwnedMonitor *objLocksFreeOwned;
+    CVMBool threadExiting;
+    CVMOwnedMonitor *objLocksReservedOwned;
+    CVMObjMonitor *objLocksReservedUnlocked;
+    CVMThreadID threadInfo;
+    CVMThreadState threadState;
+    CVMUint32 threadID;
+    int nativeRunInfoType;
+    CVMSysMutex *sysLocks;
+    int microLock;
+    CVMBool userThread;
+    CVMObjectICell* allocationRetryICell;
+    CVMUint32 criticalCount;
+    CVMBool hasPostedExitEvents;
+    volatile CVMJvmtiExecEnv jvmtiEE;
+    CVMProfiledMonitor *blockingLockEntryMonitor;
+    CVMProfiledMonitor *blockingWaitMonitor;
+    CVMBool hasRun;
+    CVMBool interruptsMasked;
+    CVMBool maskedInterrupt;
+    CVMObjMonitor *objLocksPinned[16];
+    CVMSize objLocksPinnedCount;
+    CVMUint32 traceDepth;
+    CVMInt32 priority;
+    CVMUint32 tickCount;
+    CVMUint32 debugFlags;
+};
+typedef struct {
+    CVMThreadICell* threadICell;
+    void (*nativeFunc)(void *);
+    void* nativeFuncArg;
+    CVMBool isDaemon;
+    int started;
+    CVMMutex parentLock;
+    CVMCondVar parentCond;
+    CVMExecEnv *ee;
+    int priority;
+} CVMThreadStartInfo;
+extern CVMBool
+CVMinitExecEnv(CVMExecEnv* ee, CVMExecEnv *targetEE,
+        CVMThreadStartInfo* threadInfo);
+extern void
+CVMdestroyExecEnv(CVMExecEnv* ee);
+extern CVMBool
+CVMattachExecEnv(CVMExecEnv* ee, CVMBool orphan);
+extern void
+CVMdetachExecEnv(CVMExecEnv* ee);
+extern CVMExecEnv * CVMgetEE();
+extern void CVMaddThread(CVMExecEnv *ee, CVMBool userThread);
+extern void CVMremoveThread(CVMExecEnv *ee, CVMBool userThread);
+struct CVMInterpreterFrame {
+    CVMFrame frameX;
+    CVMUint8* pcX;
+    CVMConstantPool* cpX;
+    CVMSlotVal32* localsX;
+};
+struct CVMJavaFrame {
+    CVMInterpreterFrame frameX;
+    CVMJvmtiLockInfo *jvmtiLockInfo;
+    CVMObjectICell receiverObjX;
+    CVMStackVal32 opstackX[1];
+};
+struct CVMTransitionFrame {
+    CVMInterpreterFrame frameX;
+    CVMBool incrementPcFlagX;
+    CVMStackVal32 opstackX[1];
+};
+extern CVMInterpreterFrame *CVMDEBUGgetInterpreterFrame(CVMFrame *frame);
+extern void
+CVMgcUnsafeExecuteJavaMethod(CVMExecEnv* volatile ee, CVMMethodBlock* mb,
+        CVMBool isStatic, CVMBool isVirtual);
+extern void
+CVMgcUnsafeExecuteJavaMethodJVMTI(CVMExecEnv* volatile ee, CVMMethodBlock* mb,
+                                  CVMBool isStatic, CVMBool isVirtual);
+extern CVMUint8* CVMgcUnsafeExecuteJavaMethodQuick(CVMExecEnv* ee,
+    CVMUint8* pc, CVMStackVal32* topOfStack, CVMSlotVal32* locals,
+    CVMConstantPool* cp, CVMClassBlock** retCb);
+extern CVMInt32
+CVMpc2lineno(CVMMethodBlock *mb, CVMUint16 pc_offset);
+extern void
+CVMframe2string(CVMFrame* frame, char *buf, char* limit);
+extern void
+CVMframeIterate2string(CVMFrameIterator* frame, char *buf, char* limit);
+extern void
+CVMpc2string(CVMUint8* pc, CVMMethodBlock* mb,
+      CVMBool isTransition, CVMBool isCompiled, char *buf, char* limit);
+extern void
+CVMlineno2string(CVMInt32 lineno, CVMMethodBlock* mb,
+      CVMBool isTransition, CVMBool isCompiled, char *buf, char* limit);
+extern CVMUint8*
+CVMgcSafeFindPCForException(CVMExecEnv* ee, CVMFrameIterator* frame,
+       CVMClassBlock* exceptionClass, CVMUint8* pc);
+extern CVMFrame*
+CVMgcUnsafeHandleException(CVMExecEnv* ee, CVMFrame* frame,
+      CVMFrame* initialframe);
+extern void
+CVMsignalError(CVMExecEnv* ee, CVMClassBlock* exceptionCb,
+        const char *format, ...);
+extern void
+CVMsignalErrorVaList(CVMExecEnv* ee, CVMClassBlock* exceptionCb,
+       const char* format, va_list ap);
+extern CVMTransitionFrame*
+CVMpushTransitionFrame(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern CVMBool
+CVMjavaFrameEnsureStackmaps(CVMExecEnv *ee, CVMExecEnv *frameEE,
+                            CVMFrame *frame);
+typedef struct {
+    CVMExecEnv *targetEE;
+    CVMFrame *prevFrame;
+    void *callbackData;
+} CVMInterpreterStackData;
+extern CVMStackMapEntry*
+CVMgetStackmapEntry(CVMExecEnv *frameEE, CVMFrame *frame,
+      CVMJavaMethodDescriptor *jmd, CVMStackMaps *stackmaps,
+      CVMBool *missingStackmapOK);
+CVMUint8*
+CVMfindInnermostHandlerFor(CVMJavaMethodDescriptor* jmd, CVMUint8* pc);
+CVMClassBlock* CVMgetCallerClass(CVMExecEnv* ee, int skip);
+CVMFrame*
+CVMgetCallerFrameSpecial(CVMFrame* frame, int n, CVMBool skipReflection);
+struct CVMFrameIterator {
+    CVMStack *stack;
+    CVMFrame *endFrame;
+    CVMFrame *frame;
+    CVMFrame *next;
+};
+void
+CVMframeIterateInitSpecial(CVMFrameIterator *iter, CVMStack *stack,
+      CVMFrame* firstFrame, CVMFrame *lastFrame);
+void
+CVMframeIterateInit(CVMFrameIterator *iter, CVMFrame* firstFrame);
+CVMBool
+CVMframeIterateSkipReflection(CVMFrameIterator *iter,
+    int skip, CVMBool skipReflection, CVMBool popFrame);
+CVMUint32
+CVMframeIterateCount(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateIsInlined(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateHandlesExceptions(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateCanHaveJavaCatchClause(CVMFrameIterator *iter);
+CVMFrameFlags
+CVMframeIterateGetFlags(CVMFrameIterator *iter);
+void
+CVMframeIterateSetFlags(CVMFrameIterator *iter, CVMFrameFlags flags);
+CVMFrame *
+CVMframeIterateGetFrame(CVMFrameIterator *iter);
+CVMMethodBlock *
+CVMframeIterateGetMb(CVMFrameIterator *iter);
+CVMUint8 *
+CVMframeIterateGetJavaPc(CVMFrameIterator *iter);
+void
+CVMframeIterateSetJavaPc(CVMFrameIterator *iter, CVMUint8 *pc);
+CVMStackVal32 *
+CVMframeIterateGetLocals(CVMFrameIterator *iter);
+CVMObjectICell *
+CVMframeIterateSyncObject(CVMFrameIterator *iter);
+CVMMethodBlock *
+CVMgetCallerMb(CVMFrame* frame, int skip);
+void
+CVMframeSetContextArtificial(CVMExecEnv *ee);
+extern CVMBool
+CVMisAssignable(CVMExecEnv* ee, CVMClassBlock* srcCb,
+  CVMClassBlock* dstCb);
+extern CVMBool
+CVMgcUnsafeIsInstanceOf(CVMExecEnv* ee, CVMObject* obj,
+   CVMClassBlock* cb);
+extern CVMBool
+CVMisSubclassOf(CVMExecEnv* ee, CVMClassBlock* subclasscb,
+  CVMClassBlock* cb);
+extern CVMBool
+CVMextendsClass(CVMExecEnv* ee, CVMClassBlock* subclasscb, CVMClassBlock* cb);
+extern CVMBool
+CVMimplementsInterface(CVMExecEnv* ee, CVMClassBlock* cb,
+         CVMClassBlock* interfacecb);
+CVMBool
+CVMverifyClassAccess(CVMExecEnv* ee,
+       CVMClassBlock* currentClass, CVMClassBlock* newClass,
+       CVMBool resolverAccess);
+extern CVMBool
+CVMverifyMemberAccess3(CVMExecEnv* ee,
+                       CVMClassBlock* currentClass,
+                       CVMClassBlock* resolvedClass,
+                       CVMClassBlock* memberClass,
+                       CVMUint32 access, CVMBool resolverAccess,
+                       CVMBool protectedRestriction);
+extern CVMBool
+CVMverifyMemberAccess2(CVMExecEnv* ee,
+         CVMClassBlock* currentClass,
+         CVMClassBlock* memberClass,
+         CVMUint32 access, CVMBool resolverAccess,
+         CVMBool protectedRestriction);
+CVMBool
+CVMverifyMemberAccess(CVMExecEnv* ee,
+        CVMClassBlock* currentClass,
+        CVMClassBlock* memberClass,
+        int access, CVMBool resolverAccess);
+extern CVMBool
+CVMisTrustedClassLoader(CVMExecEnv* ee, CVMClassLoaderICell* loader);
+extern void
+CVMmultiArrayAlloc(CVMExecEnv* ee,
+     CVMInt32 nDimensions,
+     CVMStackVal32* dimensions,
+     CVMClassBlock* arrayCb,
+     CVMObjectICell* resultCell);
+extern void
+CVMdisableRemoteExceptions(CVMExecEnv* ee);
+extern void
+CVMenableRemoteExceptions(CVMExecEnv* ee);
+extern CVMBool
+CVMremoteExceptionsDisabled(CVMExecEnv* ee);
+extern void
+CVMfillInStackTrace(CVMExecEnv *ee, CVMThrowableICell* objICell);
+extern void
+CVMprintStackTrace(CVMExecEnv *ee, CVMThrowableICell* throwableICell,
+     CVMObjectICell* printableICell);
+typedef enum {
+    CVM_QUICKEN_SUCCESS_OPCODE_ONLY,
+    CVM_QUICKEN_SUCCESS_OPCODE_AND_OPERANDS,
+    CVM_QUICKEN_NEED_TO_RUN_STATIC_INITIALIZERS,
+    CVM_QUICKEN_ALREADY_QUICKENED,
+    CVM_QUICKEN_ERROR
+} CVMQuickenReturnCode;
+extern CVMQuickenReturnCode
+CVMquickenOpcode(CVMExecEnv* ee, CVMUint8* pc,
+   CVMConstantPool* cp, CVMClassBlock** p_cb,
+   CVMBool clobbersCpIndex);
+extern CVMBool
+CVMisSpecialSuperCall(CVMClassBlock* currClass, CVMMethodBlock* mb);
+CVMMethodBlock*
+CVMlookupSpecialSuperMethod(CVMExecEnv* ee,
+       CVMClassBlock* currClass,
+       CVMMethodTypeID methodID);
+extern CVMBool
+CVMclassIsOKToInstantiate(CVMExecEnv *ee, CVMClassBlock *cb);
+extern CVMBool
+CVMfieldHasNotChangeStaticState(CVMExecEnv *ee, CVMFieldBlock *fb,
+                                CVMBool expectToBeStatic);
+extern CVMBool
+CVMfieldIsOKToWriteTo(CVMExecEnv *ee, CVMFieldBlock *fb,
+        CVMClassBlock *currentCb, CVMBool okToThrow);
+extern CVMBool
+CVMmethodHasNotChangeStaticState(CVMExecEnv *ee, CVMMethodBlock *mb,
+                                 CVMBool expectToBeStatic);
+extern void
+CVMinitStats();
+extern void
+CVMdumpStats();
+extern void
+CVMlocksForGCAcquire(CVMExecEnv* ee);
+extern void
+CVMlocksForGCRelease(CVMExecEnv* ee);
+extern CVMBool CVMsuspendCheckerInit();
+extern void CVMsuspendCheckerDestroy();
+extern CVMBool CVMsuspendCheckerIsOK(CVMExecEnv *ee, CVMExecEnv *targetEE);
+extern void
+CVMlocksForThreadSuspendAcquire(CVMExecEnv* ee);
+extern void
+CVMlocksForThreadSuspendRelease(CVMExecEnv* ee);
+extern void
+CVMthreadSuspendConsistentRequest(CVMExecEnv* ee);
+extern void
+CVMthreadSuspendConsistentRelease(CVMExecEnv* ee);
+typedef enum {
+    CVM_MangleMethodName_JNI_SHORT,
+    CVM_MangleMethodName_JNI_LONG,
+    CVM_MangleMethodName_CNI_SHORT
+} CVMMangleType;
+extern char*
+CVMmangleMethodName(CVMExecEnv* ee, CVMMethodBlock* mb,
+      CVMMangleType mangleType);
+extern CVMBool
+CVMlookupNativeMethodCode(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern void CVMwaitForUserThreads(CVMExecEnv *ee);
+extern void CVMwaitForAllThreads(CVMExecEnv *ee);
+extern int CVMprepareToExit(void);
+extern int CVMatExit(void (*func)(void));
+extern void CVMexit(int);
+extern void CVMabort(void);
+extern CVMBool CVMsafeExit(CVMExecEnv *ee, CVMInt32 status);
+extern void
+CVMunloadApplicationclasses(CVMExecEnv* ee);
+extern void CVMtraceInit();
+extern void CVMtraceReset(CVMUint32 old, CVMUint32 nnew);
+extern void CVMtraceMethodCall(CVMExecEnv *ee,
+          CVMFrame* frame, CVMBool isJump);
+extern void CVMtraceMethodReturn(CVMExecEnv *ee, CVMFrame* frame);
+extern void CVMtraceFramelessMethodCall(CVMExecEnv *ee,
+            CVMFrame* frame, CVMMethodBlock *mb,
+     CVMBool isJump);
+extern void CVMtraceFramelessMethodReturn(CVMExecEnv *ee, CVMMethodBlock *mb,
+       CVMFrame* frame);
+CVMBool
+CVMsyncReturnHelper(CVMExecEnv *ee, CVMFrame *frame, CVMObjectICell *objICell,
+      CVMBool areturn);
+CVMUint32
+CVMregisterReturnEvent(CVMExecEnv *ee, CVMUint8* pc, CVMUint32 ret_opcode,
+         jvalue *retValue);
+CVMUint32
+CVMregisterReturnEventPC(CVMExecEnv *ee, CVMUint8* pc,
+    jvalue *retValue);
+CVMBool
+CVMinvokeJNIHelper(CVMExecEnv *ee, CVMMethodBlock *mb);
+void CVMpostThreadStartEvents(CVMExecEnv *ee);
+void CVMpostThreadExitEvents(CVMExecEnv *ee);
+void
+CVMcopyRefArrays(CVMExecEnv* ee,
+   CVMArrayOfRef* srcArr, jint src_pos,
+   CVMArrayOfRef* dstArr, jint dst_pos,
+   CVMClassBlock* dstElemCb, jint length);
+CVMBool CVMmaskInterrupts(CVMExecEnv *ee);
+void CVMunmaskInterrupts(CVMExecEnv *ee);
+typedef struct CVMPackage CVMPackage;
+struct CVMPackage {
+    char *packageName;
+    char *filename;
+    CVMPackage* next;
+};
+extern char*
+CVMpackagesGetEntry(const char* name);
+extern CVMBool
+CVMpackagesAddEntry(const char *name, const char *filename);
+extern void
+CVMpackagesDestroy();
+typedef jint ( *JVM_OnLoad_t)(JavaVM *, char *, void *);
+typedef void ( *JVM_OnUnload_t)(JavaVM *);
+typedef struct CVMXrunItem {
+    jobject shareLibRef;
+    JVM_OnUnload_t onUnloadFunc;
+} CVMXrunItem;
+typedef struct CVMXrunTable {
+    CVMInt32 elemIdx;
+    CVMInt32 elemCnt;
+    CVMXrunItem *table;
+} CVMXrunTable;
+extern CVMBool
+CVMXrunInitTable(CVMXrunTable *onUnloadTable, CVMInt32 numXrunArguments);
+extern void
+CVMXrunAppendToTable(CVMXrunTable *onUnloadTable, jobject libRef,
+       JVM_OnUnload_t fptr);
+extern void
+CVMXrunProcessTable(CVMXrunTable *onUnloadTable, JNIEnv *env, JavaVM *vm);
+extern CVMBool
+CVMXrunHandleArgument(CVMXrunTable *onUnloadTable, JNIEnv* env, char* arg);
+typedef jint ( *Agent_OnLoad_t)(JavaVM *, char *, void *);
+typedef void ( *Agent_OnUnload_t)(JavaVM *);
+typedef struct CVMAgentlibArg {
+  char *str;
+  CVMBool is_absolute;
+} CVMAgentlibArg_t;
+typedef struct CVMAgentItem {
+    void *libHandle;
+    Agent_OnUnload_t onUnloadFunc;
+} CVMAgentItem;
+typedef struct CVMAgentTable {
+    CVMInt32 elemIdx;
+    CVMInt32 elemCnt;
+    CVMAgentItem *table;
+} CVMAgentTable;
+extern CVMBool
+CVMAgentInitTable(CVMAgentTable *table, CVMInt32 numAgentArguments);
+extern void
+CVMAgentAppendToTable(CVMAgentTable *table, void *libHandle,
+        Agent_OnUnload_t fptr);
+extern void
+CVMAgentProcessTableUnload(CVMAgentTable *agentTable,
+      JNIEnv *env, JavaVM *vm);
+extern CVMBool
+CVMAgentHandleArgument(CVMAgentTable *agentTable, JNIEnv* env,
+         CVMAgentlibArg_t* arg);
+enum {
+    CVM_HEAPSTATEOBJ_INITIAL = 0,
+    CVM_HEAPSTATEOBJ_FREED
+};
+typedef struct CVMHeapStateObject CVMHeapStateObject;
+struct CVMHeapStateObject
+{
+    CVMObject *obj;
+    CVMUint32 size;
+};
+typedef struct CVMHeapState CVMHeapState;
+struct CVMHeapState
+{
+    CVMHeapState *next;
+    char *name;
+    CVMUint32 id;
+    CVMUint32 timeStamp;
+    CVMUint32 numberOfObjects;
+    CVMUint32 totalSize;
+    CVMHeapStateObject objects[1];
+};
+typedef struct CVMInspector CVMInspector;
+struct CVMInspector {
+    CVMBool keepAllObjectsAlive;
+    CVMBool hasCapturedState;
+    CVMUint32 lastHeapStateID;
+    CVMHeapState *heapStates;
+};
+void CVMinspectorGCLockerUnlock(CVMGCLocker *self, CVMExecEnv *current_ee);
+void CVMinspectorGCLockerWait(CVMGCLocker *self, CVMExecEnv *current_ee);
+extern CVMBool CVMgcIsValidObject(CVMExecEnv *ee, CVMObject *obj);
+CVMBool CVMgcDisableGC(void);
+CVMBool CVMgcEnableGC(void);
+CVMBool CVMgcIsDisabled(void);
+void CVMgcKeepAllObjectsAlive(CVMBool keepAlive);
+void CVMgcDumpObjectReferences(CVMObject *obj);
+void CVMgcDumpClassReferences(const char *clazzname);
+void CVMgcDumpClassBlocks(const char *clazzname);
+void CVMgcDumpObjectGCRoots(CVMObject *obj);
+extern void
+CVMgcDumpHeapSimple();
+extern void
+CVMgcDumpHeapVerbose();
+extern void
+CVMgcDumpHeapStats();
+enum {
+    CVM_HEAPSTATE_SORT_NONE = 0,
+    CVM_HEAPSTATE_SORT_BY_OBJ,
+    CVM_HEAPSTATE_SORT_BY_OBJCLASS
+};
+extern void
+CVMgcCaptureHeapState(const char *name);
+extern void
+CVMgcReleaseHeapState(CVMUint32 id);
+extern void
+CVMgcReleaseAllHeapState(void);
+extern void
+CVMgcListHeapStates(void);
+extern void
+CVMgcDumpHeapState(CVMUint32 id, int sortKey);
+extern void
+CVMgcCompareHeapState(CVMUint32 id1, CVMUint32 id2);
+extern void
+CVMgcHeapStateObjectMoved(CVMObject *oldObj, CVMObject *newObj);
+extern void
+CVMgcHeapStateObjectFreed(CVMObject *obj);
+extern void CVMdumpObject(CVMObject* directObj);
+extern void CVMdumpClassBlock(CVMClassBlock *cb);
+extern void CVMdumpString(CVMObject *string);
+extern void CVMdumpObjectReferences(CVMObject *obj);
+extern void CVMdumpClassReferences(const char *clazzname);
+extern void CVMdumpClassBlocks(const char *clazzname);
+extern void CVMdumpObjectGCRoots(CVMObject *obj);
+extern void CVMdumpSysInfo();
+typedef void (*pProc)(void);
+typedef struct exit_proc {
+    pProc proc;
+    struct exit_proc *next;
+} * exit_procPtr;
+typedef void (*loopProcPtr)(CVMExecEnv*, CVMMethodBlock *, CVMBool, CVMBool);
+struct CVMOptions {
+    void *vfprintfHook;
+    void *exitHook;
+    void *abortHook;
+    void *safeExitHook;
+    CVMBool timeStampEnabled;
+    const char *startHeapSizeStr;
+    const char *minHeapSizeStr;
+    const char *maxHeapSizeStr;
+    const char *nativeStackSizeStr;
+    const char *gcAttributesStr;
+    const char *optAttributesStr;
+    const char *traceFlagsStr;
+    CVMBool debugging;
+    CVMUint16 classVerificationLevel;
+    const char *bootclasspathStr;
+    const char *appclasspathStr;
+    CVMBool fullShutdownFlag;
+    CVMBool javaAssertionsUserDefault;
+    CVMBool javaAssertionsSysDefault;
+    CVMJavaAssertionsOptionList* javaAssertionsClasses;
+    CVMJavaAssertionsOptionList* javaAssertionsPackages;
+};
+struct CVMGlobalState {
+    CVMUint32** allocPtrPtr;
+    CVMUint32** allocTopPtr;
+    CVMAddr unused1;
+    CVMUint32 debugFlags;
+    CVMUint32 unused3;
+    CVMUint32 unused4;
+    CVMCState cstate[CVM_NUM_CONSISTENT_STATES];
+    CVMMutex objGlobalMicroLock;
+    CVMSysMutex globalRootsLock;
+    CVMStack globalRoots;
+    CVMSysMutex weakGlobalRootsLock;
+    CVMStack weakGlobalRoots;
+    CVMStack classGlobalRoots;
+    CVMStack classLoaderGlobalRoots;
+    CVMStack protectionDomainGlobalRoots;
+    CVMStack classTable;
+    CVMClassBlock* freeClassList;
+    CVMClassLoaderICell* freeClassLoaderList;
+    CVMSysMutex classTableLock;
+    CVMLoaderCacheEntry** loaderCache;
+    CVMLoaderConstraint** loaderConstraints;
+    CVMSysMutex loaderCacheLock;
+    CVMSysMutex heapLock;
+    CVMSysMutex nullClassLoaderLock;
+    CVMSysMutex jvmtiLock;
+    CVMSysMutex jvmtiLockInfoLock;
+    CVMTargetGlobalState target;
+    CVMUint32 maxHeapSize;
+    CVMGCLocker inspectorGCLocker;
+    CVMCondVar gcLockerCV;
+    CVMSysMutex gcLockerLock;
+    CVMGCCommonGlobalState gcCommon;
+    CVMGCGlobalState gc;
+    CVMJNIJavaVM javaVM;
+    CVMExecEnv mainEE;
+    CVMSysMutex threadLock;
+    CVMExecEnv *threadList;
+    CVMUint32 userThreadCount;
+    CVMUint32 threadCount;
+    CVMCondVar threadCountCV;
+    CVMUint32 threadIDCount;
+    CVMSysMutex syncLock;
+    CVMObjMonitor *objLocksBound;
+    CVMObjMonitor *objLocksUnbound;
+    CVMObjMonitor *objLocksFree;
+    CVMMutex sysMicroLock[CVM_NUM_SYS_MICROLOCKS];
+    CVMMethodTypeID initTid;
+    CVMMethodTypeID clinitTid;
+    CVMMethodTypeID finalizeTid;
+    CVMMethodTypeID cloneTid;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedAction1;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedExceptionAction1;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedAction2;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedExceptionAction2;
+    CVMMethodBlock* java_lang_ref_Finalizer_register;
+    CVMJavaVal32* java_lang_ref_Reference_lock;
+    CVMJavaVal32* java_lang_ref_Reference_pending;
+    CVMBool referenceWorkTODO;
+    CVMMethodBlock* java_lang_Class_runStaticInitializers;
+    CVMMethodBlock* java_lang_Class_newInstance;
+    CVMMethodBlock* java_lang_reflect_Constructor_newInstance;
+    CVMMethodBlock* java_lang_reflect_Method_invoke;
+    CVMMethodTypeID printlnTid;
+    CVMMethodBlock* java_lang_Throwable_fillInStackTrace;
+    CVMFieldBlock* java_lang_System_out;
+    CVMMethodBlock* java_lang_ClassLoader_NativeLibrary_getFromClass;
+    CVMMethodBlock* java_lang_ClassLoader_addClass;
+    CVMMethodBlock* java_lang_ClassLoader_loadClass;
+    CVMMethodBlock* java_lang_ClassLoader_findNative;
+    CVMMethodBlock* java_lang_ClassLoader_checkPackageAccess;
+    CVMMethodBlock* java_lang_ClassLoader_loadBootstrapClass;
+    CVMMethodBlock* java_lang_Class_loadSuperClasses;
+    CVMMethodBlock* java_lang_Shutdown_waitAllUserThreadsExitAndShutdown;
+    CVMMethodBlock* sun_misc_ThreadRegistry_waitAllSystemThreadsExit;
+    CVMMethodBlock* java_lang_Thread_exit;
+    CVMMethodBlock* java_lang_Thread_initMainThread;
+    CVMMethodBlock* java_lang_Thread_initAttachedThread;
+    CVMMethodBlock* java_lang_Thread_nextThreadNum;
+    CVMClassLoaderICell* systemClassLoader;
+    CVMClassPath bootClassPath;
+    CVMClassPath appClassPath;
+    CVMUint16 classVerificationLevel;
+    void* cvmDynHandle;
+    CVMMethodBlock* sun_misc_Launcher_AppClassLoader_setExtInfo;
+    CVMMethodBlock* sun_misc_Launcher_ClassContainer_init;
+    CVMMethodBlock* sun_misc_Launcher_ClassContainer_init_withClass;
+    CVMMethodBlock* sun_misc_Launcher_getFileURL;
+    CVMMethodBlock* java_io_File_init;
+    CVMMethodBlock* java_util_jar_JarFile_init;
+    CVMMethodBlock* java_security_CodeSource_init;
+    CVMMethodBlock* java_security_SecureClassLoader_getProtectionDomain;
+    CVMMethodBlock* java_lang_ClassLoader_checkCerts;
+    CVMPackage* packages[31];
+    CVMUint16 numPackages;
+    CVMJvmtiGlobals jvmti;
+    CVMSysMutex typeidLock;
+    CVMUint32 typeIDscalarSegmentSize;
+    CVMUint32 typeIDmethodTypeSegmentSize;
+    CVMUint32 typeIDmemberNameSegmentSize;
+    CVMSysMutex internLock;
+    CVMUint32 stringInternSegmentSizeIdx;
+    CVMInt32 lastRandom;
+    CVMThrowableICell* preallocatedOutOfMemoryError;
+    CVMThrowableICell* preallocatedStackOverflowError;
+    CVMParsedSubOptions parsedSubOptions;
+    struct {
+ CVMUint32 nativeStackSize;
+ CVMUint32 javaStackMinSize;
+ CVMUint32 javaStackMaxSize;
+ CVMUint32 javaStackChunkSize;
+    } config;
+    void *vfprintfHook;
+    void (*exitHook)(int);
+    void (*abortHook)();
+    void (*safeExitHook)(int);
+    CVMBool abort_entered;
+    CVMBool timeStampEnabled;
+    CVMSysMutex timestampListLock;
+    CVMInt64 firstWallclockTime;
+    CVMBool fullShutdown;
+    CVMXrunTable onUnloadTable;
+    CVMAgentTable agentTable;
+    exit_procPtr exit_procs;
+    CVMObject* discoveredSoftRefs;
+    CVMObject* discoveredWeakRefs;
+    CVMObject* discoveredFinalRefs;
+    CVMObject* discoveredPhantomRefs;
+    CVMObject* deferredWeakrefs;
+    CVMObject* deferredWeakrefsToClear;
+    CVMObject* deferredWeakrefsToAddToPending;
+    CVMBool suspendCheckerInitialized;
+    CVMThreadID suspendCheckerThreadInfo;
+    volatile CVMUint32 suspendCheckerState;
+    CVMMutex suspendCheckerLock;
+    CVMCondVar suspendCheckerCV;
+    CVMCondVar suspendCheckerAckCV;
+    CVMBool measureGC;
+    CVMInt64 totalGCTime;
+    CVMInt64 startGCTime;
+    CVMInt64 initFreeMemory;
+    CVMBool javaAssertionsUserDefault;
+    CVMBool javaAssertionsSysDefault;
+    CVMJavaAssertionsOptionList* javaAssertionsClasses;
+    CVMJavaAssertionsOptionList* javaAssertionsPackages;
+    CVMBool userHomePropSpecified;
+    CVMBool userNamePropSpecified;
+    CVMInspector inspector;
+    loopProcPtr CVMgcUnsafeExecuteJavaMethodProcPtr;
+};
+extern void
+CVMoptPrintUsage();
+extern CVMBool
+CVMoptParseXoptOptions(const char* optAttributesStr);
+extern CVMBool
+CVMoptParseXssOption(const char* optAttributesStr);
+extern void CVMdumpGlobalsSubOptionValues();
+extern CVMGlobalState CVMglobals;
+extern CVMBool
+CVMinitVMGlobalState(CVMGlobalState *, CVMOptions *options);
+extern void
+CVMdestroyVMGlobalState(CVMExecEnv *ee, CVMGlobalState *);
+extern void
+CVMglobalSysMutexesAcquire(CVMExecEnv* ee);
+extern void
+CVMglobalSysMutexesRelease(CVMExecEnv* ee);
+CVMJavaLong CVMjvm2Long(const CVMAddr location[2]);
+void CVMlong2Jvm(CVMAddr location[2], CVMJavaLong val);
+CVMJavaDouble CVMjvm2Double(const CVMAddr location[2]);
+void CVMdouble2Jvm(CVMAddr location[2], CVMJavaDouble val);
+void CVMmemCopy64(CVMUint32 *to, const CVMUint32 *from);
+extern CVMJavaDouble CVMlongBits2Double(CVMJavaLong val);
+extern CVMJavaLong CVMdouble2LongBits(CVMJavaDouble val);
+extern CVMJavaInt CVMlong2Int(CVMJavaLong val);
+extern CVMJavaFloat CVMlong2Float(CVMJavaLong val);
+extern CVMJavaDouble CVMlong2Double(CVMJavaLong val);
+extern void * CVMlong2VoidPtr(CVMJavaLong val);
+extern CVMJavaLong CVMvoidPtr2Long(void * val);
+extern CVMJavaLong CVMint2Long(CVMJavaInt val);
+extern CVMJavaLong CVMdouble2Long(CVMJavaDouble val);
+CVMJavaLong CVMlongAdd(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongAnd(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongDiv(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongMul(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongOr (CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongSub(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongXor(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongRem(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongUshr(CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongShl (CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongShr (CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongNeg(CVMJavaLong op);
+CVMJavaLong CVMlongNot(CVMJavaLong op);
+CVMInt32 CVMlongLtz(CVMJavaLong op);
+CVMInt32 CVMlongGez(CVMJavaLong op);
+CVMInt32 CVMlongEqz(CVMJavaLong op);
+CVMInt32 CVMlongEq(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongNe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongGe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongLe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongLt(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongGt(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongCompare(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongConstZero();
+CVMJavaLong CVMlongConstOne();
+CVMJavaInt CVMdouble2Int(CVMJavaDouble val);
+CVMJavaFloat CVMdouble2Float(CVMJavaDouble val);
+CVMJavaDouble CVMint2Double(CVMJavaInt val);
+CVMJavaDouble CVMdoubleAdd(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleSub(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleDiv(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleMul(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleRem(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleNeg(CVMJavaDouble op);
+CVMInt32 CVMdoubleCompare(CVMJavaDouble op1, CVMJavaDouble op2,
+     CVMInt32 direction);
+CVMJavaDouble CVMdoubleConstZero();
+CVMJavaDouble CVMdoubleConstOne();
+extern CVMJavaInt double2Int(CVMJavaDouble d);
+extern CVMJavaLong double2Long(CVMJavaDouble d);
+void* memalign(size_t alignment, size_t size);
+void free(void* memalignAllocedSpace);
+CVMBool CVMmemInit();
+size_t CVMmemPageSize();
+void *CVMmemMap(size_t requestedSize, size_t *mappedSize);
+void *CVMmemUnmap(void *addr, size_t requestedSize, size_t *unmappedSize);
+void *CVMmemCommit(void *addr, size_t requestedSize, size_t *committedSize);
+void *CVMmemDecommit(void *addr, size_t requestedSize,
+       size_t *decommittedSize);
+extern const CVMObjectICell CVMID_nullICell;
+enum CVMOpcode {
+    opc_nop = 0,
+    opc_aconst_null = 1,
+    opc_iconst_m1 = 2,
+    opc_iconst_0 = 3,
+    opc_iconst_1 = 4,
+    opc_iconst_2 = 5,
+    opc_iconst_3 = 6,
+    opc_iconst_4 = 7,
+    opc_iconst_5 = 8,
+    opc_lconst_0 = 9,
+    opc_lconst_1 = 10,
+    opc_fconst_0 = 11,
+    opc_fconst_1 = 12,
+    opc_fconst_2 = 13,
+    opc_dconst_0 = 14,
+    opc_dconst_1 = 15,
+    opc_bipush = 16,
+    opc_sipush = 17,
+    opc_ldc = 18,
+    opc_ldc_w = 19,
+    opc_ldc2_w = 20,
+    opc_iload = 21,
+    opc_lload = 22,
+    opc_fload = 23,
+    opc_dload = 24,
+    opc_aload = 25,
+    opc_iload_0 = 26,
+    opc_iload_1 = 27,
+    opc_iload_2 = 28,
+    opc_iload_3 = 29,
+    opc_lload_0 = 30,
+    opc_lload_1 = 31,
+    opc_lload_2 = 32,
+    opc_lload_3 = 33,
+    opc_fload_0 = 34,
+    opc_fload_1 = 35,
+    opc_fload_2 = 36,
+    opc_fload_3 = 37,
+    opc_dload_0 = 38,
+    opc_dload_1 = 39,
+    opc_dload_2 = 40,
+    opc_dload_3 = 41,
+    opc_aload_0 = 42,
+    opc_aload_1 = 43,
+    opc_aload_2 = 44,
+    opc_aload_3 = 45,
+    opc_iaload = 46,
+    opc_laload = 47,
+    opc_faload = 48,
+    opc_daload = 49,
+    opc_aaload = 50,
+    opc_baload = 51,
+    opc_caload = 52,
+    opc_saload = 53,
+    opc_istore = 54,
+    opc_lstore = 55,
+    opc_fstore = 56,
+    opc_dstore = 57,
+    opc_astore = 58,
+    opc_istore_0 = 59,
+    opc_istore_1 = 60,
+    opc_istore_2 = 61,
+    opc_istore_3 = 62,
+    opc_lstore_0 = 63,
+    opc_lstore_1 = 64,
+    opc_lstore_2 = 65,
+    opc_lstore_3 = 66,
+    opc_fstore_0 = 67,
+    opc_fstore_1 = 68,
+    opc_fstore_2 = 69,
+    opc_fstore_3 = 70,
+    opc_dstore_0 = 71,
+    opc_dstore_1 = 72,
+    opc_dstore_2 = 73,
+    opc_dstore_3 = 74,
+    opc_astore_0 = 75,
+    opc_astore_1 = 76,
+    opc_astore_2 = 77,
+    opc_astore_3 = 78,
+    opc_iastore = 79,
+    opc_lastore = 80,
+    opc_fastore = 81,
+    opc_dastore = 82,
+    opc_aastore = 83,
+    opc_bastore = 84,
+    opc_castore = 85,
+    opc_sastore = 86,
+    opc_pop = 87,
+    opc_pop2 = 88,
+    opc_dup = 89,
+    opc_dup_x1 = 90,
+    opc_dup_x2 = 91,
+    opc_dup2 = 92,
+    opc_dup2_x1 = 93,
+    opc_dup2_x2 = 94,
+    opc_swap = 95,
+    opc_iadd = 96,
+    opc_ladd = 97,
+    opc_fadd = 98,
+    opc_dadd = 99,
+    opc_isub = 100,
+    opc_lsub = 101,
+    opc_fsub = 102,
+    opc_dsub = 103,
+    opc_imul = 104,
+    opc_lmul = 105,
+    opc_fmul = 106,
+    opc_dmul = 107,
+    opc_idiv = 108,
+    opc_ldiv = 109,
+    opc_fdiv = 110,
+    opc_ddiv = 111,
+    opc_irem = 112,
+    opc_lrem = 113,
+    opc_frem = 114,
+    opc_drem = 115,
+    opc_ineg = 116,
+    opc_lneg = 117,
+    opc_fneg = 118,
+    opc_dneg = 119,
+    opc_ishl = 120,
+    opc_lshl = 121,
+    opc_ishr = 122,
+    opc_lshr = 123,
+    opc_iushr = 124,
+    opc_lushr = 125,
+    opc_iand = 126,
+    opc_land = 127,
+    opc_ior = 128,
+    opc_lor = 129,
+    opc_ixor = 130,
+    opc_lxor = 131,
+    opc_iinc = 132,
+    opc_i2l = 133,
+    opc_i2f = 134,
+    opc_i2d = 135,
+    opc_l2i = 136,
+    opc_l2f = 137,
+    opc_l2d = 138,
+    opc_f2i = 139,
+    opc_f2l = 140,
+    opc_f2d = 141,
+    opc_d2i = 142,
+    opc_d2l = 143,
+    opc_d2f = 144,
+    opc_i2b = 145,
+    opc_i2c = 146,
+    opc_i2s = 147,
+    opc_lcmp = 148,
+    opc_fcmpl = 149,
+    opc_fcmpg = 150,
+    opc_dcmpl = 151,
+    opc_dcmpg = 152,
+    opc_ifeq = 153,
+    opc_ifne = 154,
+    opc_iflt = 155,
+    opc_ifge = 156,
+    opc_ifgt = 157,
+    opc_ifle = 158,
+    opc_if_icmpeq = 159,
+    opc_if_icmpne = 160,
+    opc_if_icmplt = 161,
+    opc_if_icmpge = 162,
+    opc_if_icmpgt = 163,
+    opc_if_icmple = 164,
+    opc_if_acmpeq = 165,
+    opc_if_acmpne = 166,
+    opc_goto = 167,
+    opc_jsr = 168,
+    opc_ret = 169,
+    opc_tableswitch = 170,
+    opc_lookupswitch = 171,
+    opc_ireturn = 172,
+    opc_lreturn = 173,
+    opc_freturn = 174,
+    opc_dreturn = 175,
+    opc_areturn = 176,
+    opc_return = 177,
+    opc_getstatic = 178,
+    opc_putstatic = 179,
+    opc_getfield = 180,
+    opc_putfield = 181,
+    opc_invokevirtual = 182,
+    opc_invokespecial = 183,
+    opc_invokestatic = 184,
+    opc_invokeinterface = 185,
+    opc_xxxunusedxxx = 186,
+    opc_new = 187,
+    opc_newarray = 188,
+    opc_anewarray = 189,
+    opc_arraylength = 190,
+    opc_athrow = 191,
+    opc_checkcast = 192,
+    opc_instanceof = 193,
+    opc_monitorenter = 194,
+    opc_monitorexit = 195,
+    opc_wide = 196,
+    opc_multianewarray = 197,
+    opc_ifnull = 198,
+    opc_ifnonnull = 199,
+    opc_goto_w = 200,
+    opc_jsr_w = 201,
+    opc_breakpoint = 202,
+    opc_aldc_ind_quick = 203,
+    opc_aldc_ind_w_quick = 204,
+    opc_invokestatic_quick = 205,
+    opc_invokestatic_checkinit_quick = 206,
+    opc_invokevirtual_quick = 207,
+    opc_getfield_quick = 208,
+    opc_agetfield_quick = 209,
+    opc_vinvokevirtual_quick = 210,
+    opc_invokevirtual_quick_w = 211,
+    opc_putfield_quick = 212,
+    opc_invokenonvirtual_quick = 213,
+    opc_invokesuper_quick = 214,
+    opc_invokeignored_quick = 215,
+    opc_getfield2_quick = 216,
+    opc_checkcast_quick = 217,
+    opc_instanceof_quick = 218,
+    opc_nonnull_quick = 219,
+    opc_putfield2_quick = 220,
+    opc_ainvokevirtual_quick = 221,
+    opc_invokevirtualobject_quick = 222,
+    opc_invokeinterface_quick = 223,
+    opc_aldc_quick = 224,
+    opc_ldc_quick = 225,
+    opc_exittransition = 226,
+    opc_dinvokevirtual_quick = 227,
+    opc_aldc_w_quick = 228,
+    opc_ldc_w_quick = 229,
+    opc_aputfield_quick = 230,
+    opc_getfield_quick_w = 231,
+    opc_ldc2_w_quick = 232,
+    opc_agetstatic_quick = 233,
+    opc_getstatic_quick = 234,
+    opc_getstatic2_quick = 235,
+    opc_aputstatic_quick = 236,
+    opc_putstatic_quick = 237,
+    opc_putstatic2_quick = 238,
+    opc_agetstatic_checkinit_quick = 239,
+    opc_getstatic_checkinit_quick = 240,
+    opc_getstatic2_checkinit_quick = 241,
+    opc_aputstatic_checkinit_quick = 242,
+    opc_putstatic_checkinit_quick = 243,
+    opc_putstatic2_checkinit_quick = 244,
+    opc_putfield_quick_w = 245,
+    opc_new_checkinit_quick = 246,
+    opc_new_quick = 247,
+    opc_anewarray_quick = 248,
+    opc_multianewarray_quick = 249,
+    opc_prefix = 250
+};
+extern const char* const CVMopnames[];
+extern const char CVMopcodeLengths[];
+extern CVMUint32 CVMopcodeGetLengthVariable(const CVMUint8* iStream);
+typedef enum CVMOpcode CVMOpcode;
+extern int
+CVMopcodeGetLengthWithBoundsCheckVariable(const unsigned char* iStream,
+       const unsigned char* iStream_end);
+typedef CVMFreelistFrame CVMGlobalRootsFrame;
+extern CVMObjectICell*
+CVMID_getGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getClassGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getClassLoaderGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getProtectionDomainGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getWeakGlobalRoot(CVMExecEnv* ee);
+extern void
+CVMID_freeGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeClassGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeClassLoaderGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeProtectionDomainGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeWeakGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern CVMFrameGCScannerFunc CVMglobalrootFrameScanner;
+typedef void CVMThrowFunc(CVMExecEnv *, const char *format, ...);
+extern CVMThrowFunc CVMthrowClassCircularityError;
+extern CVMThrowFunc CVMthrowClassFormatError;
+extern CVMThrowFunc CVMthrowIllegalAccessError;
+extern CVMThrowFunc CVMthrowInstantiationError;
+extern CVMThrowFunc CVMthrowLinkageError;
+extern CVMThrowFunc CVMthrowUnsupportedClassVersionError;
+extern CVMThrowFunc CVMthrowVerifyError;
+extern CVMThrowFunc CVMthrowUnsatisfiedLinkError;
+extern CVMThrowFunc CVMthrowNegativeArraySizeException;
+extern CVMThrowFunc CVMthrowNoSuchFieldException;
+extern CVMThrowFunc CVMthrowNoSuchMethodException;
+extern CVMThrowFunc CVMthrowIncompatibleClassChangeError;
+extern CVMThrowFunc CVMthrowAbstractMethodError;
+extern CVMThrowFunc CVMthrowArithmeticException;
+extern CVMThrowFunc CVMthrowArrayIndexOutOfBoundsException;
+extern CVMThrowFunc CVMthrowArrayStoreException;
+extern CVMThrowFunc CVMthrowClassCastException;
+extern CVMThrowFunc CVMthrowClassNotFoundException;
+extern CVMThrowFunc CVMthrowCloneNotSupportedException;
+extern CVMThrowFunc CVMthrowIllegalAccessException;
+extern CVMThrowFunc CVMthrowIllegalArgumentException;
+extern CVMThrowFunc CVMthrowIllegalMonitorStateException;
+extern CVMThrowFunc CVMthrowIllegalStateException;
+extern CVMThrowFunc CVMthrowInstantiationException;
+extern CVMThrowFunc CVMthrowInternalError;
+extern CVMThrowFunc CVMthrowInterruptedException;
+extern CVMThrowFunc CVMthrowNoClassDefFoundError;
+extern CVMThrowFunc CVMthrowNoSuchFieldError;
+extern CVMThrowFunc CVMthrowNoSuchMethodError;
+extern CVMThrowFunc CVMthrowNullPointerException;
+extern CVMThrowFunc CVMthrowOutOfMemoryError;
+extern CVMThrowFunc CVMthrowStackOverflowError;
+extern CVMThrowFunc CVMthrowStringIndexOutOfBoundsException;
+extern CVMThrowFunc CVMthrowUnsupportedOperationException;
+extern CVMThrowFunc CVMthrowInvalidClassException;
+extern CVMThrowFunc CVMthrowIOException;
+extern CVMThrowFunc CVMthrowConversionBufferFullException;
+extern CVMThrowFunc CVMthrowUnknownCharacterException;
+extern CVMThrowFunc CVMthrowMalformedInputException;
+CVMJavaFloat CVMfloatAdd(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatSub(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatMul(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatDiv(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatRem(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatNeg(CVMJavaFloat op);
+CVMInt32 CVMfloatCompare(CVMJavaFloat op1, CVMJavaFloat op2,
+    CVMInt32 direction);
+CVMJavaInt CVMfloat2Int(CVMJavaFloat op);
+CVMJavaDouble CVMfloat2Double(CVMJavaFloat op);
+extern CVMJavaLong CVMfloat2Long(CVMJavaFloat op);
+extern void setFPMode(void);
+extern CVMJavaInt float2Int(CVMJavaFloat d);
+extern CVMJavaLong float2Long(CVMJavaFloat d);
+CVMJavaInt CVMintAdd(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintSub(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintMul(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintDiv(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintRem(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintAnd(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintOr (CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintXor(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintNeg(CVMJavaInt op);
+CVMJavaInt CVMintUshr(CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintShl (CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintShr (CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintNeg(CVMJavaInt op);
+CVMJavaFloat CVMint2Float(CVMJavaInt val);
+CVMJavaByte CVMint2Byte(CVMJavaInt val);
+CVMJavaChar CVMint2Char(CVMJavaInt val);
+CVMJavaShort CVMint2Short(CVMJavaInt val);
+CVMUint16 CVMgetUint16(const CVMUint8 *ptr);
+CVMUint32 CVMgetUint32(const CVMUint8 *ptr);
+CVMInt16 CVMgetInt16(const CVMUint8 *ptr);
+CVMInt32 CVMgetInt32(const CVMUint8 *ptr);
+static void CVMdoubleAddHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) + (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleSubHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) - (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleMulHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) * (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleDivHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) / (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleRemHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = CVMdoubleRem(l1, l2); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static CVMBool CVMlongAddHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) + (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongSubHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) - (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongMulHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) * (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongDivHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (1 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) / (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongRemHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (1 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) % (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongAndHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) & (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongOrHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) | (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongXorHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) ^ (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static void CVMlongShlHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = ((v) << (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void CVMlongShrHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = ((v) >> (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void CVMlongUshrHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = (((unsigned long long)(v)) >> (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void
+CVMlongNegHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong r;
+    r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    r = (-(r));
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = r; };
+}
+static void
+CVMlongCmpHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong value1, value2;
+    value1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); });
+    value2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    (((topOfStack[-4].s).j).i) = ((((value1)) < ((value2))) ? -1 : (((value1)) > ((value2))) ? 1 : 0);
+}
+static void
+CVMdoubleNegHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r;
+    r = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r = (-(r));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = r; };
+}
+static void
+CVMdoubleCmpHelper(CVMStackVal32* topOfStack, int direction)
+{
+    CVMJavaDouble value1, value2;
+    value1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); });
+    value2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    (((topOfStack[-4].s).j).i) = CVMdoubleCompare(value1, value2, direction);
+}
+static void
+CVMd2lHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r1;
+    CVMJavaLong r2;
+    r1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r2 = double2Long((r1));
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = r2; };
+}
+static void
+CVMd2iHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r1;
+    CVMJavaInt r2;
+    r1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r2 = (double2Int(r1));
+    (((topOfStack[-2].s).j).i) = r2;
+}
+static void
+CVMl2dHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong r1;
+    CVMJavaDouble r2;
+    r1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    r2 = ((CVMJavaDouble)(r1));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = r2; };
+}
+static void
+CVMi2dHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r;
+    r = ((CVMJavaDouble)((((topOfStack[-1].s).j).i)));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d = r; };
+}
+static CVMInt32
+CVMtableswitchHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack, CVMUint8* pc,
+       CVMFrame* frame)
+{
+    CVMInt32* lpc = (CVMInt32*)(((CVMAddr)(pc+1) + 3) & ~3);
+    CVMInt32 key = (((topOfStack[-1].s).j).i);
+    CVMInt32 low = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+    CVMInt32 high = (CVMInt32)((*((CVMInt32*)(&lpc[2])) << 24) | ((*((CVMInt32*)(&lpc[2])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[2])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[2])) >> 24));
+    CVMInt32 skip;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ttableswitch %d [%d-%d]\n", key, low, high) : (void)0);
+    key -= low;
+    ;
+    skip = ((CVMUint32) key > high - low)
+ ? (CVMInt32)((*((CVMInt32*)(&lpc[0])) << 24) | ((*((CVMInt32*)(&lpc[0])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[0])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[0])) >> 24))
+ : (CVMInt32)((*((CVMInt32*)(&lpc[key + 3])) << 24) | ((*((CVMInt32*)(&lpc[key + 3])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[key + 3])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[key + 3])) >> 24));
+    return skip;
+}
+static CVMInt32
+CVMlookupswitchHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack, CVMUint8* pc,
+        CVMFrame* frame)
+{
+    CVMInt32* lpc = (CVMInt32*)(((CVMAddr)(pc+1) + 3) & ~3);
+    CVMInt32 key = (((topOfStack[-1].s).j).i);
+    CVMInt32 skip = (CVMInt32)((*((CVMInt32*)(lpc)) << 24) | ((*((CVMInt32*)(lpc)) & 0xff00) << 8) | ((*((CVMInt32*)(lpc)) >> 8) & 0xff00) | (*((CVMUint32*)(lpc)) >> 24));
+    CVMInt32 npairs = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlookupswitch %d\n", key) : (void)0);
+    while (--npairs >= 0) {
+ lpc += 2;
+ if (key == (CVMInt32)((*((CVMInt32*)(lpc)) << 24) | ((*((CVMInt32*)(lpc)) & 0xff00) << 8) | ((*((CVMInt32*)(lpc)) >> 8) & 0xff00) | (*((CVMUint32*)(lpc)) >> 24))) {
+     skip = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+     break;
+ }
+    }
+    ;
+    return skip;
+}
+static CVMBool
+CVManewarrayHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+     CVMClassBlock* elemCb)
+{
+    CVMJavaInt arrLen;
+    CVMArrayOfRef* directArr;
+    CVMClassBlock* arrCb;
+    arrLen = (((topOfStack[-1].s).j).i);
+    if (arrLen < 0) {
+ CVMthrowNegativeArraySizeException(ee, ((void *)0));
+ return (!(1 == 1));
+    }
+    { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1008
+    , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { arrCb = CVMclassGetArrayOf(ee, elemCb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1008
+    , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+      ;
+    if (arrCb == ((void *)0)) {
+ return (!(1 == 1));
+    }
+    directArr = (CVMArrayOfRef*)
+ CVMgcAllocNewArray(ee, CVM_T_CLASS, arrCb, arrLen);
+    if (directArr == ((void *)0)) {
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+ return (!(1 == 1));
+    }
+    (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1019, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = ((CVMObject*)directArr));
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tanewarray_quick %C => 0x%x\n", arrCb, directArr) : (void)0);
+    return (1 == 1);
+}
+static CVMBool
+CVMnewarrayHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+    CVMBasicType typeCode)
+{
+    CVMJavaInt arrLen;
+    CVMArrayOfAnyType* directArr;
+    CVMClassBlock* arrCb;
+    arrLen = (((topOfStack[-1].s).j).i);
+    if (arrLen < 0) {
+ CVMthrowNegativeArraySizeException(ee, ((void *)0));
+ return (!(1 == 1));
+    }
+    arrCb = (CVMClassBlock*)CVMbasicTypeArrayClassblocks[typeCode];
+    ((void)((arrCb != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1040, "arrCb != 0") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    directArr = (CVMArrayOfAnyType*)
+ CVMgcAllocNewArray(ee, typeCode, arrCb, arrLen);
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnewarray %C.%d => 0x%x\n", arrCb, arrLen, directArr) : (void)0);
+    ((void)((directArr == ((void *)0) || ((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000) != 0 ) && (((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)==0xc000)? CVMtypeidGetArrayDepthX(((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX)) : (((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)>>14))==1) && (((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)==0xc000)? CVMtypeidGetArrayBasetypeX(((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX)) : ((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0x3fff)) == CVMbasicTypeID[typeCode]))) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1052
+    , "directArr == NULL || CVMisArrayClassOfBasicType(CVMobjectGetClass(directArr), CVMbasicTypeID[typeCode])") || (CVMsystemPanic("CVMassertHook returned"), 0)))
+                                ;
+    (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1053, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = ((CVMObject*)directArr));
+    if (directArr == ((void *)0)) {
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+  return (!(1 == 1));
+    }
+    return (1 == 1);
+}
+static CVMBool
+CVMmultianewarrayHelper(CVMExecEnv* ee, CVMClassBlock* arrCb)
+{
+    CVMInt32 nDimensions;
+    CVMInt32 dimCount;
+    CVMInt32 effectiveNDimensions;
+    CVMObjectICell* resultCell;
+    CVMStack* stack = &ee->interpreterStack;
+    CVMFrame* frame;
+    CVMStackVal32* topOfStack;
+    CVMUint8* pc;
+    frame = stack->currentFrame;;
+    topOfStack = frame->topOfStack;;
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    nDimensions = pc[3];
+    effectiveNDimensions = nDimensions;
+    topOfStack -= nDimensions;
+    frame->topOfStack = topOfStack;;
+    for (dimCount = 0; dimCount < nDimensions; dimCount++) {
+ CVMInt32 dim = (((topOfStack[dimCount].s).j).i);
+ if (dim <= 0) {
+     if ((dim == 0) && (effectiveNDimensions == nDimensions)) {
+  effectiveNDimensions = dimCount + 1;
+     } else if (dim < 0) {
+  { if ((1 == 1)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+  CVMthrowNegativeArraySizeException(ee, ((void *)0));
+  return (!(1 == 1));
+     }
+ }
+    }
+    resultCell = ((ee)->miscICell);
+    ((void)((((resultCell)->ref_DONT_ACCESS_DIRECTLY == 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1116, "CVMID_icellIsNull(resultCell)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1126
+    , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { CVMmultiArrayAlloc(ee, effectiveNDimensions, topOfStack, arrCb, resultCell); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1126
+    , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+      ;
+    if (((resultCell)->ref_DONT_ACCESS_DIRECTLY == 0)) {
+ { if ((1 == 1)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+ return (!(1 == 1));
+    }
+    (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1138, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1138, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((resultCell))->ref_DONT_ACCESS_DIRECTLY))));
+    (resultCell)->ref_DONT_ACCESS_DIRECTLY = 0;;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tmultianewarray_quick %C " "(dimensions = %d, effective = %d) => 0x%x\n", arrCb, nDimensions, effectiveNDimensions, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1148, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0)
+                                                               ;
+    return (1 == 1);
+}
+static CVMMethodBlock*
+CVMinvokeInterfaceHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+    CVMMethodBlock* imb )
+{
+    CVMObject* directObj;
+    CVMClassBlock* icb;
+    CVMClassBlock* ocb;
+    CVMUint32 interfaceCount;
+    CVMInterfaces* interfaces;
+    CVMInterfaceTable* itablePtr;
+    CVMUint16 methodTableIndex;
+    CVMMethodBlock* mb;
+    int guess;
+    CVMStack* stack = &ee->interpreterStack;
+    CVMFrame* frame;
+    CVMUint8* pc;
+    frame = stack->currentFrame;;
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    guess = pc[4];
+    icb = (((CVMMethodRange*) ((CVMUint8 *)((imb) - ((imb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+    directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1175, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+    if (directObj == ((void *)0)) {
+        CVMthrowNullPointerException(ee, ((void *)0));
+ return ((void *)0);
+    }
+    ocb = ((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3));
+    interfaces = ((ocb)->interfacesX);
+    interfaceCount = ((interfaces) == ((void *)0) ? 0 : (interfaces)->interfaceCountX);
+    itablePtr = ((interfaces)->itable);
+    if (guess < 0 || guess >= interfaceCount ||
+ ((itablePtr)[guess].interfaceCb) != icb) {
+ guess = interfaceCount - 1;
+ while ((guess >= 0) &&
+        (((itablePtr)[guess].interfaceCb) != icb)) {
+     guess--;
+ }
+ if (guess >= 0) {
+     ((void)((((itablePtr)[guess].interfaceCb) == icb) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 1202
+     , "CVMcbInterfacecbGivenItable(itablePtr, guess) == icb") || (CVMsystemPanic("CVMassertHook returned"), 0)))
+               ;
+     if ((((ocb)->interfacesX)->itable[guess]. interfaceCb) == icb) {
+  if (!(((((((((CVMMethodRange*) ((CVMUint8 *)((frame->mb) - ((frame->mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->runtimeFlagsX) & 0x01) != 0))) &&
+      !((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1209, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) {
+      pc[4] = guess;
+  }
+     }
+ }
+    }
+    if (guess >= 0) {
+        methodTableIndex = (((interfaces)->itable[guess]. intfInfoX.methodTableIndicesX)[(*(((void)((((0x400 & (0x01 | 0x03 | 0x02)) ? ((((imb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x400) : ((((imb)->immutX.invokerAndAccessFlagsX) & 0x400) != 0)) && (((((((CVMMethodRange*) ((CVMUint8 *)((imb) - ((imb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->accessFlagsX) & 0x200) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1224, "CVMmbIs(imb, ABSTRACT) && CVMcbIs(CVMmbClassBlock(imb), INTERFACE)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(imb)->immutX.codeX.methodSlotIndex))])
+                                                      ;
+        mb = (((ocb)->methodTablePtrX)[methodTableIndex]);
+        return mb;
+    } else if (icb == ((CVMClassBlock*)(&java_lang_Object_Classblock))) {
+        methodTableIndex = ((imb)->immutX.methodTableIndexX);
+        mb = (((ocb)->methodTablePtrX)[methodTableIndex]);
+        return mb;
+    } else {
+        CVMthrowIncompatibleClassChangeError(
+     ee, "class %C does not implement interface %C", ocb, icb);
+ return ((void *)0);
+    }
+}
+static CVMBool
+CVMloadConstantHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint16 cpIndex, CVMUint8* pc)
+{
+    switch ((((cp)->cpTypesX)[cpIndex] & 0x3F)) {
+    case CVM_CONSTANT_ClassTypeID:
+    {
+ CVMBool resolved;
+ { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+ ,
+ 1256
+ , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { resolved = ((((cp)->cpTypesX) == ((void *)0) ? (1 == 1) : (((cp)->cpTypesX)[cpIndex] & 0x80) != 0) ? (1 == 1) : CVMprivate_cpResolveEntryFromClass(ee, (((CVMMethodRange*) ((CVMUint8 *)((((((ee))->interpreterStack.currentFrame)->mb)) - ((((((ee))->interpreterStack.currentFrame)->mb))->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), cp, cpIndex)); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+ ,
+ 1256
+ , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+   ;
+ if (!resolved) {
+     return (!(1 == 1));
+ }
+    }
+    case CVM_CONSTANT_ClassBlock: {
+ CVMClassBlock *cb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1262, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[cpIndex] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1262, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, cpIndex, ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[cpIndex].resolved.cb);
+ (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1263, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1263, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((((cb)->javaInstanceX)))->ref_DONT_ACCESS_DIRECTLY))));
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => %C\n", CVMopnames[pc[0]], cpIndex, cb) : (void)0)
+                     ;
+ return (1 == 1);
+    }
+    default:
+ return (!(1 == 1));
+    }
+}
+static CVMBool
+CVMldcHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint8* pc)
+{
+    return CVMloadConstantHelper(ee, topOfStack, cp, pc[1], pc);
+}
+static CVMBool
+CVMldc_wHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint8* pc)
+{
+    return CVMloadConstantHelper(ee, topOfStack, cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), pc);
+}
+static void
+CVMldc2_wHelper(CVMStackVal32* topOfStack, CVMConstantPool* cp, CVMUint8* pc)
+{
+    CVMJavaVal64 r;
+    ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(r.v))->l = ((fakeOutGCCStrictAliasing *)(&((cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.val32.raw)))->l; });
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(r.v))->l; };
+}
+static CVMStackVal32*
+CVMgetfield_quick_wHelper(CVMExecEnv* ee, CVMFrame* frame,
+     CVMStackVal32* topOfStack, CVMConstantPool* cp,
+     CVMUint8* pc)
+{
+    CVMFieldBlock* fb;
+    CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1301, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+    if (directObj == ((void *)0)) {
+ return ((void *)0);
+    }
+    fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1305, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1305, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+    ;
+    if ((( ((((fb)->nameAndTypeIDX))&0xffff) == 6) || ( ((((fb)->nameAndTypeIDX))&0xffff) == 9))) {
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); union {CVMUint32 x;} tmp_[2]; ; tmp_[0].x = (&(fieldLoc_)->raw)[0]; tmp_[1].x = (&(fieldLoc_)->raw)[1]; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-1].s).j))->raw))->l = ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l; }; };
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i)) : (void)0)
+                                     ;
+ topOfStack++;
+    } else {
+ if (( ((((fb)->nameAndTypeIDX))&0xffff) > 10)) {
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX)));
+ ; (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1323, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) = *fieldLoc_; };
+ } else {
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ; (((((topOfStack[-1].s).j))) = (*fieldLoc_)); }
+                       ;
+ }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X) ==>\n", CVMopnames[pc[0]], directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i)) : (void)0)
+                                                   ;
+    }
+    return topOfStack;
+}
+static CVMStackVal32*
+CVMputfield_quick_wHelper(CVMExecEnv* ee, CVMFrame* frame,
+     CVMStackVal32* topOfStack, CVMConstantPool* cp,
+     CVMUint8* pc)
+{
+    CVMObject* directObj;
+    CVMFieldBlock* fb;
+    fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1341, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1341, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+    if ((( ((((fb)->nameAndTypeIDX))&0xffff) == 6) || ( ((((fb)->nameAndTypeIDX))&0xffff) == 9))) {
+ directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1343, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ if (directObj == ((void *)0)) {
+     return ((void *)0);
+ }
+ ;
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); union {CVMUint32 x;} tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l = ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-2].s).j))->raw))->l; }; (&(fieldLoc_)->raw)[0] = tmp_[0].x; (&(fieldLoc_)->raw)[1] = tmp_[1].x; };
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i), directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))) : (void)0)
+                                    ;
+ topOfStack -= 3;
+    } else {
+ directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1361, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ if (directObj == ((void *)0)) {
+     return ((void *)0);
+ }
+                                     ;
+ if (( ((((fb)->nameAndTypeIDX))&0xffff) > 10)) {
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) = 1;; *fieldLoc_ = (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))); };
+ } else {
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ; ((*fieldLoc_) = ((((topOfStack[-1].s).j)))); };
+ }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))) : (void)0)
+                                                   ;
+ topOfStack -= 2;
+    }
+    return topOfStack;
+}
+static CVMBool
+CVMwideHelper(CVMExecEnv* ee, CVMSlotVal32* locals, CVMFrame* frame)
+{
+    CVMStackVal32* topOfStack;
+    CVMUint8* pc;
+    CVMUint16 reg;
+    CVMBool needRequestCheck = (!(1 == 1));
+    char trBuf[30];
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    topOfStack = frame->topOfStack;;
+    reg = ((((*(CVMUint8*)((pc + 2)+(0))) << 8) | (*(CVMUint8*)((pc + 2)+(1)))));
+    ;
+    switch(pc[1]) {
+        case opc_aload:
+        case opc_iload:
+        case opc_fload:
+     (topOfStack[0].s) = locals[reg];
+     if (pc[1] == opc_iload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiload_w locals[%d](%d) =>\n", reg, (((topOfStack[0].s).j).i)) : (void)0); }
+                        ;
+     if (pc[1] == opc_aload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\taload_w locals[%d](0x%x) =>\n", reg, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1404, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }
+                           ;
+     if (pc[1] == opc_fload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfload_w locals[%d](%f) =>\n", reg, (((topOfStack[0].s).j).f)) : (void)0); }
+                          ;
+     { pc += 4; topOfStack += 1; ; };
+     break;
+        case opc_lload:
+        case opc_dload:
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[reg].j.raw))->l; };
+     if (pc[1] == opc_lload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlload_w locals[%d](%s) =>\n", reg, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                          ;
+     if (pc[1] == opc_dload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdload_w locals[%d](%f) =>\n", reg, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }
+                           ;
+     { pc += 4; topOfStack += 2; ; };
+     break;
+        case opc_istore:
+        case opc_astore:
+        case opc_fstore:
+     locals[reg] = (topOfStack[-1].s);
+     if (pc[1] == opc_istore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tistore_w %d ==> locals[%d]\n", (((topOfStack[-1].s).j).i), reg) : (void)0); }
+                            ;
+     if (pc[1] == opc_astore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tastore_w 0x%x => locals[%d]\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1426, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), reg) : (void)0); }
+                             ;
+     if (pc[1] == opc_fstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfstore_w %f ==> locals[%d]\n", (((topOfStack[-1].s).j).f), reg) : (void)0); }
+                              ;
+     { pc += 4; topOfStack += -1; ; };
+     break;
+        case opc_lstore:
+        case opc_dstore:
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[reg].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+     if (pc[1] == opc_lstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlstore_w %s => locals[%d]\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), reg) : (void)0); }
+                                            ;
+     if (pc[1] == opc_dstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdstore_w %f => locals[%d]\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), reg) : (void)0); }
+                             ;
+     { pc += 4; topOfStack += -2; ; };
+     break;
+        case opc_iinc: {
+     CVMInt16 offset = ((CVMInt16) (((*(CVMUint8*)((pc+4)+(0))) << 8) | (*(CVMUint8*)((pc+4)+(1)))));
+     locals[reg].j.i += offset;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiinc_w locals[%d]+%d => %d\n", reg, offset, locals[reg].j.i) : (void)0)
+                              ;
+     { pc += 6; topOfStack += 0; ; };
+     break;
+ }
+        case opc_ret:
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  needRequestCheck = (1 == 1);
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tret_w %d (%#x)\n", reg, locals[reg].a) : (void)0);
+     pc = locals[reg].a;
+     break;
+        default:
+     ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1458, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    }
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    frame->topOfStack = topOfStack;;
+    return needRequestCheck;
+}
+static void
+CVMmemCopy64Helper(CVMAddr* destination, CVMAddr* source) {
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(destination))->l = ((fakeOutGCCStrictAliasing *)(source))->l; };
+}
+static CVMStackVal32*
+CVMreturn64Helper(CVMStackVal32* topOfStack, CVMFrame* frame)
+{
+    CVMJavaVal64 result;
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(result.v))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+    topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1484, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(result.v))->l; };
+    return topOfStack;
+}
+static const CVMUint8 CVMinvokeStaticTransitionCode[] = {
+    opc_invokestatic_quick, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeVirtualTransitionCode[] = {
+    opc_invokevirtual_quick_w, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeNonVirtualTransitionCode[] = {
+    opc_invokenonvirtual_quick, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeInterfaceTransitionCode[] = {
+    opc_invokeinterface_quick, 0, 1, 0, 0, opc_exittransition
+};
+void
+CVMgcUnsafeExecuteJavaMethod(CVMExecEnv* volatile ee,
+                        CVMMethodBlock* mb,
+                        CVMBool isStatic, CVMBool isVirtual)
+{
+    CVMFrame* frame = ((void *)0);
+    CVMFrame* initialframe = ((void *)0);
+    CVMStack* stack = &ee->interpreterStack;
+    CVMStackVal32* topOfStack = ((void *)0);
+    CVMSlotVal32* locals = ((void *)0);
+    CVMUint8* pc = ((void *)0);
+    CVMConstantPool* cp = ((void *)0);
+    CVMTransitionConstantPool transitioncp;
+    CVMClassBlock* initCb = ((void *)0);
+    char trBuf[30];
+    static const void* const opclabels_data[256] = {
+ &&opc_nop, &&opc_aconst_null, &&opc_iconst_m1, &&opc_iconst_0, &&opc_iconst_1, &&opc_iconst_2,
+ &&opc_iconst_3, &&opc_iconst_4, &&opc_iconst_5, &&opc_lconst_0, &&opc_lconst_1, &&opc_fconst_0,
+ &&opc_fconst_1, &&opc_fconst_2, &&opc_dconst_0, &&opc_dconst_1, &&opc_bipush, &&opc_sipush,
+ &&opc_ldc, &&opc_ldc_w, &&opc_ldc2_w, &&opc_iload, &&opc_lload, &&opc_fload,
+ &&opc_dload, &&opc_aload, &&opc_iload_0, &&opc_iload_1, &&opc_iload_2, &&opc_iload_3,
+ &&opc_lload_0, &&opc_lload_1, &&opc_lload_2, &&opc_lload_3, &&opc_fload_0, &&opc_fload_1,
+ &&opc_fload_2, &&opc_fload_3, &&opc_dload_0, &&opc_dload_1, &&opc_dload_2, &&opc_dload_3,
+ &&opc_aload_0, &&opc_aload_1, &&opc_aload_2, &&opc_aload_3, &&opc_iaload, &&opc_laload,
+ &&opc_faload, &&opc_daload, &&opc_aaload, &&opc_baload, &&opc_caload, &&opc_saload,
+ &&opc_istore, &&opc_lstore, &&opc_fstore, &&opc_dstore, &&opc_astore, &&opc_istore_0,
+ &&opc_istore_1, &&opc_istore_2, &&opc_istore_3, &&opc_lstore_0, &&opc_lstore_1, &&opc_lstore_2,
+ &&opc_lstore_3, &&opc_fstore_0, &&opc_fstore_1, &&opc_fstore_2, &&opc_fstore_3, &&opc_dstore_0,
+ &&opc_dstore_1, &&opc_dstore_2, &&opc_dstore_3, &&opc_astore_0, &&opc_astore_1, &&opc_astore_2,
+ &&opc_astore_3, &&opc_iastore, &&opc_lastore, &&opc_fastore, &&opc_dastore, &&opc_aastore,
+ &&opc_bastore, &&opc_castore, &&opc_sastore, &&opc_pop, &&opc_pop2, &&opc_dup,
+ &&opc_dup_x1, &&opc_dup_x2, &&opc_dup2, &&opc_dup2_x1, &&opc_dup2_x2, &&opc_swap,
+ &&opc_iadd, &&opc_ladd, &&opc_fadd, &&opc_dadd, &&opc_isub, &&opc_lsub,
+ &&opc_fsub, &&opc_dsub, &&opc_imul, &&opc_lmul, &&opc_fmul, &&opc_dmul,
+ &&opc_idiv, &&opc_ldiv, &&opc_fdiv, &&opc_ddiv, &&opc_irem, &&opc_lrem,
+ &&opc_frem, &&opc_drem, &&opc_ineg, &&opc_lneg, &&opc_fneg, &&opc_dneg,
+ &&opc_ishl, &&opc_lshl, &&opc_ishr, &&opc_lshr, &&opc_iushr, &&opc_lushr,
+ &&opc_iand, &&opc_land, &&opc_ior, &&opc_lor, &&opc_ixor, &&opc_lxor,
+ &&opc_iinc, &&opc_i2l, &&opc_i2f, &&opc_i2d, &&opc_l2i, &&opc_l2f,
+ &&opc_l2d, &&opc_f2i, &&opc_f2l, &&opc_f2d, &&opc_d2i, &&opc_d2l,
+ &&opc_d2f, &&opc_i2b, &&opc_i2c, &&opc_i2s, &&opc_lcmp, &&opc_fcmpl,
+ &&opc_fcmpg, &&opc_dcmpl, &&opc_dcmpg, &&opc_ifeq, &&opc_ifne, &&opc_iflt,
+ &&opc_ifge, &&opc_ifgt, &&opc_ifle, &&opc_if_icmpeq, &&opc_if_icmpne, &&opc_if_icmplt,
+ &&opc_if_icmpge, &&opc_if_icmpgt, &&opc_if_icmple, &&opc_if_acmpeq, &&opc_if_acmpne, &&opc_goto,
+ &&opc_jsr, &&opc_ret, &&opc_tableswitch, &&opc_lookupswitch, &&opc_ireturn, &&opc_lreturn,
+ &&opc_freturn, &&opc_dreturn, &&opc_areturn, &&opc_return, &&opc_getstatic, &&opc_putstatic,
+ &&opc_getfield, &&opc_putfield, &&opc_invokevirtual, &&opc_invokespecial, &&opc_invokestatic, &&opc_invokeinterface,
+ &&opc_xxxunusedxxx, &&opc_new, &&opc_newarray, &&opc_anewarray, &&opc_arraylength, &&opc_athrow,
+ &&opc_checkcast, &&opc_instanceof, &&opc_monitorenter, &&opc_monitorexit, &&opc_wide, &&opc_multianewarray,
+ &&opc_ifnull, &&opc_ifnonnull, &&opc_goto_w, &&opc_jsr_w, &&opc_breakpoint, &&opc_aldc_ind_quick,
+ &&opc_aldc_ind_w_quick, &&opc_invokestatic_quick, &&opc_invokestatic_checkinit_quick, &&opc_invokevirtual_quick, &&opc_getfield_quick, &&opc_agetfield_quick,
+ &&opc_vinvokevirtual_quick, &&opc_invokevirtual_quick_w, &&opc_putfield_quick, &&opc_invokenonvirtual_quick, &&opc_invokesuper_quick, &&opc_invokeignored_quick,
+ &&opc_getfield2_quick, &&opc_checkcast_quick, &&opc_instanceof_quick, &&opc_nonnull_quick, &&opc_putfield2_quick, &&opc_ainvokevirtual_quick,
+ &&opc_invokevirtualobject_quick, &&opc_invokeinterface_quick, &&opc_aldc_quick, &&opc_ldc_quick, &&opc_exittransition, &&opc_dinvokevirtual_quick,
+ &&opc_aldc_w_quick, &&opc_ldc_w_quick, &&opc_aputfield_quick, &&opc_getfield_quick_w, &&opc_ldc2_w_quick, &&opc_agetstatic_quick,
+ &&opc_getstatic_quick, &&opc_getstatic2_quick, &&opc_aputstatic_quick, &&opc_putstatic_quick, &&opc_putstatic2_quick, &&opc_agetstatic_checkinit_quick,
+ &&opc_getstatic_checkinit_quick, &&opc_getstatic2_checkinit_quick, &&opc_aputstatic_checkinit_quick, &&opc_putstatic_checkinit_quick, &&opc_putstatic2_checkinit_quick, &&opc_putfield_quick_w,
+ &&opc_new_checkinit_quick, &&opc_new_quick, &&opc_anewarray_quick, &&opc_multianewarray_quick, &&opc_prefix, &&opc_DEFAULT,
+ &&opc_DEFAULT, &&opc_DEFAULT, &&opc_DEFAULT, &&opc_DEFAULT
+    };
+    const void* const *opclabels = &opclabels_data[0];
+    if (!CVMCstackCheckSize(ee, (5976 + (3 * 1024)),
+        "CVMgcUnsafeExecuteJavaMethod", (1 == 1))) {
+ goto return_from_executejava_branch_island;
+    }
+    ((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1625, "CVMD_isgcUnsafe(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    frame = stack->currentFrame;;
+    initialframe = frame;
+new_transition:
+    ;
+    ((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1640, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1640, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    topOfStack = frame->topOfStack;;
+    if (isStatic) {
+ pc = (CVMUint8*)CVMinvokeStaticTransitionCode;
+    } else {
+ if ((((((((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->accessFlagsX) & 0x200) != 0)) {
+     pc = (CVMUint8*)CVMinvokeInterfaceTransitionCode;
+ } else if (isVirtual && !((0x03 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x03) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x03) != 0)) &&
+     !(((((((mb)->immutX.nameAndTypeIDX))&0xffff0000) == ((CVMglobals.initTid)&0xffff0000))))) {
+     pc = (CVMUint8*)CVMinvokeVirtualTransitionCode;
+ } else {
+     pc = (CVMUint8*)CVMinvokeNonVirtualTransitionCode;
+ }
+    }
+    isVirtual = (!(1 == 1));
+    (&transitioncp)->cp.cpTypesX = ((void *)0); (&transitioncp)->entry1X.resolved.mb = mb;;
+    cp = (CVMConstantPool*)&transitioncp;
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodCall(ee, frame, (!(1 == 1))); };
+    ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+    {
+ const void* nextLabel;;
+ nextLabel = opclabels[pc[0]];;
+ goto *nextLabel;;
+    }
+    {
+ {
+ opc_nop: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1705, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ opc_aconst_null: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1711, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = 0;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+     opc_iconst_m1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1730, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = -1; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1731, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1732, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 1; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1733, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 2; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1734, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 3; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_4: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1735, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 4; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_5: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1736, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 5; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_lconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1738, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = (0LL); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_lconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1739, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = (1LL); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_fconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1741, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 0.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_fconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1742, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 1.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_fconst_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1743, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 2.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_dconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1745, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d = (0.0); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_dconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1746, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d = (1.0); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+ opc_bipush: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1749, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+     (((topOfStack[0].s).j).i) = (CVMInt8)(pc[1]);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tbipush %d\n", (((topOfStack[0].s).j).i)) : (void)0);
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_sipush: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1755, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+     (((topOfStack[0].s).j).i) = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tsipush %d\n", (((topOfStack[0].s).j).i)) : (void)0);
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_aload: ;
+ opc_iload: ;
+ opc_fload: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1764, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     CVMUint32 localNo = pc[1];
+            CVMSlotVal32 l = locals[localNo];
+     topOfStack += 1;
+     (topOfStack[-1].s) = l;
+     if (pc[0] == opc_aload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\taload locals[%d](0x%x) =>\n", pc[1], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1770, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }
+                             ;
+     if (pc[0] == opc_iload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiload locals[%d](%d) =>\n", pc[1], (((topOfStack[-1].s).j).i)) : (void)0); }
+                          ;
+     if (pc[0] == opc_fload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfload locals[%d](%f) =>\n", pc[1], (((topOfStack[-1].s).j).f)) : (void)0); }
+                            ;
+     { pc += 2; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_lload: ;
+ opc_dload: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1779, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[pc[1]].j.raw))->l; };
+     if (pc[0] == opc_dload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdload locals[%d](%f) =>\n", pc[1], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }
+                            ;
+     if (pc[0] == opc_lload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlload locals[%d](%s) =>\n", pc[1], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                           ;
+     { pc += 2; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_iload_0: ; opc_aload_0: ; opc_fload_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1810, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[0]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 0, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 0, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1810, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 0, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_1: ; opc_aload_1: ; opc_fload_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1811, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[1]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 1, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 1, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1811, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 1, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_2: ; opc_aload_2: ; opc_fload_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1812, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[2]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 2, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 2, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1812, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 2, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_3: ; opc_aload_3: ; opc_fload_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1813, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[3]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 3, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 3, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1813, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 3, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_lload_0: ; opc_dload_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1830, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[0].j.raw))->l; }; if (pc[0] == opc_lload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 0, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 0, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_1: ; opc_dload_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1831, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[1].j.raw))->l; }; if (pc[0] == opc_lload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 1, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 1, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_2: ; opc_dload_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1832, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[2].j.raw))->l; }; if (pc[0] == opc_lload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 2, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 2, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_3: ; opc_dload_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1833, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[3].j.raw))->l; }; if (pc[0] == opc_lload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 3, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 3, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+        opc_iaload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1872, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfInt* arrObj = (CVMArrayOfInt*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1873, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaInt volatile *elemLoc_ = (CVMJavaInt volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1873, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_laload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1874, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaLong temp64; CVMArrayOfLong* arrObj = (CVMArrayOfLong*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1875, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); ; *(CVMJavaLong volatile *)&(temp64) = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)((CVMUint32*)&(elemLoc_)->raw))->l); }); }; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = temp64; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+        opc_faload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1876, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfFloat* arrObj = (CVMArrayOfFloat*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1877, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaFloat volatile *elemLoc_ = (CVMJavaFloat volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1877, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).f)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%f" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_daload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1878, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaDouble temp64; CVMArrayOfDouble* arrObj = (CVMArrayOfDouble*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1879, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); ; *(CVMJavaDouble volatile*)&(temp64) = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)((CVMUint32*)&(elemLoc_)->raw))->d); }); }; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = temp64; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+        opc_aaload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1880, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfRef* arrObj = (CVMArrayOfRef*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMObject* volatile *elemLoc_ = (CVMObject* volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "0x%x" ") ==>\n", CVMopnames[pc[0]], arrObj, index, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_baload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1882, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfByte* arrObj = (CVMArrayOfByte*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1883, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaByte volatile *elemLoc_ = (CVMJavaByte volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1883, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_caload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1884, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfChar* arrObj = (CVMArrayOfChar*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1885, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaChar volatile *elemLoc_ = (CVMJavaChar volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1885, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_saload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1886, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfShort* arrObj = (CVMArrayOfShort*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1887, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaShort volatile *elemLoc_ = (CVMJavaShort volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1887, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore: ;
+ opc_fstore: ;
+ opc_astore: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1893, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     locals[pc[1]] = (topOfStack[-1].s);
+     if (pc[0] == opc_istore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tistore %d ==> locals[%d]\n", (((topOfStack[-1].s).j).i), pc[-1]) : (void)0); }
+                            ;
+     if (pc[0] == opc_astore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tastore 0x%x => locals[%d]\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1898, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), pc[-1]) : (void)0); }
+                               ;
+     if (pc[0] == opc_fstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfstore %f ==> locals[%d]\n", (((topOfStack[-1].s).j).f), pc[-1]) : (void)0); }
+                              ;
+     { pc += 2; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lstore: ;
+        opc_dstore: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1906, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[pc[1]].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+     if (pc[0] == opc_dstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdstore %f => locals[%d]\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), pc[1]) : (void)0); }
+                              ;
+     if (pc[0] == opc_lstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlstore %s => locals[%d]\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), pc[1]) : (void)0); }
+                                             ;
+     { pc += 2; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+ opc_istore_0: ; opc_astore_0: ; opc_fstore_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1933, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[0] = (topOfStack[-1].s); if (pc[0] == opc_istore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 0) : (void)0); }; if (pc[0] == opc_astore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1933, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 0) : (void)0); }; if (pc[0] == opc_fstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 0) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_1: ; opc_astore_1: ; opc_fstore_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1934, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[1] = (topOfStack[-1].s); if (pc[0] == opc_istore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 1) : (void)0); }; if (pc[0] == opc_astore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1934, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 1) : (void)0); }; if (pc[0] == opc_fstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 1) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_2: ; opc_astore_2: ; opc_fstore_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1935, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[2] = (topOfStack[-1].s); if (pc[0] == opc_istore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 2) : (void)0); }; if (pc[0] == opc_astore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1935, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 2) : (void)0); }; if (pc[0] == opc_fstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 2) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_3: ; opc_astore_3: ; opc_fstore_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1936, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[3] = (topOfStack[-1].s); if (pc[0] == opc_istore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 3) : (void)0); }; if (pc[0] == opc_astore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1936, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 3) : (void)0); }; if (pc[0] == opc_fstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 3) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_0: ; opc_dstore_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1953, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[0].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 0) : (void)0); }; if (pc[0] == opc_dstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 0) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_1: ; opc_dstore_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1954, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[1].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 1) : (void)0); }; if (pc[0] == opc_dstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 1) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_2: ; opc_dstore_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1955, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[2].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 2) : (void)0); }; if (pc[0] == opc_dstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 2) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_3: ; opc_dstore_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1956, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[3].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 3) : (void)0); }; if (pc[0] == opc_dstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 3) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+        opc_bastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1982, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfByte* arrObj = (CVMArrayOfByte*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1983, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaByte volatile *elemLoc_ = (CVMJavaByte volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1983, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_castore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1984, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfChar* arrObj = (CVMArrayOfChar*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1985, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaChar volatile *elemLoc_ = (CVMJavaChar volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1985, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_sastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1986, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfShort* arrObj = (CVMArrayOfShort*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1987, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaShort volatile *elemLoc_ = (CVMJavaShort volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1987, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_iastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1988, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfInt* arrObj = (CVMArrayOfInt*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1989, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaInt volatile *elemLoc_ = (CVMJavaInt volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1989, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_fastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1990, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfFloat* arrObj = (CVMArrayOfFloat*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1991, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaFloat volatile *elemLoc_ = (CVMJavaFloat volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1991, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).f)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%f" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_lastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1992, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaLong temp64; CVMArrayOfLong* arrObj = (CVMArrayOfLong*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1993, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-4].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-4 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; temp64 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile*)(&((arrObj)->elems[(index)])); CVMUint32 tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(tmp_))->l = (temp64); }; (&(elemLoc_)->raw)[0] = tmp_[0]; (&(elemLoc_)->raw)[1] = tmp_[1]; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -4; ; }; ; goto *nextLabel;; }; };
+        opc_dastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1994, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaDouble temp64; CVMArrayOfDouble* arrObj = (CVMArrayOfDouble*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1995, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-4].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-4 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; temp64 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); CVMUint32 tmp_[2]; ; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(tmp_))->d = (temp64); }; (&(elemLoc_)->raw)[0] = tmp_[0]; (&(elemLoc_)->raw)[1] = tmp_[1]; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -4; ; }; ; goto *nextLabel;; }; };
+        opc_aastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2000, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMObject* rhsObject = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2002, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMArrayOfRef* arrObj = (CVMArrayOfRef*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2003, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; };
+     if (rhsObject != 0) {
+  CVMClassBlock* elemType =
+      (*(((void)(((((((((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))->classNameX))&0xc000) != 0 )) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2007, "CVMisArrayClass(((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))->cpX.arrayInfoX)->elementCb));
+  CVMClassBlock* rhsType = ((CVMClassBlock*)(((CVMAddr)((rhsObject)->hdr.clas)) & ~3));
+  if (rhsType != elemType) {
+      if (!CVMisAssignable(ee, rhsType, elemType)) {
+   if (!(((ee)->exceptionFlags.oneflag.local) != 0)) {
+       goto array_store_exception;
+   } else {
+       goto handle_exception;
+   }
+      }
+  }
+     }
+     { CVMObject* volatile *elemLoc_ = (CVMObject* volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "CARD_TABLE_SLOT_ADDRESS_FOR((elemLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "CARD_TABLE_SLOT_ADDRESS_FOR((elemLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) = 1;; *elemLoc_ = (rhsObject); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x ==> %O[%d] ==>\n", CVMopnames[pc[0]], rhsObject, arrObj, index) : (void)0)
+                                                  ;
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+ }
+ opc_pop: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2028, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tpop\n") : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ opc_pop2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2033, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tpop2\n") : (void)0);
+     { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ opc_dup: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2037, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMJavaVal32 rhs = ((topOfStack[-1].s).j);
+     topOfStack += 1;
+     pc += 1;
+     ((topOfStack[-1].s).j) = rhs;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup\n") : (void)0);
+     { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_dup_x1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2046, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup_x1\n") : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_dup_x2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2053, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup_x2\n") : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_dup2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2061, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_dup2_x1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2067, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[1].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2_x1\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_dup2_x2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2076, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[-4].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[1].s).j);
+     ((topOfStack[-4].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2_x2\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_swap: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2086, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMJavaVal32 j = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = j;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tswap\n") : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_iadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2133, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) + ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_isub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2135, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) - ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_imul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2137, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) * ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_idiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2139, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (1 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = ((((((topOfStack[-2].s).j).i)) == 0x80000000 && ((((topOfStack[-1].s).j).i)) == -1) ? (((((topOfStack[-2].s).j).i)) / 1) : (((((topOfStack[-2].s).j).i)) / ((((topOfStack[-1].s).j).i)))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_irem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2141, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (1 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = ((((((topOfStack[-2].s).j).i)) == 0x80000000 && ((((topOfStack[-1].s).j).i)) == -1) ? (((((topOfStack[-2].s).j).i)) % 1) : (((((topOfStack[-2].s).j).i)) % ((((topOfStack[-1].s).j).i)))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_iand: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2143, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) & ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ior: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2145, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) | ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ixor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2147, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) ^ ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2150, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) + ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2152, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) - ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2154, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) * ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fdiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2156, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) / ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_frem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2158, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = CVMfloatRem((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ladd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2161, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongAddHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2163, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongSubHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2165, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongMulHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ldiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2167, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongDivHelper(topOfStack); if (1 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lrem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2169, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongRemHelper(topOfStack); if (1 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_land: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2171, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongAndHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2173, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongOrHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lxor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2175, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongXorHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2178, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleAddHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2180, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleSubHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2182, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleMulHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ddiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2184, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleDivHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_drem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2186, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleRemHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ineg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2191, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     (((topOfStack[-1].s).j).i) = (- (((((topOfStack[-1].s).j).i))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_lneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2197, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMlongNegHelper(topOfStack);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0)
+                                      ;
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_fneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2205, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     (((topOfStack[-1].s).j).f) = (-((((topOfStack[-1].s).j).f)));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f)) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_dneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2211, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMdoubleNegHelper(topOfStack);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_ishl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2238, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) << ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lshl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2238, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongShlHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_ishr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2239, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) >> ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lshr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2239, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongShrHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_iushr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2240, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((unsigned int)((((topOfStack[-2].s).j).i))) >> ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lushr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2240, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongUshrHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_iinc: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2244, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMUint32 localNo = pc[1];
+     CVMInt32 incr = (CVMInt8)pc[2];
+     pc += 3;
+     locals[localNo].j.i += incr;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiinc locals[%d]+%d => %d\n", localNo, (CVMInt8)(incr), locals[localNo].j.i) : (void)0)
+                                           ;
+     { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2257, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaLong r;
+     r = ((CVMJavaLong)((((topOfStack[-1].s).j).i)));
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2266, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    (((topOfStack[-1].s).j).f) = ((CVMJavaFloat)(((((topOfStack[-1].s).j).i))));
+           (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2f => %f\n", (((topOfStack[-1].s).j).f)) : (void)0);
+           { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_l2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2271, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+        CVMJavaLong r;
+     r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+     (((topOfStack[-2].s).j).i) = ((CVMJavaInt)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2i => %d\n", (((topOfStack[-2].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_l2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2280, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+        CVMJavaLong r;
+     r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+     (((topOfStack[-2].s).j).f) = ((CVMJavaFloat)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2f => %f\n", (((topOfStack[-2].s).j).f)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_f2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2289, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+            (((topOfStack[-1].s).j).i) = (float2Int((((topOfStack[-1].s).j).f)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2i => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_f2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2294, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaLong r;
+      r = float2Long(((((topOfStack[-1].s).j).f)));
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_f2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2303, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaDouble r;
+     r = ((CVMJavaDouble)((((topOfStack[-1].s).j).f)));
+     { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        }
+        opc_d2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2312, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    {
+     CVMJavaDouble r;
+     r = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+     (((topOfStack[-2].s).j).f) = ((CVMJavaFloat)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2f => %f\n", (((topOfStack[-2].s).j).f)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2b: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2321, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = ((signed char)((((topOfStack[-1].s).j).i)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2b => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_i2c: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2326, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = (((((topOfStack[-1].s).j).i)) & (0xffff));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2c => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_i2s: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2331, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = ((signed short)((((topOfStack[-1].s).j).i)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2s => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_lcmp: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2338, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMlongCmpHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0)
+                      ;
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+ }
+        opc_fcmpl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2346, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     (((topOfStack[-2].s).j).i) =
+  CVMfloatCompare((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f), -1);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_fcmpg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2354, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     (((topOfStack[-2].s).j).i) =
+  CVMfloatCompare((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f), 1);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_dcmpg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2362, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+        {
+     CVMdoubleCmpHelper(topOfStack, 1);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+        opc_dcmpl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2369, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+        {
+     CVMdoubleCmpHelper(topOfStack, -1);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+ opc_ifeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) == 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+        opc_ifne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) != 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) != 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_iflt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) < 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) < 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifge: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) >= 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) >= 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifgt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) > 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) > 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifle: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) <= 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) <= 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) == (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) == (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_if_icmpne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) != (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) != (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmplt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) < (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) < (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpge: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) >= (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) >= (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpgt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) > (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) > (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmple: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) <= (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) <= (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_acmpeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) ? "" : "not ") : (void)0); ; if (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_if_acmpne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) != ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) ? "" : "not ") : (void)0); ; if (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) != ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_goto: ;
+ {
+     CVMInt16 skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n",CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+            ;
+            ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_jsr: ;
+        {
+     CVMInt16 skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+            ;
+     ((topOfStack[0].s).a) = pc + 3;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n",CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_ret: ; {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tret %d (%#x)\n", pc[1], locals[pc[1]].a) : (void)0);
+     pc = locals[pc[1]].a;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+ opc_tableswitch: ;
+ {
+     CVMInt32 skip = CVMtableswitchHelper(ee, topOfStack, pc, frame);
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lookupswitch: ;
+ {
+     CVMInt32 skip = CVMlookupswitchHelper(ee, topOfStack, pc, frame);
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lreturn: ;
+ opc_dreturn: ;
+        {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     topOfStack = CVMreturn64Helper(topOfStack, frame);
+     topOfStack += 2;
+     if (pc[0] == opc_dreturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfreturn1 %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0); };
+     if (pc[0] == opc_lreturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlreturn %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                       ;
+     goto handle_return;
+        }
+ opc_return: ;
+        {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2574, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\treturn\n") : (void)0);
+     goto handle_return;
+ }
+ opc_ireturn: ;
+ opc_areturn: ;
+ opc_freturn: ;
+        {
+     CVMJavaVal32 result;
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     result = ((topOfStack[-1].s).j);
+     topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2631, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     ((topOfStack[0].s).j) = result;
+     topOfStack++;
+     if (pc[0] == opc_ireturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tireturn %d\n", (((topOfStack[-1].s).j).i)) : (void)0); };
+     if (pc[0] == opc_areturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tareturn 0x%x\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2635, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); };
+     if (pc[0] == opc_freturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfreturn %f\n", (((topOfStack[-1].s).j).f)) : (void)0); };
+     goto handle_return;
+        }
+    handle_return:
+ ;
+ {
+     if (((0x20 & (0x01 | 0x03 | 0x02)) ? ((((frame->mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x20) : ((((frame->mb)->immutX.invokerAndAccessFlagsX) & 0x20) != 0))) {
+                CVMObjectICell *objICell = &((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2658, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2658, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX);
+                if (!CVMfastTryUnlock(ee, (*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2659, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(objICell)->ref_DONT_ACCESS_DIRECTLY)))) {
+      ;
+      (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2662, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2662, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+      (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+      if (!CVMsyncReturnHelper(ee, frame, &(((topOfStack[-1].s).j).r),
+          pc[0] == opc_areturn))
+      {
+                        frame = stack->currentFrame;;
+   goto handle_exception;
+      }
+  }
+     }
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+     { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2675, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2698, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) {
+  locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+  cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     }
+     pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+        opc_newarray: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2726, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     if (!CVMnewarrayHelper(ee, topOfStack, (CVMBasicType)pc[1])) {
+  goto handle_exception;
+     }
+     { pc += 2; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_arraylength: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2741, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMArrayOfAnyType* arrObj = (CVMArrayOfAnyType*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2743, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((arrObj) == 0) { goto null_pointer_exception; };
+     (((topOfStack[-1].s).j).i) = ((arrObj)->length);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O.length(%d) ==>\n", CVMopnames[pc[0]], arrObj, (((topOfStack[-1].s).j).i)) : (void)0)
+                            ;
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_athrow: ; {
+     CVMObject* directObj;
+            ;
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2757, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tathrow => %O\n", directObj) : (void)0);
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     { ((void)((!(((ee)->exceptionFlags.oneflag.local) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2761, "!CVMlocalExceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0))); (ee)->isThrowingAnException = (1 == 1); (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2761, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((ee)->localExceptionICell))->ref_DONT_ACCESS_DIRECTLY = (directObj));; ((ee)->exceptionFlags.oneflag.local) = 1; ((CVMglobals.debugFlags & ((16384L))) != 0 ? CVMconsolePrintf ("[<%d> Exception thrown: %O]\n", ee->threadID, directObj) : (void)0); if ((CVMglobals.debugFlags & ((16384L)))) { CVMdumpStack(&ee->interpreterStack, (!(1 == 1)), (!(1 == 1)), 100); } };
+     goto handle_exception;
+ }
+ opc_monitorenter: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2767, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2768, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_monitorenter(%O)\n", directObj) : (void)0);
+     if (!CVMfastTryLock(ee, directObj)) {
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  frame->topOfStack = topOfStack;;
+  if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2776, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].lock(ee, &(((topOfStack[-1].s).j).r))) {
+      goto out_of_memory_error;
+  }
+     }
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_monitorexit: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2783, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2784, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_monitorexit(%O)\n", directObj) : (void)0);
+     if (!CVMfastTryUnlock(ee, directObj)){
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  frame->topOfStack = topOfStack;;
+  if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2792, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].unlock(ee, &(((topOfStack[-1].s).j).r))) {
+      goto illegal_monitor_state_exception_thread_not_owner;
+  }
+     }
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_ifnull: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (!!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2818, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) ? "" : "not ") : (void)0); ; if (!!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2818, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifnonnull: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2819, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) ? "" : "not ") : (void)0); ; if (!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2819, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+        opc_breakpoint: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2850, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[1]];; {
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tbreakpoint\n") : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_aldc_ind_quick: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2858, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     CVMObjectICell* strICell = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2859, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[pc[1]] & 0x3F) == CVM_CONSTANT_StringICell)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2859, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, pc[1], StringICell)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[pc[1]].resolved.strICell);
+     (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2860, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2860, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((strICell))->ref_DONT_ACCESS_DIRECTLY))));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_aldc_quick: ;
+        opc_ldc_quick: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2867, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+     ((topOfStack[0].s).j) = ((cp)->entriesX[pc[1]].resolved.val32);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        opc_checkcast_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2875, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2877, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMClassBlock* castCb =
+  (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2879, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2879, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C\n", CVMopnames[pc[0]], castCb) : (void)0);
+     if (!CVMgcUnsafeIsInstanceOf(ee, directObj, castCb)) {
+  goto class_cast_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_instanceof_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2889, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2891, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     (((topOfStack[-1].s).j).i) = (directObj != ((void *)0)) &&
+  CVMgcUnsafeIsInstanceOf(ee, directObj,
+     (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2894, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2894, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb));
+     if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  goto handle_exception;
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C => %d\n", CVMopnames[pc[0]], (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2902, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2902, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb), (((topOfStack[-1].s).j).i)) : (void)0)
+                    ;
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+  }
+ opc_nonnull_quick: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2908, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnonnull_quick\n") : (void)0);
+     if ((((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2910, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) == 0) { goto null_pointer_exception; };
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ opc_exittransition: ; {
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\texittransition\n") : (void)0);
+     if (frame == initialframe) {
+                if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+  goto finish;
+     } else {
+  goto opc_exittransition_overflow;
+     }
+ }
+ opc_agetstatic_quick: ;
+ opc_getstatic_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2933, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2934, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2934, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+     ((topOfStack[0].s).j) = (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)])));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] (0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX), (((topOfStack[0].s).j).i)) : (void)0)
+                                    ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_getstatic2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2944, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2945, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2945, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&((topOfStack[0].s).j).raw,
+          &(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] ((0x%X,0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX), (((topOfStack[0].s).j).i), (((topOfStack[1].s).j).i)) : (void)0)
+                                                  ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_aputstatic_quick: ;
+ opc_putstatic_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2963, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2964, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2964, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+     (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX)) : (void)0)
+                                               ;
+     { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_putstatic2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2973, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2974, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2974, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw,
+          &((topOfStack[-2].s).j).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X,0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX)) : (void)0)
+                                               ;
+     { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+ opc_agetstatic_checkinit_quick: ;
+ opc_getstatic_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2997, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb;
+     CVMClassBlock* cb;
+     fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3001, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3001, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+     ((topOfStack[0].s).j) = (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)])));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] (0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), cb, fb, ((fb)->offsetX), (((topOfStack[0].s).j).i)) : (void)0)
+                                    ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_getstatic2_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3012, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3014, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3014, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&((topOfStack[0].s).j).raw,
+          &(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] ((0x%X,0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), cb, fb, ((fb)->offsetX), (((topOfStack[0].s).j).i), (((topOfStack[1].s).j).i)) : (void)0)
+                                                  ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_aputstatic_checkinit_quick: ;
+ opc_putstatic_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3034, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+        {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3036, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3036, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+     (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), cb, fb, ((fb)->offsetX)) : (void)0)
+                              ;
+     { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_putstatic2_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3047, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3049, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3049, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw,
+          &((topOfStack[-2].s).j).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X,0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), cb, fb, ((fb)->offsetX)) : (void)0)
+                              ;
+     { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+        opc_getfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3074, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3076, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     pc += 3;
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; (((((topOfStack[-1].s).j))) = (*fieldLoc_)); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X) ==>\n", CVMopnames[pc[-3]], directObj, slotIndex, (((topOfStack[-1].s).j).i)) : (void)0)
+                                          ;
+            { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3086, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3088, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; ((*fieldLoc_) = ((((topOfStack[-1].s).j)))); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), directObj, slotIndex) : (void)0)
+                                          ;
+            { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+        }
+        opc_getfield2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3097, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3099, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (pc[1])); union {CVMUint32 x;} tmp_[2]; ; tmp_[0].x = (&(fieldLoc_)->raw)[0]; tmp_[1].x = (&(fieldLoc_)->raw)[1]; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-1].s).j))->raw))->l = ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l; }; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], directObj, pc[1], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i)) : (void)0)
+                                                    ;
+            { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3107, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3109, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (pc[1])); union {CVMUint32 x;} tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l = ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-2].s).j))->raw))->l; }; (&(fieldLoc_)->raw)[0] = tmp_[0].x; (&(fieldLoc_)->raw)[1] = tmp_[1].x; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i), directObj, pc[1]) : (void)0)
+                                                    ;
+            { pc += 3; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+ opc_agetfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3117, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* fieldObj;
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3120, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     pc += 3;
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; (fieldObj) = *fieldLoc_; };
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3125, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (fieldObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%x) ==>\n", CVMopnames[pc[-3]], directObj, slotIndex, fieldObj) : (void)0)
+                                     ;
+            { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+ opc_aputfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3131, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3133, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (pc[1])); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) = 1;; *fieldLoc_ = (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%x) ==> %O[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3137, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), directObj, pc[1]) : (void)0)
+                                         ;
+            { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+        }
+ opc_new_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3143, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];; {
+     CVMClassBlock* newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3144, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3144, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     CVMObject* directObj;
+     if ((!(((CVMAddr)(*((void)(ee), ((((((newCb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(newCb)->clinitEEX.eePtr)) : &((newCb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((newCb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(newCb)->clinitEEX.eePtr)) : &((newCb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = newCb; goto init_class; } ;;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     directObj = CVMgcAllocNewInstance(ee, newCb);
+     if (directObj == 0) {
+  goto out_of_memory_error_for_new_quick;
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3159, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (directObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_new_checkinit_quick %C => 0x%x\n", newCb, directObj) : (void)0)
+                       ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_new_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3167, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMClassBlock* newCb;
+     CVMObject* directObj;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3178, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3178, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     directObj = CVMgcAllocNewInstance(ee, newCb);
+     if (directObj == ((void *)0)) {
+  goto out_of_memory_error_for_new_quick;
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3183, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (directObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnew_quick %C => 0x%x\n", newCb, directObj) : (void)0)
+                       ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_anewarray_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3191, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMClassBlock* elemCb;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     elemCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3207, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3207, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     if (!CVManewarrayHelper(ee, topOfStack, elemCb)) {
+  goto handle_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_invokeinterface_quick: ;
+ {
+     CVMMethodBlock* imb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3220, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3220, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+            ;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     topOfStack -= ((imb)->immutX.argsSizeX);
+     mb = CVMinvokeInterfaceHelper(ee, topOfStack, imb);
+     if (mb == ((void *)0)) {
+  goto handle_exception;
+     }
+            ;
+     goto callmethod;
+ }
+ opc_invokestatic_quick: ; {
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3238, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3238, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     goto callmethod;
+ }
+ opc_invokestatic_checkinit_quick: ;
+        {
+     CVMClassBlock* cb;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3249, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3249, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     cb = (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     goto callmethod;
+ }
+ opc_invokevirtualobject_quick: ; {
+     CVMObject* directObj;
+            ;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= pc[2];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3271, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = ((((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[pc[1]]));
+            ;
+     goto callmethod;
+ }
+ opc_invokenonvirtual_quick: ; {
+     CVMObject* directObj;
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3283, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3283, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3286, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     goto callmethod;
+ }
+ opc_invokesuper_quick: ;
+        {
+     CVMObject* directObj;
+     CVMClassBlock* cb = (((CVMMethodRange*) ((CVMUint8 *)((frame->mb) - ((frame->mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+            ;
+     mb = (((((cb)->superclassX.superclassCb))->methodTablePtrX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))]);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3301, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     goto callmethod;
+ }
+        opc_invokeignored_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3311, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMObject* directObj;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tinvokeignored_quick\n") : (void)0);
+     topOfStack -= pc[1];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3315, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if (pc[2]) {
+  if ((directObj) == 0) { goto null_pointer_exception; };
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_invokevirtual_quick_w: ;
+        {
+     CVMObject* directObj;
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3332, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3332, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3335, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = (((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[((mb)->immutX.methodTableIndexX)])
+                                    ;
+            ;
+     goto callmethod;
+ }
+ opc_invokevirtual_quick: ;
+ opc_ainvokevirtual_quick: ;
+ opc_dinvokevirtual_quick: ;
+ opc_vinvokevirtual_quick: ;
+        {
+     CVMObject* directObj;
+            ;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= pc[2];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3366, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = (((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[pc[1]]);
+            ;
+                       ;
+ }
+   callmethod:
+ ;
+ {
+     CVMFrame* prev;
+     int invokerIdx;
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C.%M\n", CVMopnames[pc[0]], (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb) : (void)0)
+                                                 ;
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     prev = frame;
+    new_mb:
+     ;
+     invokerIdx = ((mb)->immutX.invokerAndAccessFlagsX >> 12);
+     if (invokerIdx < CVM_INVOKE_CNI_METHOD) {
+  CVMJavaMethodDescriptor* jmd = (*(((void)(((!((0x100 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x100) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x100) != 0)) && !((0x400 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x400) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x400) != 0)))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3409, "CVMmbIsJava(mb)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.jmd));
+  CVMClassBlock* cb;
+  locals = &topOfStack->s;
+  { CVMFrame* cf_ = (CVMFrame*)(frame); ((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || (stack)->currentFrame == ((void *)0)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMD_isgcUnsafe(ee) || (stack)->currentFrame == NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMUint32)(((jmd)->capacityX))) <= (CVMUint32)(((stack))->stackChunkEnd - ((topOfStack))))) { (frame) = (CVMFrame*)&topOfStack[(((jmd)->maxLocalsX))]; ((frame)->prevX = (cf_)); (frame)->type = CVM_FRAMETYPE_JAVA; (frame)->mb = mb; (frame)->flags = 0; if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (((void)((((((void)((((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3468, "((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)(((frame))))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMframeIsJava((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)((frame)))->jvmtiLockInfo = ((void *)0); }; if ((1 == 1)) { (stack)->currentFrame = (frame); } } else { CVMStackVal32* space_; space_ = CVMexpandStack(ee, stack, (((jmd)->capacityX)), (1 == 1), !(1 == 1)); if (space_ == 0) { (frame) = 0; { frame = stack->currentFrame;; locals = ((void *)0); goto handle_exception; }; } else { (cf_) = ((CVMFrame*)((CVMAddr)((cf_)) | ((1 << 0)))); (frame) = (CVMFrame*)&space_[(((jmd)->maxLocalsX))]; ((frame)->prevX = (cf_)); (frame)->type = CVM_FRAMETYPE_JAVA; (frame)->mb = mb; (frame)->flags = 0; if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (((void)((((((void)((((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3468, "((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)(((frame))))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMframeIsJava((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)((frame)))->jvmtiLockInfo = ((void *)0); }; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("pushing JavaFrame caused stack expansion\n") : (void)0); locals = (CVMSlotVal32*)frame - ((jmd)->maxLocalsX); memcpy((void*)locals, (void*)topOfStack, ((mb)->immutX.argsSizeX) * sizeof(CVMSlotVal32)); }; if ((1 == 1)) { (stack)->currentFrame = (frame); } } } }
+    ;
+  prev->topOfStack = topOfStack;
+  (topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3479, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3479, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX) = locals;
+  pc = ((CVMUint8*)jmd + (sizeof(CVMJavaMethodDescriptor)));
+  cb = (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+  {
+      cp = ((cb)->cpX.constantpoolX);
+  }
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX) = cp;
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodCall(ee, frame, (!(1 == 1))); };
+  ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+  if (!((0x20 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x20) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x20) != 0))) {
+      (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+      ,
+ 3515
+      , "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3515, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3515, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX))->ref_DONT_ACCESS_DIRECTLY = (((void *)0)))
+           ;
+  } else {
+      CVMObjectICell* receiverObjICell;
+      if (((0x08 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x08) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x08) != 0))) {
+   receiverObjICell = ((cb)->javaInstanceX);
+      } else {
+   receiverObjICell = &locals[0].j.r;
+      }
+      (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+      ,
+ 3525
+      , "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((receiverObjICell))->ref_DONT_ACCESS_DIRECTLY))))
+                          ;
+      receiverObjICell = &((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3527, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3527, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX);
+                    if (!CVMfastTryLock(
+       ee, (*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3531, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(receiverObjICell)->ref_DONT_ACCESS_DIRECTLY)))) {
+                        (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+                        frame->topOfStack = topOfStack;;
+                        if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3534, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(receiverObjICell)->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].lock(ee, receiverObjICell)) {
+       { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3535, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+       CVMthrowOutOfMemoryError(ee, ((void *)0));
+       goto handle_exception;
+   }
+                    }
+  }
+  { ((void)0); if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; frame->topOfStack = topOfStack;; }; CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; {}; } }
+        ;
+     } else if (invokerIdx < CVM_INVOKE_JNI_METHOD) {
+  CNIResultCode ret;
+  CVMMethodBlock *mb0 = mb;
+  CNINativeMethod *f = (CNINativeMethod *)(*(((void)((((0x100 & (0x01 | 0x03 | 0x02)) ? (((((mb))->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x100) : (((((mb))->immutX.invokerAndAccessFlagsX) & 0x100) != 0))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3594, "CVMmbIs((mb), NATIVE)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.nativeCode));
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceFramelessMethodCall(ee, frame, mb0, (!(1 == 1))); };
+  ret = (*f)(ee, topOfStack, &mb);
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceFramelessMethodReturn(ee, mb0, frame); };
+  if ((int)ret >= 0) {
+                    ((void)(((int)ret <= CNI_DOUBLE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3617, "(int)ret <= CNI_DOUBLE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+      topOfStack += (int)ret;
+      pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+      { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+  } else if (ret == CNI_NEW_TRANSITION_FRAME) {
+      frame->topOfStack = topOfStack;;
+      frame = stack->currentFrame;;
+      ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3635, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3635, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->incrementPcFlagX) = (1 == 1);
+      isStatic = ((0x08 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x08) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x08) != 0));
+      goto new_transition;
+  } else if (ret == CNI_NEW_MB) {
+      frame->topOfStack = topOfStack;;
+      frame->topOfStack += ((mb)->immutX.argsSizeX);
+      goto new_mb;
+  } else if (ret == CNI_EXCEPTION) {
+      goto handle_exception;
+  } else {
+      ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3684, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+  }
+     } else if (invokerIdx < CVM_INVOKE_ABSTRACT_METHOD) {
+  if (!CVMinvokeJNIHelper(ee, mb)) {
+      goto handle_exception;
+  }
+  topOfStack = frame->topOfStack;;
+  pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else if (invokerIdx == CVM_INVOKE_ABSTRACT_METHOD) {
+  CVMthrowAbstractMethodError(ee, "%C.%M",
+         (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb);
+  goto handle_exception;
+     } else if (invokerIdx == CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD) {
+  CVMthrowIllegalAccessError(
+                    ee, "access non-public method %C.%M through an interface",
+      (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), (*(((void)(((((mb)->immutX.invokerAndAccessFlagsX >> 12) == CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD || ((mb)->immutX.invokerAndAccessFlagsX >> 12) == CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3721, "CVMmbIsMiranda(mb)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.interfaceMb)));
+  goto handle_exception;
+     } else if (invokerIdx ==
+         CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD) {
+  CVMthrowAbstractMethodError(ee, "%C.%M",
+         (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb);
+  goto handle_exception;
+     } else if (invokerIdx == CVM_INVOKE_LAZY_JNI_METHOD) {
+  CVMBool result;
+  { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3740
+  , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { result = CVMlookupNativeMethodCode(ee, mb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3740
+  , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+    ;
+  if (!result) {
+      goto handle_exception;
+  } else {
+      goto new_mb;
+  }
+     } else {
+  CVMconsolePrintf ("Unkown method invoker: %d\n", invokerIdx);
+  ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3755, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     }
+ };
+ { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+    return_from_executejava_branch_island: {
+        ;
+        pc = 0;
+        return;
+    }
+    handle_exception: {
+     ;
+     {
+  { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = (
+ (((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+     }
+    handle_exception_tos_already_reset:
+     ;
+     ((void)((((ee)->exceptionFlags.bothflags != 0 && ((((ee)->exceptionFlags.oneflag.local) != 0) || ((!(1 == 1)))))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3800, "CVMexceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     frame = CVMgcUnsafeHandleException(ee, frame, initialframe);
+     if (frame == initialframe) {
+                if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+  goto finish;
+     }
+     {
+  pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+  (topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3846, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3846, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+  locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+  cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3853
+     , "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3853, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(((ee)->currentExceptionICell))->ref_DONT_ACCESS_DIRECTLY)))))
+                                   ;
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3854, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((ee)->currentExceptionICell))->ref_DONT_ACCESS_DIRECTLY = (((void *)0)));;
+     topOfStack++;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+    init_class:
+ ;
+ {
+            int result;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s ==> running static initializers...\n", CVMopnames[pc[0]]) : (void)0)
+                        ;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3892
+     , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { result = CVMclassInitNoCRecursion(ee, initCb, &mb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3892
+     , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+       ;
+     if (result == 0) {
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else if (result == 1) {
+  frame = stack->currentFrame;;
+  isStatic = (!(1 == 1));
+  goto new_transition;
+     } else {
+  goto handle_exception;
+     }
+        }
+    opc_exittransition_overflow:
+ ;
+        {
+     char retType;
+     CVMBool incrementPC;
+     if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+     ((void)((!(((ee)->exceptionFlags.oneflag.local) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3940, "!CVMlocalExceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     retType =
+  CVMtypeidGetReturnType(((frame->mb)->immutX.nameAndTypeIDX));
+     if (retType == 2) {
+  topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3957, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     } else if ((retType == 6) ||
+         (retType == 9)) {
+  topOfStack = CVMreturn64Helper(topOfStack, frame);
+  topOfStack += 2;
+     } else {
+  CVMJavaVal32 result = ((topOfStack[-1].s).j);
+  topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3973, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+  ((topOfStack[0].s).j) = result;
+  topOfStack++;
+     }
+     incrementPC = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3982, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3982, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->incrementPcFlagX);
+     { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3984, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+     cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     if (incrementPC) {
+  pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else {
+  {
+      const void* nextLabel;;
+      nextLabel = opclabels[pc[0]];;
+      ;
+      goto *nextLabel;;
+  }
+     }
+ }
+        opc_d2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4153, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMd2lHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_d2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4160, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    {
+     CVMd2iHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2i => %d\n", (((topOfStack[-2].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_l2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4167, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMl2dHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4174, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMi2dHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_goto_w: ;
+ {
+     CVMInt32 skip = ((CVMInt32) (((*(CVMUint8*)((pc + 1)+(0))) << 24) | ((*(CVMUint8*)((pc + 1)+(1))) << 16) | ((*(CVMUint8*)((pc + 1)+(2))) << 8) | (*(CVMUint8*)((pc + 1)+(3)))));
+            ;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n", CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+            ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_jsr_w: ;
+        {
+     CVMInt32 skip = ((CVMInt32) (((*(CVMUint8*)((pc + 1)+(0))) << 24) | ((*(CVMUint8*)((pc + 1)+(1))) << 16) | ((*(CVMUint8*)((pc + 1)+(2))) << 8) | (*(CVMUint8*)((pc + 1)+(3)))));
+            ;
+     ((topOfStack[0].s).a) = pc + 5;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n", CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_aldc_ind_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4203, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMObjectICell* strICell =
+  (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4205, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_StringICell)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4205, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), StringICell)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.strICell);
+     (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4206, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4206, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((strICell))->ref_DONT_ACCESS_DIRECTLY))));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_aldc_w_quick: ;
+        opc_ldc_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4213, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+            ((topOfStack[0].s).j) = ((cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.val32);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((topOfStack[0].s).j).i)) : (void)0)
+                                      ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        opc_ldc2_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4219, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+  {
+     CVMldc2_wHelper(topOfStack, cp, pc);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_ldc2_w_quick #%d => long=%s double=%g\n", ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0)
+                                                                    ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+        opc_getfield_quick_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4228, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     topOfStack = CVMgetfield_quick_wHelper(ee, frame, topOfStack,
+         cp, pc);
+     if (topOfStack == ((void *)0)) {
+  goto null_pointer_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield_quick_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4238, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     topOfStack = CVMputfield_quick_wHelper(ee, frame, topOfStack,
+         cp, pc);
+     if (topOfStack == ((void *)0)) {
+  goto null_pointer_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_wide: ;
+ {
+            ;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     if (CVMwideHelper(ee, locals, frame)) {
+  if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+      goto handle_pending_request;
+  }
+     }
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     topOfStack = frame->topOfStack;;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+        }
+ opc_prefix: ;
+ {
+     goto unimplemented_opcode;
+ }
+    handle_pending_request:
+ {
+     ;
+  {
+      { ((void)0); if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; frame->topOfStack = topOfStack;; }; CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; {}; } }
+            ;
+      { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+                }
+ }
+ ;
+ opc_getfield: ;
+ opc_putfield: ;
+        opc_invokevirtual: ;
+        opc_invokespecial: ;
+     goto quicken_opcode_clobber;
+ opc_getstatic: ;
+        opc_putstatic: ;
+        opc_invokestatic: ;
+ opc_invokeinterface: ;
+ opc_new: ;
+ opc_ldc2_w: ;
+ opc_anewarray: ;
+ opc_checkcast: ;
+ opc_instanceof: ;
+ opc_multianewarray: ;
+     goto quicken_opcode_noclobber;
+        opc_ldc: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4337, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+ {
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMldcHelper(ee, topOfStack, cp, pc)) {
+  if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+      goto handle_exception;
+  }
+  goto quicken_opcode_noclobber;
+     }
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_ldc_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4350, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMldc_wHelper(ee, topOfStack, cp, pc)) {
+  if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+      goto handle_exception;
+  }
+  goto quicken_opcode_noclobber;
+     }
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ {
+     CVMQuickenReturnCode retCode;
+     CVMClassBlock *cb;
+     CVMBool clobbersCpIndex;
+    quicken_opcode_noclobber:
+     clobbersCpIndex = (!(1 == 1));
+     goto quicken_opcode;
+    quicken_opcode_clobber:
+     clobbersCpIndex = (1 == 1);
+    quicken_opcode:
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s ==> quickening...\n", CVMopnames[pc[0]]) : (void)0);
+     retCode = CVMquickenOpcode(ee, pc, cp, &cb, clobbersCpIndex);
+     switch (retCode) {
+         case CVM_QUICKEN_ALREADY_QUICKENED:
+      break;
+         case CVM_QUICKEN_NEED_TO_RUN_STATIC_INITIALIZERS:
+      initCb = cb;
+      goto init_class;
+         case CVM_QUICKEN_ERROR: {
+      ((void)((((ee)->exceptionFlags.bothflags != 0 && ((((ee)->exceptionFlags.oneflag.local) != 0) || ((!(1 == 1)))))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4396, "CVMexceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+      goto handle_exception;
+  }
+         default:
+      ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4400, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     }
+     {
+  const void* nextLabel;;
+  nextLabel = opclabels[pc[0]];;
+  ;
+  goto *nextLabel;;
+     }
+ }
+        opc_multianewarray_quick: { const void* nextLabel; ; ((void)((4 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4421, "4 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[4]];;
+ {
+     CVMClassBlock* arrCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4423, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4423, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMmultianewarrayHelper(ee, arrCb)) {
+  goto handle_exception;
+     }
+     topOfStack = frame->topOfStack;;
+     { pc += 4; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_xxxunusedxxx: ;
+     goto unimplemented_opcode;
+ opc_DEFAULT: ;
+ unimplemented_opcode:
+     CVMconsolePrintf ("\t*** Unimplemented opcode: %d = %s\n", pc[0], CVMopnames[pc[0]])
+                               ;
+     goto finish;
+ }
+    }
+    null_pointer_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowNullPointerException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    out_of_memory_error:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowOutOfMemoryError(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    array_index_out_of_bounds_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArrayIndexOutOfBoundsException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    array_store_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArrayStoreException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    arithmetic_exception_divide_by_zero:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArithmeticException(ee, "/ by zero"); goto handle_exception_tos_already_reset; };
+    illegal_monitor_state_exception_thread_not_owner:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = (
+ (((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowIllegalMonitorStateException(ee, "current thread not owner"); goto handle_exception_tos_already_reset; };
+    out_of_memory_error_for_new_quick:
+    ;
+    {
+ CVMClassBlock* newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4600, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4600, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+ CVMthrowOutOfMemoryError(ee, "%C", newCb);
+ goto handle_exception_tos_already_reset;
+    }
+    class_cast_exception:
+    ;
+    {
+ CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4608, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ CVMClassBlock* cb = ((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3));
+ (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+ (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4611, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4611, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+ if (!(((ee)->exceptionFlags.oneflag.local) != 0)) {
+     CVMthrowClassCastException(ee, "%C", cb);
+ }
+ goto handle_exception_tos_already_reset;
+    }
+ finish:
+    ;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("Exiting interpreter\n") : (void)0);
+    frame->topOfStack = topOfStack;;
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    return;
+}
diff -ruN gcc-4.8.4/libiberty/config/mh-mingw gcc-4.8.4-stm.150128/libiberty/config/mh-mingw
--- gcc-4.8.4/libiberty/config/mh-mingw	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libiberty/config/mh-mingw	2013-05-28 13:17:15.962597000 +0200
@@ -0,0 +1 @@
+EXTRA_OFILES=cygpath.o wrap_file.o
diff -ruN gcc-4.8.4/libiberty/configure gcc-4.8.4-stm.150128/libiberty/configure
--- gcc-4.8.4/libiberty/configure	2013-05-23 10:25:29.376545000 +0200
+++ gcc-4.8.4-stm.150128/libiberty/configure	2013-05-28 13:17:15.962597000 +0200
@@ -4842,6 +4842,7 @@
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [ -n "${frag}" ]; then
diff -ruN gcc-4.8.4/libiberty/configure.ac gcc-4.8.4-stm.150128/libiberty/configure.ac
--- gcc-4.8.4/libiberty/configure.ac	2013-05-23 10:25:29.376545000 +0200
+++ gcc-4.8.4-stm.150128/libiberty/configure.ac	2013-05-28 13:17:15.962597000 +0200
@@ -185,6 +185,7 @@
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff -ruN gcc-4.8.4/libiberty/cygpath.c gcc-4.8.4-stm.150128/libiberty/cygpath.c
--- gcc-4.8.4/libiberty/cygpath.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libiberty/cygpath.c	2013-05-28 13:17:15.962597000 +0200
@@ -0,0 +1,358 @@
+/* Basic Cygwin pathname support for MinGW.
+
+   Copyright (C) 2006 STMicroelectronics
+
+   This file is part of the libiberty library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+
+   This file implements a limited amount of support for Cygwin paths.
+   It is intended for use by MinGW programs that must interact with Cygwin.
+
+   It is limited to absolute paths only.  I.e. Those beginning with Cygwin
+   mounts, such as /cygdrive/...  See the comment on cygpath() below.  */
+
+#include "libiberty.h"
+#include <string.h>
+#include <ctype.h>
+#include <windows.h>
+
+
+/* These are all the possible settings for the ST_CYGPATH_MODE
+   environment variable.  */
+static enum
+{
+  mode_unset,
+  mode_off,
+  mode_normal,
+  mode_full
+} mode = mode_unset;
+
+
+/* These are the values extracted from the registry.
+   They are extracted the first time cygpath is called.  */
+static const char *cygdrive = NULL;
+static struct mount
+{
+  /* The name of the Cygwin mount point.  E.g. "/usr/bin"  */
+  char *mount;
+
+  /* The actual Windows path that the mount translates to.  */
+  char *actual;
+
+  struct mount *next;
+} *mounts = NULL;
+
+
+/* Read a string from the Windows Registry.
+   KEY should be a valid handle from RegOpenKeyEx().
+   NAME should be the name of the value within the key.
+   The value should be of type REG_SZ.
+   If the value does not exist, is of the wrong typei, or another error
+   occurs, then NULL is returned.
+   Otherwise a malloced string is returned.  */
+static char *
+read_string_from_registry (HKEY key, const char *name)
+{
+  DWORD valuetype = REG_NONE;
+  DWORD valuesize = 0;
+  char *value = NULL;
+
+  if (RegQueryValueEx (key, name, NULL, &valuetype,
+		       NULL, &valuesize) == ERROR_SUCCESS
+      && valuetype == REG_SZ)
+    {
+      value = (char *)xmalloc (valuesize);
+      if (RegQueryValueEx (key, name, NULL, &valuetype, (unsigned char *)value,
+			   &valuesize) != ERROR_SUCCESS)
+	{
+	  free (value);
+	  value = NULL;
+	}
+    }
+
+  return value;
+}
+
+
+/* Fill in the mounts list (mounts is defined statically above).
+   All subkeys (not values) of KEY that contain a REG_SZ value named 'native'
+   are added to the start of the mounts list.  */
+static void
+read_mounts (HKEY key)
+{
+  int mountsize = 15;
+  char *mount = (char *)xmalloc (mountsize);
+  DWORD size = mountsize;
+  int index = 0;
+  int retval = 0;
+
+  /* For each subkey ...  */
+  while ((retval = RegEnumKeyEx (key, index, mount, &size, 0, NULL, 0, NULL))
+	 != ERROR_NO_MORE_ITEMS)
+    {
+      struct mount *newmount;
+      HKEY subkey;
+      char *actual;
+
+      switch (retval) {
+      case ERROR_MORE_DATA:
+	/* The buffer wasn't large enough for this key name.
+	   Unlike RegQueryValueEx, RegEnumKeyEx won't tell us how big it
+	   should be, so just make it bigger and try again.
+	   Note that this code path does NOT increment index.
+       	   Most of the time we will only be dealing with short strings.  */
+	mountsize += 10;
+	mount = (char *)xrealloc (mount, mountsize);
+	break;
+
+      case ERROR_SUCCESS:
+	/* Find the actual windows path.  */
+  	if (RegOpenKeyEx (key, mount, 0, KEY_READ, &subkey) != ERROR_SUCCESS)
+	  {
+	    index++;
+	    break;
+	  }
+	actual = read_string_from_registry (subkey, "native");	
+	RegCloseKey (subkey);
+	if (actual == NULL)
+	  {
+	    index++;
+	    break;
+	  }
+
+	/* Create the new entry in the mount table.  */
+	newmount = (struct mount *)xmalloc (sizeof (struct mount));
+	newmount->mount = xstrdup (mount);
+	newmount->actual = actual;
+	newmount->next = mounts;
+	mounts = newmount;
+	index++;
+	break;
+
+      default:
+	/* Don't infinite loop should any other return value occur.  */
+        index++;
+      }
+
+      /* The last call to RegEnumKeyEx may have clobbered size.
+         Fix it before the next call.  */
+      size = mountsize;
+    }
+
+  free (mount);
+}
+
+
+/* The top level registry reading function.
+   Open the keys, call the above functions to get the right values,
+   and clean up.  */
+static void
+read_registry (void)
+{
+  HKEY hcu_key, hlm_key;
+
+  /* Get key handles for the two places cygwin keeps its registry data.  */
+  if (RegOpenKeyEx (HKEY_CURRENT_USER,
+		    "Software\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hcu_key) != ERROR_SUCCESS)
+    hcu_key = NULL;
+
+  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
+		    "SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hlm_key) != ERROR_SUCCESS)
+    hlm_key = NULL;
+
+  /* Get the virtual mount point used for windows drives.  */
+  if (hcu_key)
+    cygdrive = read_string_from_registry (hcu_key, "cygdrive prefix");
+  if (hlm_key && cygdrive == NULL)
+    cygdrive = read_string_from_registry (hlm_key, "cygdrive prefix");
+
+  /* Read the other mount points.
+     Read hlm before hcu to ensure hcu settings get used by preference
+     by being closer on the mounts stack.  */
+  if (hlm_key)
+    read_mounts (hlm_key);
+  if (hcu_key)
+    read_mounts (hcu_key);
+
+  if (hlm_key)
+    RegCloseKey (hlm_key);
+  if (hcu_key)
+    RegCloseKey (hcu_key);
+}
+
+
+/* Given a path of unknown variety, return the same path with any
+   Cygwin mount points substituted.
+   This function always returns a malloced string which should be
+   freed when the the caller is finished with it.
+
+   The mapping is affected by the ST_CYGPATH_MODE environment variable.
+   See the fprintf messages below for full information.
+
+   It can replace /cygdrive/<letter>/..... style pathnames, even if the
+   user has used 'mount -c' to an alternative string.
+
+   It can replace (if enabled) other Cygwin mount points, such as
+   the usual '/', '/usr/bin', '/usr/lib', as well as any other user defined
+   mount points.
+
+   It does NOT attempt to convert any pathnames that look like native Windows
+   names - such as those starting with '<letter>:' or double slash (UNC).
+
+   It does NOT handle relative pathnames passing through cygwin mounts
+   (e.g. '../cygdrive/c'), or absolute paths with repeated directory
+   separators or relative elements within the mount name
+   (e.g. '/usr/./bin').
+   
+   It does NOT allow backslash \ directory separators within the actual mount
+   path (e.g. '/usr\bin').  Cygwin does not always allow them there either.  */
+char *
+cygpath (const char *path)
+{
+  char *result = NULL;
+
+  if (path == NULL)
+    return NULL;
+
+  /* If this is the first time this function has been called then read the
+     environment and registry.  */
+  if (mode == mode_unset)
+    {
+      char *env = getenv ("ST_CYGPATH_MODE");
+
+      if (env == NULL || strcmp (env, "normal") == 0)
+    	mode = mode_normal;
+      else if (strcmp (env, "full") == 0)
+	mode = mode_full;
+      else if (strcmp (env, "off") == 0)
+	mode = mode_off;
+
+      if (mode != mode_off)
+	read_registry();
+
+      if (mode == mode_unset)
+	{
+	  /* The variable was set, but not to any known value.
+	     Set up a default and print an informational message
+	     for the user.  */
+	  mode = mode_normal;
+	  fprintf (stderr, "ST_CYGPATH_MODE should be one of:\n");
+	  fprintf (stderr, " off    - Disable all path translation.\n");
+	  fprintf (stderr, " normal - Translate %s only.\n", cygdrive);
+	  fprintf (stderr, " full   - Translate all Cygwin mounts.\n");
+	}
+    }
+
+  /* First, test if this can only be a windows (non-cygwin) path.
+     This includes paths that start with a drive letter or UNC double slash.  */
+  if ((isalpha (path[0]) && path[1] == ':')
+      || ((path[0] == '\\' || path[0] == '/')
+	  && (path[1] == '\\' || path[1] == '/')))
+    result = xstrdup (path);
+
+  /* Second, handle /cygdrive/<letter>/ (or whatever) paths.  */
+  if (!result && cygdrive != NULL && (mode == mode_normal || mode == mode_full))
+    {
+      int length = strlen (cygdrive);
+      /* Note that cygwin does not allow '\\' instead of '/' in cygdrive.  */
+      if (strncmp (cygdrive, path, length) == 0
+	  && (path[length] == '/' || path[length] == '\\'
+	      || path[length] == '\0')
+	  && isalpha (path[length+1]))
+        {
+	  result = (char *)xmalloc (strlen (path) - length+1 + 1);
+	  result[0] = path[length+1];
+	  result[1] = ':';
+	  strcpy (result + 2, path + length + 2);
+	}
+    }
+
+  /* Third, handle other types of cygwin path.  */
+  if (!result && mounts != NULL && mode == mode_full)
+    {
+      int matched = 0;
+      struct mount *foundat = NULL;
+      struct mount *mount = mounts;
+      /* Find the longest matching mount point.
+	 This is important. If we just used the first matching mount point
+	 it would probably always match '/' when '/usr/bin' is right.
+	 Use the first of equal length matches - this allows current-user
+	 mounts to override 'local machine' mounts (can this happen?).
+         It is a match only if the matching part is followed by a directory
+         separator or the end of the path, except for the root mount point.  */
+      while (mount != NULL)
+	{
+	  int length = strlen (mount->mount);
+	  if (strncmp (mount->mount, path, length) == 0
+	      && matched < length
+	      && (length == 1 /* Special case for root mount point '/'.  */
+		  || path[length] == '/' || path[length] == '\\'
+		  || path[length] == '\0'))
+	    {
+	      matched = length;
+	      foundat = mount;
+	    }
+	  mount = mount->next;
+	}
+      if (matched)
+	{
+	  /* There was a match so do the substitution.
+	     If matched is 1 then it can only be the root mount point, in
+	     which case we do not want to remove the matched part as it is the 
+	     directory separator.  */
+	  if (matched == 1)
+	    matched = 0;
+	  result = (char *)xmalloc (strlen (foundat->actual) + strlen (path) + 1
+			    - matched);
+	  strcpy (result, foundat->actual);
+	  strcat (result, path + matched);
+	}
+    }
+
+  if (result)
+    {
+      /* Ensure that the return is never just a drive letter.
+	 This is not a valid directory on Windows, but code often
+	 trims trailing slashes.  */
+      int length = strlen(result);
+      if (result[length-1] == ':')
+	{
+	  result = (char *)xrealloc (result, length+2);
+	  result[length] = '/';
+	  result[length+1] = '\0';
+	}
+      return result;
+    }
+
+  /* If we get here then it must have been some other kind of path.  */
+  return xstrdup (path);
+}
+
+
+/* This is just to make inserting the conversion more convenient.
+   The CYGPATH_REPLACE is conditionally compiled so it is harder to
+   add clean up code to go with it without this.  */
+void
+cygpath_replace (char **path)
+{
+  char *result = cygpath (*path);
+  free (*path);
+  *path = result;
+}
diff -ruN gcc-4.8.4/libiberty/Makefile.in gcc-4.8.4-stm.150128/libiberty/Makefile.in
--- gcc-4.8.4/libiberty/Makefile.in	2013-05-23 10:25:29.376545000 +0200
+++ gcc-4.8.4-stm.150128/libiberty/Makefile.in	2013-05-28 13:17:15.962597000 +0200
@@ -125,7 +125,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c crc32.c				\
+	 cp-demint.c cplus-dem.c crc32.c cygpath.c			\
 	dwarfnames.c dyn-string.c					\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -155,7 +155,7 @@
 	timeval-utils.c tmpnam.c					\
 	unlink-if-ordinary.c						\
 	vasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c	\
-	waitpid.c							\
+	waitpid.c wrap_file.c						\
 	xatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c	\
 	 xstrndup.c
 
@@ -199,7 +199,7 @@
 	./basename.$(objext) ./bcmp.$(objext) ./bcopy.$(objext)		\
 	./bsearch.$(objext) ./bzero.$(objext)				\
 	./calloc.$(objext) ./clock.$(objext) ./copysign.$(objext)	\
-	./_doprnt.$(objext)						\
+	./cygpath.$(object) ./_doprnt.$(objext)				\
 	 ./ffs.$(objext)						\
 	./getcwd.$(objext) ./getpagesize.$(objext)			\
 	 ./gettimeofday.$(objext)					\
@@ -222,7 +222,7 @@
 	./tmpnam.$(objext)						\
 	./vasprintf.$(objext) ./vfork.$(objext) ./vfprintf.$(objext)	\
 	 ./vprintf.$(objext) ./vsnprintf.$(objext) ./vsprintf.$(objext)	\
-	./waitpid.$(objext)
+	./waitpid.$(objext) ./wrap_file.$(object)
 
 # These files are installed if the library has been configured to do so.
 INSTALLED_HEADERS =                                                     \
@@ -637,6 +637,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/dyn-string.c $(OUTPUT_OPTION)
 
+./cygpath.$(objext): $(srcdir)/cygpath.c $(INCDIR)/ansidecl.h \
+	 $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./fdmatch.$(objext): $(srcdir)/fdmatch.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
@@ -1230,6 +1237,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/waitpid.c $(OUTPUT_OPTION)
 
+./wrap_file.$(objext): $(srcdir)/wrap_file.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/wrap_file.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/wrap_file.c $(OUTPUT_OPTION)
+
 ./xatexit.$(objext): $(srcdir)/xatexit.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -ruN gcc-4.8.4/libiberty/wrap_file.c gcc-4.8.4-stm.150128/libiberty/wrap_file.c
--- gcc-4.8.4/libiberty/wrap_file.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.8.4-stm.150128/libiberty/wrap_file.c	2013-05-28 13:17:15.962597000 +0200
@@ -0,0 +1,138 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+*/
+/*
+ * wrap_fopen.c
+ *
+ * This file redefines the standard library functions 
+ * open, create, fopen, fdopen, freopen, remove, rename, unlink, stat for native WIN32 build.
+ * Its purpose is to preprocess argument strings in order to
+ * convert CYGWIN like paths specifiers into native WIN32 paths
+ * It uses the GNU ld -wrap functionality to replace
+ * at link time calls to fopen into calls to __wrap_fopen.
+ *
+ * This file must be linked with any DLL or EXE object
+ * and the linker command line must have the following  option:
+ * -Wl,-wrap,open,-wrap,creat,-wrap,fopen,-wrap,freopen,-wrap,remove,-wrap,rename,-wrap,unlink,-wrap,stat
+ *
+ */
+
+#ifdef __MINGW32__
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <unistd.h>
+
+#include "libiberty.h"
+
+/*
+ * Declare real versions of functions.
+ */
+extern int __real_open (const char *pathname, int flags, mode_t mode);
+extern int __real_creat (const char *pathname, mode_t mode);
+extern FILE *__real_fopen (const char *path, const char *mode);
+extern FILE *__real_freopen (const char *path, const char *mode, FILE *stream);
+extern int __real_unlink (const char *pathname);
+extern int __real_remove (const char *pathname);
+extern int __real_stat (const char *file_name, struct stat *buf);
+extern int __real_chdir (const char *path);
+extern int __real_rmdir (const char *pathname); 
+extern DIR *__real_opendir (const char *name);
+extern int __real_access (const char *pathname, int mode);
+
+/*
+ * Following is the implementation of replacement functions.
+ */
+int 
+__wrap_open (const char *pathname, int flags, mode_t mode)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_open (path, flags, mode);
+  return r;
+}
+
+int 
+__wrap_creat (const char *pathname, mode_t mode)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_creat (path, mode);
+  return r;
+}
+
+FILE *
+__wrap_fopen (const char *pathname, const char *mode)
+{
+  FILE *f;
+  char *path = cygpath (pathname);
+  f = __real_fopen (path, mode);
+  return f;
+}
+
+FILE *__wrap_freopen (const char *pathname, const char *mode, FILE *stream)
+{
+  FILE *f;
+  char *path = cygpath (pathname);
+  f = __real_freopen (path, mode, stream);
+  return f;
+}
+
+int __wrap_unlink (const char *pathname) 
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_unlink (path);
+  return r;
+}
+
+int __wrap_remove (const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_remove (path);
+  return r;
+}
+
+int __wrap_stat(const char *pathname, struct stat *buf)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_stat (path, buf);
+  return r;
+}
+
+int __wrap_chdir(const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_chdir (path);
+  return r;
+}
+
+int __wrap_rmdir(const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_rmdir (path);
+  return r;
+}
+
+DIR *__wrap_opendir(const char *pathname)
+{
+  DIR *d;
+  char *path = cygpath (pathname);
+  d = __real_opendir (path);
+  return d;
+}
+
+int __wrap_access(const char *pathname, int mode)
+{
+  int r; 
+  char *path = cygpath (pathname);
+  r = __real_access (path, mode);
+  return r;
+}
+
+#endif /* __MINGW32__ */
